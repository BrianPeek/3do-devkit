/*
        File:		ourVDL.c

        Contains:	This file contains routines to mess around with video
   display lists.

        Written by:	eric carlson

        Copyright:	© 1993 by The 3DO Company. All rights reserved.
                                This material constitutes confidential and
   proprietary information of the 3DO Company and shall not be used by any
   Person or for any purpose except as expressly authorized in writing by the
   3DO Company.

        Change History (most recent first):

                 <4>	 8/11/93	JAY		remove 2 filler words
   from DMA control word 'length' field because of change in SubmitVDL's
   verification process. check DMA control word of vlds loaded from disk and
   adjust if length field includes filler words <3>	 6/23/93	JAY
   intergrated ec's changes for Dragon (4B1) <2>	 3/18/93	JAY
   commented out tempLong local variable. It is not used <1>	 3/18/93
   JAY		first checked in
                                2/17/93		ec		Added VDL
   diddling routines. 2/15/93		ec		Add CorrectVDL for
   Magneto6
                                 2/5/93		ec		Change for VDL
   structure generated by PS export module
                                12/5/92		ec		New Today

        To Do:
*/

#undef KERNEL

#include "Portfolio.h"
#include "debug.h"

#include "ourVDL.h"

//	Defined in Slideshow24.c
extern int32 PALmode;

// some globals
short gCurrFieldNum = 0;

//  Convert an 8 bit value into a long with two indexes
long
Convert8 (int32 n)
{
  long x, y;

  if (n < 128)
    {
      x = n & 0x07;
      y = 31 - (n >> 3);
    }
  else
    {
      x = (n & 0x07) + 8;
      y = 30 - ((n & 0x7F) >> 3);
    }

  return (y << 16) | x;
}

//	Convert a 16 bit pixel to a 24 bit pixel
long
ConvertPixel (int32 pixel)
{
  return (Convert8 ((pixel >> 7) & 0xF8) << 10)
         | (Convert8 ((pixel >> 2) & 0xF8) << 5)
         | Convert8 ((pixel << 3) & 0xF8);
}

//	Draw a LR image in 24 bits to prove it works
void
DrawImage24 (int32 *image, Bitmap *destBitmap)
{
  int32 *line0, *line1, x, y;

  line0 = (long *)destBitmap->bm_Buffer;
  line1 = line0 + 320;
  for (y = 0; y < 120; y++)
    {
      for (x = 0; x < 320; x++)
        {
          *line0++ = ConvertPixel (*image >> 16);
          *line1++ = ConvertPixel (*image & 0xFFFF);
          image++;
        }
      line0 += 320;
      line1 += 320;
    }
}

void
InitVDL480 (int32 *vdl, Bitmap *destBitmap, int32 bitmapindex, int32 PALmode)
{
  int32 j;

  if (PALmode)
    vdl[0] = VDL_ENVIDDMA | VDL_LDCUR | VDL_LDPREV | (34 << VDL_LEN_SHIFT)
             | VDL_PREVSEL | (288 << VDL_LINE_SHIFT) | VDL_DISPMOD_384
             | VDL_480RES;
  else
    vdl[0] = VDL_ENVIDDMA | VDL_LDCUR | VDL_LDPREV | (34 << VDL_LEN_SHIFT)
             | VDL_PREVSEL | (240 << VDL_LINE_SHIFT) | VDL_DISPMOD_320
             | VDL_480RES;
  vdl[1] = ((uint32)destBitmap->bm_Buffer);
  vdl[2] = ((uint32)destBitmap->bm_Buffer) + 2;
  vdl[3] = (int32)(vdl + 40);
  for (j = 0; j < 8; j++)
    vdl[4 + j] = (j << 24) | (j * 2 * 0x00010101);

  for (j = 8; j < 16; j++)
    vdl[4 + j] = (j << 24) | ((j + j + 225) * 0x00010101);

  for (j = 16; j < 32; j++)
    vdl[4 + j] = (j << 24) | (((31 - j) * 16) * 0x00010101);

  vdl[4 + 32] = VDL_DISPCTRL | VDL_BACKGROUND | 0;
  vdl[4 + 33] = VDL_DISPCTRL | VDL_VINTEN | VDL_HSUB_ZERO | VDL_BLSB_BLUE
                | (int32)(bitmapindex ? VDL_VSUB_ONE : VDL_VSUB_ZERO);
  for (j = 4 + 34; j < 40; j++)
    vdl[j] = VDL_NULLVDL;

#if 0	
	if (PALmode)
		vdl[40] = (34<<VDL_LEN_SHIFT)
				| (0<<VDL_LINE_SHIFT)
				| VDL_DISPMOD_320
				| VDL_480RES;
	else
		vdl[40] = (34<<VDL_LEN_SHIFT)
				| (0<<VDL_LINE_SHIFT)
				| VDL_DISPMOD_384
				| VDL_480RES;
	vdl[41] = ((uint32)destBitmap->bm_Buffer);
	vdl[42] = ((uint32)destBitmap->bm_Buffer) + 2;
	vdl[43] = (int32)(vdl+80);
	for (j=0; j<8; j++) 
		vdl[44+j] = (j<<24)|(j*2*0x00010101);
	
	for (j=8; j<16; j++)
		vdl[44+j] = (j<<24)|((j+j+225)*0x00010101);
	
	for (j=16; j<32; j++)
		vdl[44+j] = (j<<24)|(((31-j)*16)*0x00010101);
	
	vdl[44+32] = VDL_DISPCTRL
				|VDL_BACKGROUND | 0;
	vdl[44+33] = VDL_DISPCTRL
				| VDL_VINTEN
				| VDL_HSUB_ZERO
				| VDL_BLSB_BLUE
				|(int32)(bitmapindex ? VDL_VSUB_ONE : VDL_VSUB_ZERO);
	for (j=44+34; j<40+40; j++)
		vdl[j] = VDL_NULLVDL;

	if (PALmode)
		vdl[80] = (34<<VDL_LEN_SHIFT)|(17<<VDL_LINE_SHIFT)|VDL_DISPMOD_320|VDL_480RES;
	else
		vdl[80] = (34<<VDL_LEN_SHIFT)|(17<<VDL_LINE_SHIFT)|VDL_DISPMOD_384|VDL_480RES;
	vdl[81] = ((uint32)destBitmap->bm_Buffer);
	vdl[82] = ((uint32)destBitmap->bm_Buffer) + 2;
	vdl[83] = (int32)GrafBase->gf_VDLPostDisplay;
	for (j=0; j<8; j++)
		vdl[84+j] = (j<<24)|(j*2*0x00010101);
	
	for (j=8; j<16; j++)
		vdl[84+j] = (j<<24)|((j+j+225)*0x00010101);
	
	for (j=16; j<32; j++)
		vdl[84+j] = (j<<24)|(((31-j)*16)*0x00010101);
	
	vdl[84+32] = VDL_DISPCTRL
				| VDL_BACKGROUND|0;
	vdl[84+33] = VDL_DISPCTRL
				| VDL_VINTEN
				| VDL_HSUB_ZERO
				| VDL_BLSB_BLUE
				|(int32)(bitmapindex ? VDL_VSUB_ONE : VDL_VSUB_ZERO);
	for (j=84+34; j<80+40; j++)
		vdl[j] = VDL_NULLVDL;
#endif
}

/*
 * Build a vdl DMA clut control word.
 */
int32
SetDMACtlWord (int32 clutColorWords, int32 scanLineCount, Boolean lastScanLine)
{
  // the standard clut control flags are:
  //		link to next color set is relative
  //		use "current frame buffer" address from this color set
  //		use "previous frame buffer" address from this color set

  DMAControlWord clutCtlWord;

  // zero all fields to begin with
  LONGWORD (clutCtlWord) = 0;

  clutCtlWord.useCurrentLineAddr = true;
  clutCtlWord.usePreviousLineAddr = true;
  clutCtlWord.numColorWords = (int)clutColorWords;
  clutCtlWord.scanLines = (int)scanLineCount;

  clutCtlWord.displayMode = PALmode ? 0x01 : 0x00;

  // if this isn't for the last scanline, next address is relative
  if (!lastScanLine)
    {
      clutCtlWord.relativeAddrNextCLUT = true;
      clutCtlWord.videoDMA = true;
    }

  return LONGWORD (clutCtlWord);
}

/*
 *	Build a VDL display control word.
 */
int32
SetDisplayCtlWord (Boolean Hinterp, Boolean Vinterp, Boolean clutBypass)
{
  VDLDisplayCtlWord displayControl;

  LONGWORD (displayControl) = 0;

  displayControl.controlWord = 1;
  displayControl.controlWordType = 1;
  if (Hinterp)
    {
      displayControl.horizontalInterpolation = 1;
      displayControl.windowHorizontalInterp = 1;
    }
  if (Vinterp)
    {
      displayControl.verticalInterpolation = 1;
      displayControl.windowVerticalInterp = 1;
    }

  displayControl.blueLSBSource = 2; // use bit 0 of frame-buffer data
  displayControl.HSource = 0;       // not from frame, but zero always
  displayControl.VSource = 0;       // not from frame, but zero always

  displayControl.windowBlueLSBSource = 2; // use bit 0 of frame-buffer data
  displayControl.windowHSource = 0;
  displayControl.windowVSource = 0;

  if (clutBypass)
    {
      displayControl.bypassCLUT = 1;
      displayControl.bypassLSBIsRandom = 1;
      // displayControl.windowMSBReplicate = 0;
    }

  return LONGWORD (displayControl);
}

/*
 * Fill in a ‘simple’ VDL - One CLUT for the screen with CLUTByPass Enabled
 */
void
InitSimpleVDL (SVDL *v, Bitmap *destBitmap, int32 PALmode)
{
  int32 scanLine, colorTableEntry;
  uint32 i;
  uint32 color;

  v->SVDLDMA
      = SetDMACtlWord (kClutColorWords - kFillerWords, myScreenHeight, false);
  v->SVDLCurBuf = ((uint32)destBitmap->bm_Buffer);
  v->SVDLPrevBuf = v->SVDLCurBuf;
  v->SVDLNextVDL = 0;
  v->SVDLDisplay = SetDisplayCtlWord (true, true, true);
  v->backgroundEntry = 0xE0000000;
  for (i = 0; i < kCLUTWords; i++)
    {
      color
          = (i * 0x41D) / 0x80; // This line matches the system default values
      color &= 0xFF;
      v->SVDLColors[i].index = (int)i;
      v->SVDLColors[i].select = (int)0;
      v->SVDLColors[i].flag = (int)0;
      v->SVDLColors[i].red = (int)color;
      v->SVDLColors[i].green = (int)color;
      v->SVDLColors[i].blue = (int)color;
    }
  v->SVDLFiller1 = VDL_NULLVDL;
  v->SVDLFiller1 = VDL_NULLVDL;
}

/*
 * Fill in a ‘standard’ VDL - ie. one with a ‘System Clut’ ( standard 3DO IMAG
 *	file displays correctly with this clut), and one clut entry per
 *scanline.
 */
void
InitVDL (VDLEntry *vdlPtr, Bitmap *destBitmap)
{
  int32 scanLine, colorTableEntry;
  VDL_REC *vdlArrayPtr;
  VDL_REC *vdlRecPtr;
  uint32 prevFrameBuffer;
  uint32 *vdlClutEntry;

  vdlArrayPtr = (VDL_REC *)vdlPtr;
  for (scanLine = 0; scanLine < myScreenHeight; scanLine++)
    {
      // There are a minimum of 4 (maybe 6) entries in a 'color palette'. There
      //  are ALWAYS 4 control words:  The first word is always the
      //  control value to be deposited in the CLUT DMA controller, the second
      //  word is always the 'current' frame buffer address, the third word is
      //  always the 'previous' frame buffer address, and the fourth word is
      //  always the address of the next color palette to be used.  The maximum
      //  number of total words in a color palette is about 50, due to the
      //  amount of time available for the hardware to process it during horiz
      //  blank.  In addition a color palette is not allowed to fall across a 1
      //  megabyte physical VRAM page boundary.

      vdlRecPtr = (VDL_REC *)&vdlArrayPtr[scanLine];

      // first, the DMA control word...
      vdlRecPtr->controlword
          = SetDMACtlWord (kClutColorWords - kFillerWords, 1, false);

      // second, the 'current' scanline frame buffer address...
      vdlRecPtr->curLineBuffer = ((uint32)destBitmap->bm_Buffer)
                                 + (scanLine / 2) * 4 * myScreenWidth
                                 + ((scanLine & 1) * 2);

      // third, the 'previous' scanline frame buffer address...
      if (scanLine != 0)
        vdlRecPtr->prevLineBuffer = prevFrameBuffer;
      else
        vdlRecPtr->prevLineBuffer = vdlRecPtr->curLineBuffer;
      prevFrameBuffer = vdlRecPtr->curLineBuffer;

      // fourth, is the address (relative in this case) of the next color
      // palette to use
      vdlRecPtr->nextVDLEntry = kClutColorWords * (uint32)sizeof (uint32);

      // control words for this line...  set them to null
      vdlRecPtr->displayControl = VDL_NULLVDL;

      // and finally colors to use on this line.  also set them to null
      vdlClutEntry = &vdlRecPtr->CLUTEntry[0];
      for (colorTableEntry = 0; colorTableEntry < kCLUTWords;
           colorTableEntry++)
        vdlClutEntry[colorTableEntry] = VDL_NULLVDL;

      vdlRecPtr->backgroundEntry = VDL_NULLVDL;

      vdlRecPtr->filler1 = VDL_NULLVDL;
      vdlRecPtr->filler2 = VDL_NULLVDL;
    }

  vdlRecPtr = (VDL_REC *)&vdlArrayPtr[myScreenHeight - 1];
  vdlRecPtr->controlword
      = SetDMACtlWord (kClutColorWords - kFillerWords, 1, true);

  // and finally set the display control word for the screen
  vdlRecPtr = (VDL_REC *)&vdlArrayPtr[0];
  vdlRecPtr->displayControl = SetDisplayCtlWord (true, true, true);
}

/*
 * Fill in the context (screen) specific fields for a VDL generated by the
 *	PhotoShop export module
 */
void
CorrectVDL (VDLEntry *vdlPtr, Bitmap *destBitmap)
{
#define ODD(num) (num & 1)
  uint32 scanLineEntry;
  VDL_REC *vdlArrayPtr = (VDL_REC *)vdlPtr;
  VDL_REC *vdlRecPtr;
  uint32 prevBufPtr;
  uint32 curBufPtr;
  DMAControlWord *clutCtlWordPtr;

  // the 'next' and 'prev' fields both point to the first scan line for the
  //  first VDL entry
  curBufPtr = ((uint32)destBitmap->bm_Buffer);
  prevBufPtr = curBufPtr;

  for (scanLineEntry = 0; scanLineEntry < myScreenHeight; scanLineEntry++)
    {
      vdlRecPtr = (VDL_REC *)&vdlArrayPtr[scanLineEntry];

      // if this vdl was generated by the old vdl export tool, it inlcudes the
      //  2 filler words (used to push the total vdl length to 40 long words)
      //  in the vld length.  SubmitVDL will now fail if the total length of a
      //  vdl is greater than 38, so exclude the filler words from the length.
      clutCtlWordPtr = (DMAControlWord *)&vdlRecPtr->controlword;
      if ((*clutCtlWordPtr).numColorWords == kClutColorWords)
        (*clutCtlWordPtr).numColorWords = kClutColorWords - kFillerWords;

      vdlRecPtr->curLineBuffer = curBufPtr;
      vdlRecPtr->prevLineBuffer = prevBufPtr;

      // remember the current buffer addr for next time throught the loop
      prevBufPtr = curBufPtr;

      // when calculating the next frame buffer address, remember that the
      // image
      //  is in LR format (two scanlines mixed)
      if (ODD (scanLineEntry))
        curBufPtr = (curBufPtr - 2) + (myScreenWidth * 2 * sizeof (uint16));
      else
        curBufPtr += 2;

      // fourth, is the address (relative in this case) of the next color
      // palette to use
      vdlRecPtr->nextVDLEntry = kClutColorWords * (uint32)sizeof (uint32);
      ;
    }

  // The last entry of a VDL must point to the system vdl (address is in
  //  GrafBase->gf_VDLPostDisplay)
  vdlRecPtr = (VDL_REC *)&vdlArrayPtr[myScreenHeight - 1];
  vdlRecPtr->nextVDLEntry = (int32)GrafBase->gf_VDLPostDisplay;
  ;

#undef ODD
}

/*
 * Merge a raw VDL, ie one generated by the PhotoShop export module, into an
 *	‘active’ one, ie. one already run through InitVDL above.
 */
void
MergeVDL (VDLEntry *rawVDLPtr, VDLEntry *activeVDLPtr, uint32 vdllines)
{
  uint32 scanLineEntry;
  int32 ndx;
  VDL_REC *rawVDLRecPtr;
  VDL_REC *activeVDLRecPtr;
  VDL_REC *rawVDLArrayPtr = (VDL_REC *)rawVDLPtr;
  VDL_REC *activeVDLArrayPtr = (VDL_REC *)activeVDLPtr;
  uint32 *rawClutEntry, *activeClutEntry;
  DMAControlWord *clutCtlWordPtr;

  for (scanLineEntry = 0; scanLineEntry < vdllines; scanLineEntry++)
    {
      rawVDLRecPtr = (VDL_REC *)&rawVDLArrayPtr[scanLineEntry];
      activeVDLRecPtr = (VDL_REC *)&activeVDLArrayPtr[scanLineEntry];

      // merge the stuff set up by the export module
      //  - the DMA control word and the background color
      activeVDLRecPtr->controlword = rawVDLRecPtr->controlword;
      activeVDLRecPtr->backgroundEntry = rawVDLRecPtr->backgroundEntry;
      // if this is a single VDL color Table we need to enable it
      // for all 240 lines
      if (vdllines == 1)
        activeVDLRecPtr->controlword = SetDMACtlWord (
            kClutColorWords - kFillerWords, myScreenHeight, false);
      // if this vdl was generated by the old vdl export tool, it inlcudes the
      //  2 filler words (used to push the total vdl length to 40 long words)
      //  in the vld length.  SubmitVDL will now fail if the total length of a
      //  vdl is greater than 38, so exclude the filler words from the length.
      clutCtlWordPtr = (DMAControlWord *)&activeVDLRecPtr->controlword;
      if ((*clutCtlWordPtr).numColorWords == kClutColorWords)
        (*clutCtlWordPtr).numColorWords = kClutColorWords - kFillerWords;

      //  - the display control commands
      activeVDLRecPtr->displayControl = rawVDLRecPtr->displayControl;
      if (activeVDLRecPtr->displayControl == 0) //  This should not be!
        { // lets set some resonable defaults
          if (scanLineEntry == 0)
            {
              activeVDLRecPtr->displayControl
                  = SetDisplayCtlWord (true, true, true);
              printf (" Warning: Found and changed a NULL VDL "
                      "displayControlWord to %x\n",
                      activeVDLRecPtr->displayControl);
            }
          else
            activeVDLRecPtr->displayControl = VDL_NULLVDL;
        }
      if (scanLineEntry != 0)
        activeVDLRecPtr->displayControl = VDL_NULLVDL;
      // Temporary TEST DSM turn on Fixed CLUT
      if (scanLineEntry == 0)
        {
          activeVDLRecPtr->displayControl
              = SetDisplayCtlWord (true, true, true);
        }

      //  - and the actual color entries
      activeClutEntry = &activeVDLRecPtr->CLUTEntry[0];
      rawClutEntry = &rawVDLRecPtr->CLUTEntry[0];
      for (ndx = 0; ndx < kCLUTWords; ++ndx)
        activeClutEntry[ndx] = rawClutEntry[ndx];
    }
}

/*
 * Alloate memory for, initialize, and submit a new VDL to the system.
 */
int32
AllocateVDL (VDLEntry **newVDL, Bitmap *screenBitMap)
{
  // allocate some memory.  no need to use VRAM as the system makes its own
  // copy
  //  of the vdl when we submit
  *newVDL
      = (VDLEntry *)ALLOCMEM (kVDLSize, MEMTYPE_ANY | (MEMTYPE_FILL | 0x00));
  if (*newVDL == NULL)
    {
      kprintf (("Error - unable to allocate VDL memory\n"));
      return -1;
    }

  // init the memory we just allocated with the screen specific info it needs
  InitVDL (*newVDL, screenBitMap);

  return noErr;
}

//********************************************************************************
//**
//** 							EXPERIMENTAL ROUTINES
//**							  USE WITH CAUTION!!
//**

enum
{
  nullAMYVideoControl = 0,
  videoIsPAL,
  select640Mode,
  bypassCLUT,
  slipStreamOverlay,
  forceTransparency,
  backgroundDetector,

  swapWindowPenHV,
  windowVSource,
  windowHSource,
  windowBlueLSBSource,
  windowVerticalInterp,
  windowHorizontalInterp,
  windowMSBReplicate,

  bypassLSBIsRandom,

  swapPenVH,
  VSource,
  HSource,
  blueLSBSource,
  verticalInterpolation,
  horizontalInterpolation,

  colorsOnly,

  noVerticalInterpLine
};

static char *fieldNames[] = { "nullAMYVideoControl",
                              "videoIsPAL",
                              "select640Mode",
                              "bypassCLUT",
                              "slipStreamOverlay",
                              "forceTransparency",
                              "backgroundDetector",

                              "swapWindowPenHV",
                              "windowVSource",
                              "windowHSource",
                              "windowBlueLSBSource",
                              "windowVerticalInterp",
                              "windowHorizontalInterp",
                              "windowMSBReplicate",

                              "bypassLSBIsRandom",

                              "swapPenVH",
                              "VSource",
                              "HSource",
                              "blueLSBSource",
                              "verticalInterpolation",
                              "horizontalInterpolation",

                              "colorsOnly",

                              "noVerticalInterpLine" };

/*
 * limit a number to a range
 */
short
LimitNum (short num, short min, short max)
{
  if (num > max)
    num = min;
  else if (num < min)
    num = max;

  return num;
}

/*
 * Change the VDL display control word 'focus' bit field.
 */
void
ShowAnotherField (VDLDisplayCtlWord dmaWord, Boolean nextField)
{
  if (nextField)
    gCurrFieldNum++;
  else
    gCurrFieldNum--;

  gCurrFieldNum
      = LimitNum (gCurrFieldNum, nullAMYVideoControl, noVerticalInterpLine);
  kprintf ("%s is %d,\t[%X]\n", fieldNames[gCurrFieldNum],
           GetDisplayCtlValue (dmaWord, gCurrFieldNum), LONGWORD (dmaWord));
}

/*
 * Change the value of the VDL display control word 'focus' bit field.
 */
void
SetCtlField (VDLDisplayCtlWord *dmaWord, Boolean increase)
{
  short currValue = GetDisplayCtlValue (*dmaWord, gCurrFieldNum);

  if (increase)
    currValue++;
  else
    currValue--;

  *dmaWord = SetDisplayCtlValue (*dmaWord, currValue, gCurrFieldNum);
  kprintf ("%s set to %d,\t[%X]\n", fieldNames[gCurrFieldNum],
           GetDisplayCtlValue (*dmaWord, gCurrFieldNum), LONGWORD (*dmaWord));
}

/*
 * Read the value of the VDL display control word 'focus' bit field.
 */
short
GetDisplayCtlValue (VDLDisplayCtlWord dmaWord, short fieldNum)
{
  switch (fieldNum)
    {
    case nullAMYVideoControl: //
      return dmaWord.nullAMYVideoControl;
      break;

    case videoIsPAL: // [   27] PAL video
      return dmaWord.videoIsPAL;
      break;

    case select640Mode: // [   26] select 640 mode
      return dmaWord.select640Mode;
      break;

    case bypassCLUT: // [   25] bypass CLUT if pen MSB set
      return dmaWord.bypassCLUT;
      break;

    case slipStreamOverlay: // [   24] source of overlay is SlipStream
      return dmaWord.slipStreamOverlay;
      break;

    case forceTransparency: // [   23]
      return dmaWord.forceTransparency;
      break;

    case backgroundDetector: // [   22] enable background detector
      return dmaWord.backgroundDetector;
      break;

    case swapWindowPenHV: // [   21] swap H and V bits in pen numbers in window
      return dmaWord.swapWindowPenHV;
      break;

    case windowVSource: // [20-19] selects source for V sub-positions in window
                        // pixels
      return dmaWord.windowVSource;
      break;

    case windowHSource: // [18-17] selects source for H sub-position in window
                        // pixels
      return dmaWord.windowHSource;
      break;

    case windowBlueLSBSource: // [16-15] selects source for window blue pen
                              // number's LSB
      return dmaWord.windowBlueLSBSource;
      break;

    case windowVerticalInterp: // [   14] enable vertical interpolation in
                               // window
      return dmaWord.windowVerticalInterp;
      break;

    case windowHorizontalInterp: // [   13] enable horizontal interpolation in
                                 // window
      return dmaWord.windowHorizontalInterp;
      break;

    case windowMSBReplicate: // [   11]
      return dmaWord.windowMSBReplicate;
      break;

    case bypassLSBIsRandom: // [   12] enable random number for low-bits of
                            // CLUT bypass
      return dmaWord.bypassLSBIsRandom;
      break;

    case swapPenVH: // [   10] swap H and V bits in pen number
      return dmaWord.swapPenVH;
      break;

    case VSource: // [ 9- 8] selects source of vertical sub-position
      return dmaWord.VSource;
      break;

    case HSource: // [ 7- 6] selects source of horizontal sub-position
      return dmaWord.HSource;
      break;

    case blueLSBSource: // [ 5- 4] selects source of blue pen number's LSB
      return dmaWord.blueLSBSource;
      break;

    case verticalInterpolation: // [    3] enable vertical interpolation
      return dmaWord.verticalInterpolation;
      break;

    case horizontalInterpolation: // [    2] enable horizontal interpolation
      return dmaWord.horizontalInterpolation;
      break;

    case colorsOnly: // [    1] reserved; set to zero
      return dmaWord.colorsOnly;
      break;

    case noVerticalInterpLine: // [    0] suppress vertical interpolation for
                               // this line only
      return dmaWord.noVerticalInterpLine;
      break;
    }

  return 0;
}

/*
 * Cycle the value of the VDL display control word 'focus' bit field up or
 * down.
 */
VDLDisplayCtlWord
SetDisplayCtlValue (VDLDisplayCtlWord dmaWord, short newValue, short fieldNum)
{
  //	int32	tempLong = LONGWORD(dmaWord);

  switch (fieldNum)
    {
    case nullAMYVideoControl: //
      dmaWord.nullAMYVideoControl = LimitNum (newValue, 0, 1);
      break;

    case videoIsPAL: // [   27] PAL video
      dmaWord.videoIsPAL = LimitNum (newValue, 0, 1);
      break;

    case select640Mode: // [   26] select 640 mode
      dmaWord.select640Mode = LimitNum (newValue, 0, 1);
      break;

    case bypassCLUT: // [   25] bypass CLUT if pen MSB set
      dmaWord.bypassCLUT = LimitNum (newValue, 0, 1);
      break;

    case slipStreamOverlay: // [   24] source of overlay is SlipStream
      dmaWord.slipStreamOverlay = LimitNum (newValue, 0, 1);
      break;

    case forceTransparency: // [   23]
      dmaWord.forceTransparency = LimitNum (newValue, 0, 1);
      break;

    case backgroundDetector: // [   22] enable background detector
      dmaWord.backgroundDetector = LimitNum (newValue, 0, 1);
      break;

    case swapWindowPenHV: // [   21] swap H and V bits in pen numbers in window
      dmaWord.swapWindowPenHV = LimitNum (newValue, 0, 1);
      break;

    case windowVSource: // [20-19] selects source for V sub-positions in window
                        // pixels
      dmaWord.windowVSource = LimitNum (newValue, 0, 3);
      break;

    case windowHSource: // [18-17] selects source for H sub-position in window
                        // pixels
      dmaWord.windowHSource = LimitNum (newValue, 0, 3);
      break;

    case windowBlueLSBSource: // [16-15] selects source for window blue pen
                              // number's LSB
      dmaWord.windowBlueLSBSource = LimitNum (newValue, 0, 3);
      break;

    case windowVerticalInterp: // [   14] enable vertical interpolation in
                               // window
      dmaWord.windowVerticalInterp = LimitNum (newValue, 0, 1);
      break;

    case windowHorizontalInterp: // [   13] enable horizontal interpolation in
                                 // window
      dmaWord.windowHorizontalInterp = LimitNum (newValue, 0, 1);
      break;

    case windowMSBReplicate: // [   11]
      dmaWord.windowMSBReplicate = LimitNum (newValue, 0, 1);
      break;

    case bypassLSBIsRandom: // [   12] enable random number for low-bits of
                            // CLUT bypass
      dmaWord.bypassLSBIsRandom = LimitNum (newValue, 0, 1);
      break;

    case swapPenVH: // [   10] swap H and V bits in pen number
      dmaWord.swapPenVH = LimitNum (newValue, 0, 1);
      break;

    case VSource: // [ 9- 8] selects source of vertical sub-position
      dmaWord.VSource = LimitNum (newValue, 0, 3);
      break;

    case HSource: // [ 7- 6] selects source of horizontal sub-position
      dmaWord.HSource = LimitNum (newValue, 0, 3);
      break;

    case blueLSBSource: // [ 5- 4] selects source of blue pen number's LSB
      dmaWord.blueLSBSource = LimitNum (newValue, 0, 3);
      break;

    case verticalInterpolation: // [    3] enable vertical interpolation
      dmaWord.verticalInterpolation = LimitNum (newValue, 0, 1);
      break;

    case horizontalInterpolation: // [    2] enable horizontal interpolation
      dmaWord.horizontalInterpolation = LimitNum (newValue, 0, 1);
      break;

    case colorsOnly: // [    1] reserved; set to zero
      dmaWord.colorsOnly = LimitNum (newValue, 0, 1);
      break;

    case noVerticalInterpLine: // [    0] suppress vertical interpolation for
                               // this line only
      dmaWord.noVerticalInterpLine = LimitNum (newValue, 0, 1);
      break;
    }

  return dmaWord;
}
