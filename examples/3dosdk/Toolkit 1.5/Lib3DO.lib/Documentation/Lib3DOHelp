¾KY CopyrightNotice¾C  Copyright The 3DO Company 1993-1994, All rights reserved.411 - Lib3DOHelp - 3DOToolkit 1.3 Pre-releaseMon Oct 10 09:11:03 1994¾KY HelpLib3DOHelp¾KL AboutLib3DOHelpCopyrightNoticeAbortAsyncLoadFile AsyncLoadFile BlitFontChar CEL_DATAPTR CEL_NEXTPTR CEL_PLUTPTR CEL_PRE0WORD CEL_PRE1WORD CenterCelOnScreen CenterRectf16 CenterCRectInCRect CenterCRectInDisplay CenterCRectOverIPoint CenterFPointInDisplay CenterIPointInCRect CenterIPointInSRect CenterIPointInDisplay CenterRectAACelInCRect CenterRectAACelInSRect CenterRectAACelInDisplay CenterRectAACelOverFPoint CenterRectAACelOverIPoint CenterRectCelInCRect ChainCelsAtHead ChainCelsAtTail CloneCel CloneTextCel CenterRectCelInSRect CenterRectCelInDisplay CenterRectCelListInCRect CenterRectCelListInSRect CenterRectCelListInDisplay CenterRectCelListOverFPoint CenterRectCelListOverIPoint CenterRectCelOverFPoint CenterRectCelOverIPoint CenterSRectInSRect CenterSRectInDisplay CenterSRectOverIPoint CheckAsyncLoadFile CleanupMSEvents ClearBitmap CloseGraphics CreateBackdropCel CreateCel CreateLRFormCel CreateSubrectCel CreateTextCel CRectFromCelReturn  CRectFromIVal CRectFromSRect CRectIntersection CRectUnion CrossFadeCels CrossFadeCels8 DeleteCel DeleteCelList DeleteTextCel DetachTextCelCCB  DisableMSEvent DispatchMSEvents DrawAnimCel DrawImage DrawTextChar DrawTextString EnableMSEvent EraseTextInCel FadeFromBlack FadeInCel FadeOutCel FadeToBlack FindChunk FinishAsyncLoadFile FPointFromFVal FPointFromIPoint FPointFromIVal FrameBufferToCel Free FreeBuffer GetAnimCel GetCelBitsPerPixel GetCelBytesPerRow GetCelDataBufferSize GetFontCharInfo GetFontCharWidest GetFontCharWidth GetFontStringWidth GetHSecTime GetTextCelColor GetTextCelColors GetTextCelCoords GetTextCelFormatBuffer GetTextCelFormatFlags GetTextCelLeadingAdjust GetTextCelMargins GetTextCelPenNumber GetTextCelSize GetTextCelSpacingAdjust GetTextCelTabStops GetTextExtent GetTimerIOReq GetTSecTime GetTime GetVBLTime GetUSecTime HZ_TO_USEC ICornerFromSRect IPointFromFPoint IPointFromFVal IPointFromIVal IPointIsInCRect IPointIsInSRect IS_LASTCEL ISizeFromCRect InsetCRect InsetSRect LastCelInList LinkCel LoadAnim LoadCel  LoadFile LoadFileHere LoadFont LoadImage LoadSoundEffect MakeNewCel Malloc MapAACelToCQuad MapAACelToCRect MapAACelToFPoint MapAACelToIPoint MapAACelToSRect MapCelListToCQuad MapCelListToCRect MapCelListToFPoint MapCelListToIPoint MapCelListToSRect MapCelToCQuad MapCelToCRect MapCelToFPoint MapCelToIPoint MapCelToSRect MapP2Cel MoveCel MSEC_TO_USEC OffsetAACelByFDelta OffsetAACelByIDelta OffsetCel OffsetCRect OffsetCelByFDelta OffsetCelByIDelta OffsetCelListByFDelta OffsetCelListByIDelta OffsetSRect OpenAudio OpenGraphics OpenMacLink OpenSPORT ParseCel ParseFont PreMoveCel ReadControlPad ReadFile ReportMemoryUsage RenderCelFillRect RenderCelHLine RenderCelOutlineRect RenderCelPixel RenderCelVLine ReturnCelPixel SaveFile SEC_TO_USE SetCelScale SetChannel SetFadeInCel SetFadeOutCel SetMixer SetQuad SetRectf16 SetTextCelColor SetTextCelColors SetTextCelCoords SetTextCelFormatBuffer SetTextCelFormatFlags SetTextCelLeadingAdjust SetTextCelMargins SetTextCelPenNumber SetTextCelSize SetTextCelSpacingAdjust SetTextCelTabStops SetupMSEvents Sleep SleepHSec SleepMSec SleepTSec SleepUSec SRectFromCRect SRectFromCel SRectFromIVal SRectIntersection SRectUnion ShutDown taCreateTextCel taModifyTextCel TimerCancel TimerChangeUserdata TimerReset TimerRestart TimerServicesClose TimerServicesOpen TimerServicesShutdown TimerServicesStartup TimerServicesVerify TimerSuspend TimerMsgAfterDelay TimerMsgAfterDelayVBL TimerMsgAtTime TimerMsgAtTimeVBL TimerMsgHeartbeat TimerMsgHeartbeatVBL TimerSignalAfterDelay TimerSignalAfterDelayVBL TimerSignalAtTime TimerSignalAtTimeVBL TimerSignalHeartbeat TimerSignalHeartbeatVBL UnloadAnim UnloadCel UnloadFile UnloadFont UnloadImage UpdateTextInCel vGetTextExtent vUpdateTextInCel WaitAsyncLoadFile WriteMacFile XCORNERFROMSRECT XSIZEFROMCRECT YCORNERFROMSRECT YSIZEFROMCRECT FPoint IPoint CRect SRect CQuad BlockFile FontDescriptor LoadFileInfo TextCel ¾KY AboutLib3DOHelp¾C__________________________________________________________________Version 1.1 Preliminary  --  3DOToolkit 1.3 Pre-releaseContains online versions of current 3DO Lib3DOHelp manual pages__________________________________________________________________¾KY AbortAsyncLoadFile ¾T Function¾DErr AbortAsyncLoadFile(LoadFileInfo *lf)¾CThis function aborts an async load already in progress.  It works even ifthe load operation has already completed.  If you asked AsyncLoadFile() to allocate the buffer then this functionfrees the buffer.  If you specified an ioDonePort you will NOT receivenotification at that port after calling this function.Do not call FinishAsyncLoadFile() after calling this function; thisfunction performs the Finish actions interally.ARGUMENTSlf                           A pointer to the LoadFileInfo structure for                             the load operation.RETURN VALUEReturns ABORTED (a status constant from operror.h).IMPLEMENTATIONLib3DO function¾F     BlockFile.h     ¾RAsyncLoadFile()¾KY AsyncLoadFile ¾T Function¾DErr AsyncLoadFile(char *fname, LoadFileInfo *lf)¾CThis function starts an async load of the specified file, using theoptions in the LoadFileInfo structure.This function opens the file, gets status information (filesize, etc) thenstarts the I/O.  Upon successful return from this function you can referto the buffer, bufSize, and bf (BlockFileInfo) fields of the LoadFileInfostructure, even though the I/O is still in progress.  The contents of thebuffer, of course, are indeterminate until the I/O completes.You must eventually follow a call to this function with a call to either AbortAsyncLoadFile(), WaitAsyncLoadFile(), or FinishAsyncLoadFile(). The LoadFileInfo structure is defined in BlockFile.h.  It contains valuesthat control the load operation.   If the buffer pointer in the structureis NULL a buffer is allocated for you.  If non-NULL it is a pointer to abuffer you allocated for the file.   If the ioDonePort value in thestructure is non-zero the I/O is set up to notify you via message when theload completes.If you store a NULL buffer pointer into the LoadFileInfo structure andallow this function to allocate a buffer for you, use the UnloadFile()function to release the buffer when you no longer need its contents.ARGUMENTSfname                        The name of the file to load.lf                           A pointer to a LoadFileInfo structure which                              describes the buffer and file                             characteristics.RETURN VALUEReturns zero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     BlockFile.h     ¾RLoadFile(), LoadFileHere(), UnloadFile()¾KY BlitFontChar ¾T Function¾Dint32 BlitFontChar(FontDescriptor*fDesc, uint32theChar, void*blitInfo, void*dstBuf, int32dstX, int32dstY, int32dstBPR, int32dstColorIndex, int32dstBPP)¾CBlits character pixels from the font data area into a memory buffer,performing any font formatspecific data decompression as needed.BlitFontChar() supports the internals of the text library; it should neverbe necessary to call this function directly from an application program.If you are implementing your own replacement text library, use BlitFontChar() to render the font character pixels into your own memorybuffer. You can use the standard text library source code as a guide increating your own text library.BlitFontChar() currently supports only 8-bit-per-pixel destination format,and always creates pixels suitable for an 8-bit coded cel with AMV(alternate multiplier value) used to scale pixels already in the cell foranti-aliasing.  Support for other destination formats may be added in thefuture.ARGUMENTSfDesc                        Pointer to a FontDescriptor structure.theChar                      The specific character you want to blit to                             the buffer.blitInfo                     The value returned from GetFontCharInfo()via                             its **blitInfo  parameter, or NULL.  If you                             pass NULL, an internal call to                              GetFontCharInfo() is made.  If you are                             already calling GetFontCharInfo() before                             blitting each character, you can eliminate                              this potentially expensive internal call by                             saving the blitInfo from your call and                             passing it to this function.destBuf                      Pointer to the cel buffer into which you                             want to blit the character pixels. dstX                         x coordinate within the destBuf.dstY                         y coordinate within the destBuf.dstBPR                       The bytes-per-row of the destBuf.dstColorIndex                For 8-bit-per-pixel destination buffers, the                             color index to OR into each pixel as the                             character pixels are placed into the buffer.                             The value must be in the range of 0 through                             3 inclusive.dstBPP                       The bits-per-pixel of the destination                             buffer.RETURN VALUEThe width of the character, in pixels. Zero indicates no pixels wereplaced in the destination buffer because the character is not within therange of characters stored in the font.¾F     FontLib.h     ¾RGetFontCharInfo¾KY CEL_DATAPTR ¾T Function¾DCelData * CEL_DATAPTR(ccb)¾CThis macro evaluates to a pointer to the cel's data buffer.  It takes theCCB_SPABS flag into account and always an absolute pointer, even when theCCB contains a relative offset in the ccb_SourcePtr field.  This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in an expression context.ARGUMENTSccb                          A pointer to a cel.RETURN VALUEA pointer to the cel's data buffer, a CelData* type.IMPLEMENTATIONMacro¾F     CelUtils.h     ¾KY CEL_NEXTPTR ¾T Function¾DCCB * CEL_NEXTPTR(ccb)¾CThis macro evaluates to a pointer to the next cel.  It takes the CCB_NPABSflag into account and always an absolute pointer, even when the CCBcontains a relative offset in the ccb_NextPtr field.  It evaluates to NULLif the CCB_LAST flag is set, or if the ccb_NextPtr field is NULL or zero. This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in expression context.ARGUMENTSccb                          A pointer to a cel.RETURN VALUEA pointer to the next cel, a CCB* type.  NULL if there is no next cel.IMPLEMENTATIONMacro¾F     CelUtils.h     ¾KY CEL_PLUTPTR ¾T Function¾Duint16 * CEL_PLUTPTR(ccb)¾CThis macro evaluates to a pointer to the cel's PLUT.  It takes theCCB_PPABS flag into account and always an absolute pointer, even when theCCB contains a relative offset in the ccb_PLUTPtr field.This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in expression context.ARGUMENTSccb                          A pointer to a cel.RETURN VALUEA pointer the cel's PLUT, a uint16* typeIMPLEMENTATIONMacro¾F     CelUtils.h     ¾KY CEL_PRE0WORD ¾T Function¾Duint32 CEL_PRE0WORD(ccb)¾CThis macro evaluates to the Preamble Word 0 value for the cel.  It takesthe CCB_CCBPRE flag into account and retrieves the preamble word from theCCB or the cel data buffer as appropriate.   This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in expression context.ARGUMENTSccb                          A pointer to a cel.RETURN VALUEThe cel's preamble word 0 value, a uint32 typeIMPLEMENTATIONMacro¾F     CelUtils.h     ¾KY CEL_PRE1WORD ¾T Function¾Duint32 CEL_PRE1WORD(ccb)¾CThis macro evaluates to the Preamble Word 1 value for the cel.  It takesthe CCB_CCBPRE flag into account and retrieves the preamble word from theCCB or the cel data buffer as appropriate.   This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in expression context.ARGUMENTSccb                          A pointer to a cel.RETURN VALUEThe cel's preamble word 1 value, a uint32 typeIMPLEMENTATIONMacro¾F     CelUtils.h     ¾KY CenterCelOnScreen ¾T Function¾D void CenterCelOnScreen (CCB *ccb)¾CCenters the cel named by ccb.This function calls MapCel() to set therelevant ccb fields.A much faster function, CenterRectCelInDisplay(), avoids the slow MapCel() call and preserves scaling values currently set in the cel if the projection is not 1:1. ARGUMENTSccb                          Pointer to the CCB you want to center.RETURN VALUEvoid¾F     Utils3DO.h  See Also          SetQuad(), SetRectf16(), CenterRectf16(), CenterRectCelInDiplay()     ¾KY CenterRectf16 ¾T Function¾D void CenterRectf16 (Point *q, Rectf16 *rect, Rectf16 *frame)¾CSets the coordinates of the four points q[0] through q[3]. Determinesthese coordinates by centering the Rectf16 rectangle within the Rectf16frame. The Rectf16 structure has the following definition:typedef structtag_Rectf16{frac16 rectf16_XLeft;frac16 rectf16_YTop;frac16rectf16_XRight;frac16 rectf16_YBottom;} Rectf16;ARGUMENTSq                            Pointer to an array of 4 points.rect                         Pointer to a Rectf16 structure.frame                        Pointer to a Rectf16 structure. RETURN VALUEvoid¾F     Utils3DO.h     ¾RSetQuad, SetRectf16, CenterCelOnScreen, CenterCRectInCRect, CenterCRectInDisplay, CenterCRectOverIPoint, CenterSRectInSRect, CenterSRectInDisplay, CenterSRectOverIPoint¾KY CenterCRectInCRect ¾T Function¾DCRect * CenterCRectInCRect(CRect *dst, CRect *src)¾CThis function centers the dst rectangle over or within the src rectangle. If the dst rectangle is smaller than the src rectangle, its values aremodified to center it within the src rectangle.  If the dst rectangle islarger than the src rectangle, its values are modified to center it overthe src rectangle.  In either case, the resulting rectangle retains itsoriginal sizes; only the position changes.ARGUMENTSdst                          A pointer to the CRect to be centered.src                          A pointer to the CRect within which dst is                             to be centered.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterSRectInSRect()¾KY CenterCRectInDisplay ¾T Function¾DCRect * CenterCRectInDisplay(CRect *dst)¾CThis function centers the dst rectangle over or within the display.  ARGUMENTSdst                          A pointer to a CRect where the results are                             to be stored.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterSRectInDisplay()¾KY CenterCRectOverIPoint ¾T Function¾DCRect * CenterCRectOverIPoint(CRect *dst, IPoint *point)¾CThis function centers the dst rectangle over the specified point.ARGUMENTSdst                          A pointer to a CRect where the results are                             to be stored.point                        A pointer to an IPoint over which the dst is                             to be centered.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterSRectOverIPoint()¾KY CenterFPointInDisplay ¾T Function¾DFPoint* CenterFPointInDisplay(void)¾CThis function returns the center point of the display.  The return value points to a static structure which must not be modified.ARGUMENTSNone.  Return ValueReturns a pointer to an FPoint describing the center point of the display.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterIPointInDisplay()¾KY CenterIPointInCRect ¾T Function¾DIPoint* CenterIPointInCRect(IPoint *dst, CRect *rect)¾CThis function calculates the center point of the specified rectangle andstores the result at *dst.ARGUMENTSdst                          A pointer to an IPoint where the results are                             to be stored.rect                         A pointer to the CRect for which the center                             point is to be calculated.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterIPointInSRect()¾KY CenterIPointInSRect ¾T Function¾DIPoint* CenterIPointInSRect(IPoint *dst, SRect *rect)¾CThis function calculates the center point of the specified rectangle andstores the result at *dst.ARGUMENTSdst                          A pointer to an IPoint where the results are                             to be stored.rect                         A pointer to the SRect for which the center                             point is to be calculated.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterIPointInCRect()¾KY CenterIPointInDisplay ¾T Function¾DIPoint* CenterIPointInDisplay(void)¾CThis function returns the center point of the display.  The return value points to a static structure which must not be modified.ARGUMENTSNone.  Return ValueReturns a pointer to an FPoint describing the center point of the display.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterFPointInDisplay()¾KY CenterRectAACelInCRect ¾T Function¾Dvoid CenterRectAACelInCRect(CCB *cel, CRect *rect)¾CThis function centers an anti-aliased cel over or within the specifiedrectangle.  The ccb_XPos and ccb_YPos fields are modified in both the data and alpha-channel CCBs; other CCB fields are not modified.  The centering is basedon the cel's projected size, not its source data size.  If the cel isprojected to a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to the cel to be centered.rect                         A pointer to a CRect describing the area                             within which the cel is to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectAACelInSRect(), CenterRectCelInCRect(), CenterRectCelListInCRect()¾KY CenterRectAACelInSRect ¾T Function¾Dvoid CenterRectAACelInSRect(CCB *cel, SRect *rect)¾CThis function centers an anti-aliased cel over or within the specifiedrectangle.  The ccb_XPos and ccb_YPos fields are modified in both the data and alpha-channel CCBs; other CCB fields are not modified.  The centering is basedon the cel's projected size, not its source data size.  If the cel isprojected to a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to the cel to be centered.rect                         A pointer to an SRect describing the area                             within which the cel is to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectAACelInCRect(), CenterRectCelInSRect(), CenterRectCelListInSRect()¾KY CenterRectAACelInDisplay ¾T Function¾Dvoid CenterRectAACelInDisplay(CCB *cel)¾CThis function centers an anti-aliased cel over or within the the display. The ccb_XPos and ccb_YPos fields are modified in both the data and alpha-channel CCBs; other CCB fields are not modified.  The centering is basedon the cel's projected size, not its source data size.  If the cel isprojected to a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to the cel to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectCelInDisplay(), CenterRectCelListInDisplay()¾KY CenterRectAACelOverFPoint ¾T Function¾Dvoid CenterRectAACelOverFPoint(CCB *cel, FPoint *point)¾CThis function centers an anti-aliased cel over the specified point.  The ccb_XPos and ccb_YPos fields are modified in both the data and alpha-channel CCBs; other CCB fields are not modified.  The centering is basedon the cel's projected size, not its source data size.  If the cel isprojected to a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to the cel to be centered.point                        A pointer to an FPoint over which the cel is                             to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectAACelOverIPoint(), CenterRectCelOverFPoint(), CenterCelListOverFPoint()¾KY CenterRectAACelOverIPoint ¾T Function¾Dvoid CenterRectAACelOverIPoint(CCB *cel, IPoint *point)¾CThis function centers an anti-aliased cel over the specified point.  The ccb_XPos and ccb_YPos fields are modified in both the data and alpha-channel CCBs; other CCB fields are not modified.  The centering is basedon the cel's projected size, not its source data size.  If the cel isprojected to a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to the cel to be centered.point                        A pointer to an IPoint over which the cel is                             to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectAACelOverFPoint(), CenterRectCelOverIPoint(), CenterCelListOverIPoint()¾KY CenterRectCelInCRect ¾T Function¾Dvoid CenterRectCelInCRect(CCB *cel, CRect *rect)¾CThis function centers a single cel over or within the specified rectangle.The ccb_XPos and ccb_YPos fields are modified in the CCB; other CCB fieldsare not modified.  The centering is based on the cel's projected size, notits source data size.  If the cel is projected to a non-rectangular shape,the result will be invalid.ARGUMENTScel                          A pointer to the cel to be centered.rect                         A pointer to a CRect within which the cel is                             to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectCelInSRect(), CenterRectAACelInCRect(), CenterRectCelListInCRect()¾KY ChainCelsAtHead ¾T Function¾DCCB * ChainCelsAtHead(CCB *existingCels, CCB *newCels)¾CThis function chains together two lists of cels, puting the new list aheadof the existing cels.  The return value is a pointer to the first cel inthe resulting list.  Either pointer can be NULL, eliminating the need forspecial-case code when iteratively building a list of cels.  For example,the following code will work:CCB *    list = NULL;CCB *    cels;do {   cels = get_next_antialiased_cel();    list = ChainCelsAtHead(list, cels);}while (cels != NULL);This function works properly with anti-aliased cels and similar constructswhere a list of related cels makes up a single logical entity.ARGUMENTSexistingCels                 A pointer to the existing list of cels; may                             be NULL.newCels                      A pointer to the new list of cels to be                             added ahead of the existing list; may be                             NULL.RETURN VALUEA pointer to the head of the resulting list of cels.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RChainCelsAtTail()¾KY ChainCelsAtTail ¾T Function¾DCCB * ChainCelsAtTail(CCB *existingCels, CCB *newCels)¾CThis function chains together two lists of cels, puting the new listbehind the existing cels.  The return value is a pointer to the last celin the resulting list.  Either pointer can be NULL, in which case thefunction is essentially a no-op that just returns a pointer to the lastcel in the list pointed to by the other pointer.The most effecient way to iteratively build a list of cels is to use thereturn value from the prior call as the existingCels pointer for thecurrent call.  This eliminates long searches for the end of theever-growing list of cels.  For example:CCB *    list = NULL;CCB *    tail= NULL;CCB *    cels;do {   cels = get_next_antialiased_cel();   tail =ChainCelsAtTail(tail, cels);   if (list == NULL) {       list = cels;  //remember head-of-list pointer first time through.   }} while (cels !=NULL);This function works properly with anti-aliased cels and similar constructswhere a list of related cels makes up a single logical entity.ARGUMENTSexistingCels                 A pointer to the existing list of cels; may                             be NULL.newCels                      A pointer to the new list of cels to be                             added at the end of the existing list; may                             be NULL.RETURN VALUEA pointer to the last cel in the resulting list of cels.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RChainCelsAtHead()¾KY CloneCel ¾T Function¾DCCB * CloneCel(CCB *src, int32 options)¾CThis function makes a copy of a CCB, and optionally of the pixels and/orPLUT.  The values in the cloned CCB are identical to the src CCB, exceptthat the CCB_LAST flag will be set and the ccb_NextPtr field will be NULLin the clone.The options parameter is one or more of the following values, ORedtogether as necessary:CLONECEL_CCB_ONLYCLONECEL_COPY_PIXELSCLONECEL_COPY_PLUTWhen COPY_PIXELS is specified, a new cel data buffer is allocated, and thepixels in the src cel's buffer are copied to the new buffer.  WhenCOPY_PIXELS is not specified, the new cel's ccb_SourcePtr field points tothe src cel's data buffer.When COPY_PLUT is specified, a new PLUT is allocated, and the values fromthe src cel's PLUT are copied to the new PLUT.  When COPY_PLUT is notspecified, the new cel's ccb_PLUTPtr field points to the src cel's PLUT. If the cel is uncoded, the COPY_PLUT option has no effect.You may change any of the values in the CCB fields of the newly createdcel.  Be careful about changing preamble words when the CCB_CCBPRE flag isnot set and the CLONECEL_COPY_PIXELS option was not used.  In thatsituation, the preamble words you change would be those belonging to theoriginal cel, not the copy.Use DeleteCel() to release all resources allocated for the clone.ARGUMENTSsrc                          A pointer to a cel to copy.options                      Bitmapped options, as described above.RETURN VALUEA pointer to the new CCB, or NULL if there is not enough memory to makethe clone.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCreateCel(), DeleteCel()¾KY CloneTextCel ¾T Function¾DTextCel * CloneTextCel(TextCel*templateTextCel, BooleanclonePixels)¾CCreates a new TextCel using a TextCel that already exists as a template.If clonePixels is FALSE, the new TextCel contains no text; if TRUE, thepixels from the template TextCel are copied into the new TextCel.If the template cel has a format buffer attached to it, and that bufferwas dynamically allocated by the call to SetTextCelFormatBuffer(), a new buffer of the same size is allocated and attached to the new cel. If thetemplate cel has a format buffer that you provided explicitly (a staticbuffer), the new cel will use the same static buffer.This function is useful when you want to create a number of identical TextCels.You can call CreateTextCel(), followed by whatever SetTextCel...()functions you need to create a template cel with a givensize and attributes, then call CloneTextCel() as often as necessary tocreate a number of cels with identical size and attributes.Use DeleteTextCel() to dispose of the TextCel when you are finished withit.ARGUMENTStemplateTextCel              Pointer to the TextCel structure you want to                             clone.clonePixels                  TRUE if the new TextCel is to contain the                             same pixels as those currently in the                             template TextCel.RETURN VALUEA pointer to the newly created TextCel structure; NULL if there isn\xd5 tenough memory to create the new TextCel.¾F     TextLib.h     ¾RCreateTextCel(), DeleteTextCel¾KY CenterRectCelInSRect ¾T Function¾Dvoid CenterRectCelInSRect(CCB *cel, SRect *rect)¾CThis function centers a single cel over or within the specified rectangle.The ccb_XPos and ccb_YPos fields are modified in the CCB; other CCB fieldsare not modified.  The centering is based on the cel's projected size, notits source data size.  If the cel is projected to a non-rectangular shape,the result will be invalid.ARGUMENTScel                          A pointer to the cel to be centered.rect                         A pointer to an SRect within which the cel                             is to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectCelInCRect(), CenterRectAACelInSRect(), CenterRectCelListInSRect()¾KY CenterRectCelInDisplay ¾T Function¾Dvoid CenterRectCelInDisplay(CCB *cel)¾CThis function centers a single cel over or within the the display.  The ccb_XPos and ccb_YPos fields are modified in the CCB; other CCB fieldsare not modified.  The centering is based on the cel's projected size, notits source data size.  If the cel is projected to a non-rectangular shape,the result will be invalid.ARGUMENTScel                          A pointer to the cel to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectAACelInDisplay(), CenterRectCelListInDisplay()¾KY CenterRectCelListInCRect ¾T Function¾Dvoid CenterRectCelListInCRect(CCB *cel, CRect *rect)¾CThis function centers a list of one or more cels over or within thespecified rectangle.  The list of cels is treated as if it were a singlelogical entity.  The first cel in the list is centered, then the X/Ycoordinates of all remaining cels in the list are modified so that allcels maintain the same positional relationship to each other as they hadoriginally.  This is especially useful when the first cel in the list encompases the area occupied by all the other cels; the effect is tocenter the group of cels as if they were all one cel.The ccb_XPos and ccb_YPos fields are modified in the CCBs; other CCBfields are not modified.  The centering is based on the first cel'sprojected size, not its source data size.  If the first cel is projectedto a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to a list of one or more cels to                             be centered.rect                         A pointer to an SRect within which the cels                             are to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectCelListInSRect(), CenterRectAACelInCRect(), CenterRectCelInCRect()¾KY CenterRectCelListInSRect ¾T Function¾Dvoid CenterRectCelListInSRect(CCB *cel, SRect *rect)¾CThis function centers a list of one or more cels over or within thespecified rectangle.  The list of cels is treated as if it were a singlelogical entity.  The first cel in the list is centered, then the X/Ycoordinates of all remaining cels in the list are modified so that allcels maintain the same positional relationship to each other as they hadoriginally.  This is especially useful when the first cel in the list encompases the area occupied by all the other cels; the effect is tocenter the group of cels as if they were all one cel.The ccb_XPos and ccb_YPos fields are modified in the CCBs; other CCBfields are not modified.  The centering is based on the first cel'sprojected size, not its source data size.  If the first cel is projectedto a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to a list of one or more cels to                             be centered.rect                         A pointer to an SRect within which the cels                             are to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectCelListInCRect(), CenterRectAACelInSRect(), CenterRectCelInSRect()¾KY CenterRectCelListInDisplay ¾T Function¾Dvoid CenterRectCelListInDisplay(CCB *cel)¾CThis function centers a list of one or more cels over or within thedisplay.  The list of cels is treated as if it were a single logicalentity.  The first cel in the list is centered, then the X/Y coordinatesof all remaining cels in the list are modified so that all cels maintainthe same positional relationship to each other as they had originally. This is especially useful when the first cel in the list encompases the area occupied by all the other cels; the effect is to center the group ofcels as if they were all one cel.The ccb_XPos and ccb_YPos fields are modified in the CCBs; other CCBfields are not modified.  The centering is based on the first cel'sprojected size, not its source data size.  If the first cel is projectedto a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to a list of one or more cels to                             be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectAACelInDisplay(), CenterRectCelInDisplay()¾KY CenterRectCelListOverFPoint ¾T Function¾Dvoid CenterRectCelListOverFPoint(CCB *cel, FPoint *point)¾CThis function centers a list of one or more cels over the specified point.The list of cels is treated as if it were a single logical entity.  Thefirst cel in the list is centered, then the X/Y coordinates of allremaining cels in the list are modified so that all cels maintain the samepositional relationship to each other as they had originally.  This isespecially useful when the first cel in the list encompases the areaoccupied by all the other cels; the effect is to center the group of celsas if they were all one cel.The ccb_XPos and ccb_YPos fields are modified in the CCBs; other CCBfields are not modified.  The centering is based on the first cel'sprojected size, not its source data size.  If the first cel is projectedto a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to a list of one or more cels to                             be centered.point                        A pointer to an FPoint over which the cels                             are to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectCelListOverIPoint(), CenterRectAACelOverFPoint(), CenterRectCelOverFPoint()¾KY CenterRectCelListOverIPoint ¾T Function¾Dvoid CenterRectCelListOverIPoint(CCB *cel, IPoint *point)¾CThis function centers a list of one or more cels over the specified point.The list of cels is treated as if it were a single logical entity.  Thefirst cel in the list is centered, then the X/Y coordinates of allremaining cels in the list are modified so that all cels maintain the samepositional relationship to each other as they had originally.  This isespecially useful when the first cel in the list encompases the areaoccupied by all the other cels; the effect is to center the group of celsas if they were all one cel.The ccb_XPos and ccb_YPos fields are modified in the CCBs; other CCBfields are not modified.  The centering is based on the first cel'sprojected size, not its source data size.  If the first cel is projectedto a non-rectangular shape, the result will be invalid.ARGUMENTScel                          A pointer to a list of one or more cels to                             be centered.point                        A pointer to an IPoint over which the cels                             are to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRectCelListOverFPoint(), CenterRectAACelOverIPoint(), CenterRectCelOverIPoint()¾KY CenterRectCelOverFPoint ¾T Function¾Dvoid    CenterRectCelOverFPoint(CCB *cel, FPoint *point)¾CThis function centers a single cel over the specified point.  The ccb_XPos and ccb_YPos fields are modified in the CCB; other CCB fieldsare not modified.  The centering is based on the cel's projected size, notits source data size.  If the cel is projected to a non-rectangular shape,the result will be invalid.ARGUMENTScel                          A pointer to a cel to be centered.point                        A pointer to an FPoint over which the cels                             are to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRecCelOverIPoint(), CenterRectAACelOverFPoint(), CenterRectCelListOverFPoint()¾KY CenterRectCelOverIPoint ¾T Function¾Dvoid    CenterRectCelOverIPoint(CCB *cel, IPoint *point)¾CThis function centers a single cel over the specified point.  The ccb_XPos and ccb_YPos fields are modified in the CCB; other CCB fieldsare not modified.  The centering is based on the cel's projected size, notits source data size.  If the cel is projected to a non-rectangular shape,the result will be invalid.ARGUMENTScel                          A pointer to a cel to be centered.point                        A pointer to an IPoint over which the cels                             are to be centered.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterRecCelOverFPoint(), CenterRectAACelOverIPoint(), CenterRectCelListOverIPoint()¾KY CenterSRectInSRect ¾T Function¾DSRect * CenterSRectInSRect(SRect *dst, SRect *rect)¾CThis function centers the dst rectangle over or within the src rectangle. If the dst rectangle is smaller than the src rectangle, its positionvalues are modified to center it within the src rectangle.  If the dstrectangle is larger than the src rectangle, its position values aremodified to center it over the src rectangle.  In either case, theresulting rectangle retains its original sizes; only the position changes.ARGUMENTSdst                          A pointer to the SRect to be centered.src                          A pointer to the SRect within which dst is                             to be centered.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterCRectInCRect()¾KY CenterSRectInDisplay ¾T Function¾DSRect * CenterSRectInDisplay(SRect *dst)¾CThis function centers the dst rectangle over or within the display.  ARGUMENTSdst                          A pointer to the SRect to be centered.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterCRectInDisplay()¾KY CenterSRectOverIPoint ¾T Function¾DSRect * CenterSRectOverIPoint(SRect *dst, IPoint *point)¾CThis function centers the dst rectangle over the specified point.ARGUMENTSdst                          A pointer to the SRect to be centered.point                        A pointer to an IPoint over which dst is to                             be centered.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCenterCRectOverIPoint()¾KY CheckAsyncLoadFile ¾T Function¾DErr CheckAsyncLoadFile(LoadFileInfo *lf)¾CThis function checks the status of an AsyncLoadFile() started earlier.  Azero return value means I/O is still in progress.  A negative return valueindicates error, and a positive return value indicates successfulcompletion.  You must call FinishAsyncLoadFile() after receiving a non-zero status fromthis function.ARGUMENTSlf                           A pointer to the LoadFileInfo structure for                             the load operation.RETURN VALUEReturns zero if I/O is still in progress, negative if the I/O failed, orpositive if the has I/O compeleted successfully.IMPLEMENTATIONLib3DO function¾F     BlockFile.h     ¾RAsyncLoadFile()¾KY CleanupMSEvents ¾T Function¾Dvoid CleanupMSEvents(MSEventHandle mseHandle)¾CThis function releases all resources acquired internally bySetupMSEvents().  Any ports or signals which were allocated bySeuptMSEvents() are deleted.  If mseHandle is less than or equal to zero 0this function quietly returns without doing anything.  ARGUMENTSmseHandle                    An MSEventHandle returned by                              SetupMSEvents().RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     MsgUtils.h     ¾RSetupMSEvents(), DispatchMSEvents()¾KY ClearBitmap ¾T Function¾DErr ClearBitmap(Item ioreq, Item scr_bm, Bitmap *bmPtr, int32 rgbValue)¾CThis function sets all pixels in the screen or bitmap to the specifiedrgbValue.  It uses SetVRAMPages() for fast operation.The rgbValue is a pair of RGB555s packed into a 32-bit word.  If you don'twant simple black (zero), use the MakeRGB15Pair() macro to create thisvalue from separate red, green, and blue values.For best performance, pass a non-zero ioreq parm and a bitmap pointerinstead of a screen or bitmap item.  This will avoid LookupItem() andCreateIOReq() calls that would otherwise be made internally.ARGUMENTSioreq                        An IOReq item obtained from GetVRAMIOReq(),                             or zero to have an IOReq created and deleted                             internally during the call.scr_bm                       A Screen or Bitmap item number.  May be zero                             if a Bitmap pointer is provided.bmPtr                        A Bitmap pointer.  May be NULL if a Screen                             or Bitmap item is provided.rgbValue                     The color value to store into all screen or                             bitmap pixels.RETURN VALUEReturns zero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     DisplayUtils.h     ¾KY CloseGraphics ¾T Function¾Dvoid CloseGraphics(ScreenContext *sc)¾CThis function releases all resources acquired internally byOpenGraphics().  If OpenGraphics() failed it is still safe to call thisfunction; it will undo any partial setup that OpenGraphics() may haveaccomplished.    ARGUMENTSsc                           A pointer to the ScreenContext structure                             which OpenGraphics() filled in when the                             screens were opened.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     DisplayUtils.h     ¾ROpenGraphics()¾KY CreateBackdropCel ¾T Function¾DCCB * CreateBackdropCel(int32 width, int32 height, int32 color, int32 opacityPercent)¾CThis function creates a single-colored cel which is useful in serving as abackdrop and/or control point for other objects.  The color is an RGB555-format value.  Use the MakeRGB15() macro to createthis value from separate red, green, and blue values.The cel can be opaque or translucent as specified by opacityPercent.  100percent is opaque, smaller values give translucent cels where the cel'scolor intensity is the specified percentage of the projected result.  Forexample, 75% means the projected pixels are 75% of the cel's color, 25% ofthe existing pixel's color.  There are actually only 8 levels oftranslucency available; the percentage you request is mapped to theclosest available level.  The opacity and color of the cel cannot be changed after the cel is created.  (More specifically, you're on your ownin attempting the PIXC and source pixel manipulations needed to changecolor and opacity; it won't harm anything to try.)An opacityPercent of zero results in a 'virtual' cel, which does notproject any pixels when drawn.  The CCB_SKIP flag is set whenopacityPercent is zero.  A cel of this sort is useful in anchoring a listof related cels.  It can serve as a single point of control for moving,centering, mapping, and other projection-related manipulations when usedwith the Lib3DO functions that manipulate lists of cels as if they were asingle entity.Regardless of the sizes you specify, the cel requires only sizeof(CCB)bytes of memory.  The cel is created with a source size of 1x1 pixel, andthe HDX and VDY fields are set to project the pixel to the specified widthand height.  Note that the ccb_Width and ccb_Height fields reflect thecel's source data size of 1x1 pixel.  Lib3DO functions that are sensitiveto cel size, such as centering functions, use SRectFromCel() to get theprojected cel size and thus work correctly.  You should do the same if youneed to obtain the projected cel size programmatically.You may remap the cel to project to any position, size, and shape youdesire after it is created.  Use DeleteCel() to release all resources allocated for the cel.ARGUMENTSwidth                        The width of the cel as it is to appear when                             projected.height                       The height of the cel as it is to appear                             when projected.color                        The color of the cel, in RGB555 format.opacityPercent               The opacity percentage, from 0 (invisible)                             to 100 (opaque).RETURN VALUEA pointer to the new CCB, or NULL if there is not enough memory to makethe cel.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCreateCel(), DeleteCel()¾KY CreateCel ¾T Function¾DCCB * CreateCel(int32 width, int32 height, int32 bitsPerPixel, int32 options, void *dataBuf)¾CThis function creates a cel of any arbitrary type.  The parameters providejust enough information to create the basic cel.  After the cel iscreated, you are free to modify the CCB in any way you'd like to achieveeffects not directly implied by the creation parameters.If you pass a NULL dataBuf pointer an appropriately-sized buffer isallocated when the cel is created.  If you pass a non-NULL dataBuf pointerit is stored into the ccb_SourcePtr field instead of allocating a bufferinternally. The options parameter is one or more of the following values, ORedtogether as necessary:CREATECEL_UNCODED- Create a coded cel.    bitsPerPixel must be <= 8.CREATECEL_CODED- Create an uncoded cel. bitsPerPixel must be 8 or 16.If the bitsPerPixel value is less than 8, a PLUT is always allocated whenthe cel is created.  When bitsPerPixel is 8 or 16, a PLUT is allocatedonly if the CREATECEL_CODED option is set.  When a PLUT is allocated allits entries are initialized to zero.  The cel is created with a position of 0,0 and size and perspective valuesfor a 1:1 mapping.  The Preamble Word 1 Blue LSB handling is set toPRE1_TLLSB_PDC0.  The PIXC word is set for standard opaque, 0x1F001F00. The cel flags are set to:CCB_LAST | CCB_NPABS| CCB_SPABS | CCB_PPABS |CCB_LDSIZE | CCB_LDPRS| CCB_LDPPMP|CCB_CCBPRE | CCB_YOXY | CCB_USEAV  |CCB_NOBLK |CCB_ACE| CCB_ACW | CCB_ACCWUse DeleteCel() to release all resources allocated for the cel.  The celdata buffer and PLUT are released only if they were allocated byCreateCel().  If you provided your own dataBuf pointer, you must free thebuffer yourself.ARGUMENTSwidth                        The width of the cel, and its data buffer,                             in pixels.height                       The height of the cel, and its data buffer,                             in pixels.bitsPerPixel                 The bits per pixel value for the cel.options                      Bitmapped options, as described above.dataBuf                      Option data buffer pointer; may be NULL to                              have a buffer allocated automatically.RETURN VALUEA pointer to the new CCB, or NULL if there is not enough memory to makethe cel.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCreateBackdropCel(), DeleteCel()¾KY CreateLRFormCel ¾T Function¾DCCB * CreateLRFormCel(CCB *cel, Item screenItem, SRect *subRect)¾CThis function creates an LRForm cel from a screen or portion of a screen. LRForm cels can be used to 'capture' a screen's pixels and project them toanother screen (or another portion of the same screen).If the cel pointer is NULL, a new cel is allocated for you.  If non-NULLit must be an LRForm cel created by an earlier call to this function. Passing a non-NULL cel pointer allows you to repeatedly extract differentsubrects from the same screen without having to create a new cel eachtime.If the subRect pointer is NULL, the cel will be the same size as thesource screen.  If it is non-NULL, the cel will access the sub-rectangleof pixels described by subRect.Unlike other Lib3DO functions, you cannot pass a Bitmap item in place ofthe Screen item.  This is because the GetPixelAddress() function used tolocate the pixels in the screen will not accept a Bitmap item.The cel created by this function will use the pixels in the screen'sbitmap buffer as the cel source pixels.  The pixels are not copied, and ifyou render new pixels into the screen, subsequent projections of the celwill use the new pixels.The cel is created with a position of 0,0 and size and perspective valuesfor a 1:1 mapping.  The Preamble Word 1 Blue LSB handling is set toPRE1_TLLSB_PDC0.  The PIXC word is set for standard opaque, 0x1F001F00. The cel flags are set to:CCB_LAST | CCB_NPABS| CCB_SPABS | CCB_PPABS |CCB_LDSIZE | CCB_LDPRS| CCB_LDPPMP|CCB_CCBPRE | CCB_YOXY | CCB_USEAV  |CCB_NOBLK |CCB_ACE| CCB_ACW | CCB_ACCW|CCB_BGND| PMODE_ONEUse DeleteCel() to release the resources allocated for the cel.ARGUMENTScel                          A pointer to a cel created earlier by this                             function, or NULL to create a new cel.screenItem                   The item number of the Screen whose pixels                             this cel is to project.subRect                      A pointer to an SRect describing the sub-                             rectangle to be extracted from the Screen,                             or NULL for full-screen.RETURN VALUEThe input parameter dst, if dst was non-NULL on input.  A pointer to thenewly created cel or NULL if there is not enough memory to create the cel,if dst was NULL on input.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCreateSubrectCel(), DeleteCel()¾KY CreateSubrectCel ¾T Function¾DCCB * CreateSubrectCel(CCB *dst, CCB *src, SRect *subRect)¾CThis function creates a cel from a portion of another cel's data.  The newcel projects a subrectangle of the src cel's pixels.If the dst pointer is NULL this function allocates a new cel by doing a CloneCel(src, CLONECEL_CCB_ONLY).  The CCB_CCBPRE flag is forced on in thenew cel so that preamble word changes can be done without affecting the source cel.  The new cel's preamble words and ccb_SourcePtr are modifiedto access the specified subrectangle of the src cel's pixels.  The pixelsare not copied, the dst cel's ccb_SourcePtr will point into the src cel'sdata buffer.  If the src cel is CODED, the dst cel's ccb_PLUTPtr will point to the srccel's PLUT, but you are free to change ccb_PLUTPtr in the dst cel if youwant.  You are also free to change the dst cel's Flags, PIXC word, and ingeneral any CCB values.   Be careful about changing the preamble wordvalues that describe the subrectangle of the src cel's data.If the dst pointer is non-NULL, the allocation of a new cel is bypassed,and only the preamble and ccb_SourcePtr calcs are done.  This optionprovides improved performance; you can allocate the subrect cel just once,then continually call this function to have that cel access differentportions of the src cel's pixels.Using a non-NULL dst pointer is an implicit request for high performance,so this function does no error or sanity checking.  In particular, it isyour responsibility to ensure that the dst cel you supply is compatiblewith the src cel you want to extract data from, in terms of bit depth andother CCB parameters.  The recommended method is to use this function witha NULL dst pointer once to create a subrect cel for a given source cel,then only reuse that dst pointer in association with that source cel.This function works with all types of cels of any bit depth, except thatyou cannot extract a subrectangle from a PACKED source cel due to waypacked data is stored.ARGUMENTSdst                          A pointer to a cel created earlier by this                             function, or NULL to create a new cel.src                          A pointer to an existing cel; NULL is not                              allowed.subRect                      A pointer to an SRect describing the sub-                             rectangle to be extracted from the src cel;                             NULL is not allowed.RETURN VALUEThe input parameter dst, if dst was non-NULL on input.  A pointer to thenewly created cel or NULL if there is not enough memory to create the cel,if dst was NULL on input.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCreateLRFormCel(), DeleteCel()¾KY CreateTextCel ¾T Function¾DTextCel * CreateTextCel(FontDescriptor*fDesc, uint32formatFlags, int32width, int32height)¾CCreates a TextCel using the specified sizes and formatting options.Initially, the cel data buffer is empty; until you place text into the celall pixels are zero.If width and/or height are zero, the cel is initially created with a 1 x 1pixel size. Each time text is placed into the cel, the size automaticallychanges to reflect the size of the text in the cel. The formatFlags parameter contains one or more formatting options, ORed together.   Available options are:TC_FORMAT_LEFT_JUSTIFY left-justify text     TC_FORMAT_RIGHT_JUSTIFY right -justify textTC_FORMAT_CENTER_JUSTIFY center-justify textTC_FORMAT_WORDWRAP  auto-word-wrap   textUse DeleteTextCel()to dispose of the cel when you are finished with it.ARGUMENTSfDesc                        Pointer to a FontDescriptor structure.formatFlags                  Text-formatting options.width                        Width of the cel.height                       Height of the cel.RETURN VALUEA pointer to the newly created TextCel structure; NULL if there isn\xd5 tenough memory to create the new TextCel.¾F     TextLib.h     ¾RCloneTextCel(), DeleteTextCel(), taCreateTextCel()¾KY CRectFromCelReturn  ¾T Function¾DCRect * CRectFromCel(CRect *dst, CCB *cel)¾CThis function calculates a CRect that describes the cel's projection, andstores the results into *dst.  If the cel is projected to anon-rectangular shape, the result will be invalid.ARGUMENTSdst                          A pointer to a CRect where the results are                             to be stored.cel                          A pointer to the cel.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RSRectFromCel()¾KY CRectFromIVal ¾T Function¾DCRect * CRectFromIVal(CRect *dst, int32  tlx, int32  tly, int32  brx, int32  bry)¾CThis function stores the four specified corner values into the CRect at*dst.  ARGUMENTSdst                          A pointer to a CRect where the results are                             to be stored.tlx                          The value to assign to dst->tl.x.tly                          The value to assign to dst->tl.y.brx                          The value to assign to dst->br.x.bry                          The value to assign to dst->br.y.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCRectFromSRect()¾KY CRectFromSRect ¾T Function¾DCRect * CRectFromSRect(CRect *dst, SRect *src)¾CThis function converts an SRect into a CRect that describes the same area.ARGUMENTSdst                          A pointer to a CRect where the results are                             to be stored.src                          A pointer to an SRect to convert to a CRect.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCRectFromIVal(), SRectFromCRect()¾KY CRectIntersection ¾T Function¾DCRect * CRectIntersection(CRect *dst, CRect *rect1, CRect *rect2)¾CThis function calculates the intersection of two rectangles, returning arectangle that describes the common area.  The dst rectangle can be thesame as either source rectangle.  If there is no common area between thetwo source rectangles, the function return value is NULL, but the valuesin *dst are still modified.ARGUMENTSdst                          A pointer to a CRect where the results are                             to be stored.rect1                        A pointer to one of the source CRects.rect2                        A pointer to the other source CRect.RETURN VALUEReturns dst, or NULL if there is no common area between the sourcerectangles.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCRectUnion(), SRectIntersection()¾KY CRectUnion ¾T Function¾DCRect * CRectUnion(CRect *dst, CRect *rect1, CRect *rect2)¾CThis function calculates the union of two rectangles, returning arectangle that encompases all the area described by the two sourcerectangles.  The dst rectangle can be the same as either source rectangle.ARGUMENTSdst                          A pointer to a CRect where the results are                             to be stored.rect1                        A pointer to one of the source CRects.rect2                        A pointer to the other source CRect.RETURN VALUEReturns dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCRectIntersection(), SRectUnion()¾KY CrossFadeCels ¾T Function¾DCCB * CrossFadeCels(Item screen, int32 step, CCB *oldCel, CCB*newCel)¾CThis function calculates and optionally draws a 16-level crossfade betweentwo cels.  The crossfade is accomplished in 16 equal steps by 16 calls tothis function with the step parameter varying between 0 and 15 on eachsubsequent call.  Step 0 draws oldCel at 15/16 intensity and newCel at1/16 intensity, step 1 draws 14/16 oldCel and 2/16 newCel, and so on up tostep 15 which is 0/16 oldCel and 16/16 newCel (IE, oldCel is not drawn andnewCel is drawn as opaque).The screen parameter can be either a Screen or Bitmap item, in which casethe cels are drawn on each call. It can also be zero, in which case thecalculations are done but the cels are not drawn.  In the latter case, thereturn value is a pointer to the cels you must draw; the oldCel and newCelCCBs will be linked together in the right order for drawing.  As thecrossfade progresses the order in which the cels are drawn changes, so ifyou pass zero for the screen item you must draw the cels based on thisfunction's return value.This function make certain assumptions about the cels.  If the cels don'tmatch the assumptions your mileage may vary, visually.  Both cels shouldbe single cels, not lists of cels and not anti-aliased cels.  Both celsshould project to the same screen area.  If the cels contain transparencyin differing locations and there are non-black pixels under thetransparency area in the bitmap, the results may not be what you expect inthat area.  Coded-8 cels won't work because their AMV-based scaling can'tbe mixed with the PIXC-based scaling set up by this function.  The ccb_NextPtr, PIXC word, and CCB_LAST flag values in both cels are modifiedon each call.  After the last call (step=15) both cels' PIXC words arereset to 0x1F001F00, both cels' CCB_LAST flags are set, and both cels'ccb_NextPtr links are NULL.  If this doesn't work for your needs, save andrestore these values yourself, or clone the CCBs and pass the clones tothis function.  Other than the limitations and assumptions mentioned above, any type ofcels should work just fine (E.G., coded/uncoded, packed/not-packed, anyflags settings, any PLUT values, any size/perspective mapping, etc).  Thetwo cels can be different types (E.G., oldCel is coded6/newCel isuncoded16, oldCel is LRFORM/newCel isn't, etc).Each cel is drawn just once; no intermediate prescale-the-bitmap drawingis done.This function is coded so that you can start at any fade level, and skip intermediate levels if you want.  The last step should not be skipped,because it's the one that restores the PIXC words.  You can also call anystep multiple times.ARGUMENTSscreen                       A Screen or Bitmap item to which the cels                             are drawn, or zero to bypass the internal                             drawing step.step                         A value between 0 and 15 inclusive.oldCel                       A pointer to the old (outgoing) cel.newCel                       A pointer to the new (incoming) cel.RETURN VALUEA pointer to the cels to be drawn, useful only if the screen parameter waszero to bypass internal drawing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCrossFadeCels8()¾KY CrossFadeCels8 ¾T Function¾DCCB *   CrossFadeCels8(Item screen, int32 step, CCB *oldCel, CCB *newCel)¾CThis function calculates and optionally draws an 8-level crossfade betweentwo cels.  The crossfade is accomplished in 8 equal steps by 8 calls tothis function with the step parameter varying between 0 and 7 on eachsubsequent call.  Step 0 draws oldCel at 7/8 intensity and newCel at 1/8intensity, step 1 draws 6/8 oldCel and 2/8 newCel, and so on up to step 7which is 0/8 oldCel and 8/8 newCel (IE, oldCel is not drawn and newCel isdrawn as opaque).The screen parameter can be either a Screen or Bitmap item in which casethe cels are drawn on each call, or it can be zero in which case thecalculations are done but the cels are not drawn.  In the latter case, thereturn value is a pointer to the cels you must draw; the oldCel and newCelCCBs will be linked together in the right order for drawing.  As thecrossfade progresses, the order in which the cels are drawn changes, so ifyou pass zero for the screen item you must draw the cels based on thisfunction's return value.This function make certain assumptions about the cels.  If the cels don'tmatch the assumptions your mileage may vary, visually.  Both cels shouldbe single cels, not lists of cels and not anti-aliased cels.  Both celsshould project to the same screen area.  If the cels contain transparencyin differing locations and there are non-black pixels under thetransparency area in the bitmap, the results may not be what you expect inthat area.  Coded-8 cels won't work because their AMV-based scaling can'tbe mixed with the PIXC-based scaling set up by this function.  The ccb_NextPtr, PIXC word, and CCB_LAST flag values in both cels are modifiedon each call.  After the last call (step=15) both cels' PIXC words arereset to 0x1F001F00, both cels' CCB_LAST flags are set, and both cels'ccb_NextPtr links are NULL.  If this doesn't work for your needs, save andrestore these values yourself, or clone the CCBs and pass the clones tothis function.  Other than the limitations/assumptions mentioned above, any type of celsshould work just fine (EG, coded/uncoded, packed/not-packed, any flagssettings, any PLUT values, any size/perspective mapping, etc).  The twocels can be different types (EG, oldCel is coded6/newCel is uncoded16,oldCel is LRFORM/newCel isn't, etc).Each cel is drawn just once; no intermediate pre-scale-the-bitmap drawingis done.This function is coded so that you can start at any fade level, and skip intermediate levels if you want.  The last step should not be skipped,because it's the one that restores the PIXC words.  You can also call anystep multiple times.ARGUMENTSscreen                       A Screen or Bitmap item to which the cels                             are drawn, or zero to bypass the internal                             drawing step.step                         A value between 0 and 15 inclusive.oldCel                       A pointer to the old (outgoing) cel.newCel                       A pointer to the new (incoming) cel.RETURN VALUEA pointer to the cels to be drawn, useful only if the screen parameter waszero to bypass internal drawing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCrossFadeCels()¾KY DeleteCel ¾T Function¾DCCB * DeleteCel(CCB *cel)¾CThis function deletes any type of cel created by Lib3DO library functions.A NULL pointer is valid as input, and is quietly treated as a no-op.  Ifextra resources, such as a data buffer or PLUT, were allocated by thecreating function they are also released.  This function correctly handles anti-aliased cels, cels loaded as a groupfrom a single cel file, and other such constructs where several relatedcels were created and treated as if they were a single cel.  If a Lib3DOfunction gives you back a single CCB* return value even when it createsseveral linked cels at once, then you need pass only that single CCB* toDeleteCel() to release everything allocated when the group of cels wascreated.This function works correctly with cels loaded from a file via LoadCel(),and is equivelent to UnloadCel().  It also works on TextCels created bythe TextLib functions; DeleteCel() on the tc_CCB value of a TextCel isequivelent to DeleteTextCel().If you have custom functions for creating cels and those functions do notuse the standard library CreateCel() function as their basis, you canprovide  DeleteCel() support for your custom cels.  Doing so is a somewhatcomplex procedure which is fully documented in the Implementation Notessection of the source code file DeleteCelMagic.c in the Lib3DO sourcecode.  ARGUMENTScel                          A pointer to a cel created by any Lib3DO                              function; may be NULL.RETURN VALUENULL, always.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RDeleteCelList()¾KY DeleteCelList ¾T Function¾DCCB * DeleteCelList(CCB *celList)¾CThis function deletes a list of one or more cels.  It walks theccb_NextPtr links calling DeleteCel() on each cel, implying that all thecels in the list must be ones created by DeleteCel-compatible functions.  A NULL pointer is valid as input, and is quietly treated as a no-op.This function contains special logic for handling cels where the libraryfunction creates a related group of cels and returns a single CCB* valueto you.  In this sense, it is not exactly equivelent to walking theccb_NextPtr links.  When a group of related cels is linked into a largerlist, you need to call DeleteCel() only for the first cel in the group ofrelated cels.  This function contains logic to call DeleteCel() only onthe first cel in such a related group, then skip over the related celsthat get deleted all at once, and continue processing with any other celslinked after the related group.  For this reason, it is best to useDeleteCelList() if you have acquired cels from various Lib3DO functionsand linked them together into a larger list.  If you attempt to walk thelist yourself calling DeleteCel() on each cel, you have to keep track ofwhether any of the cels need to be skipped as you go.ARGUMENTScelList                      A pointer to a list of one or more cels                             created by Lib3DO functions; may be NULL.RETURN VALUENULL, always.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RDeleteCel()¾KY DeleteTextCel ¾T Function¾Dvoid DeleteTextCel(TextCel *tCel)¾CDeletes the specified text cel and all resources it acquired internallywhen it was created.  If SetTextCelFormatBuffer()dynamically allocates aformat buffer for the cel, that buffer is also released.Text cels are also compatible with the Lib3DO DeleteCel() and DeleteCelList() functions.  Those functions require a pointer to a CCB.  When they receive a pointer to a CCB associated with a text cel,processing is automatically handed off to DeleteTextCel() internally.ARGUMENTStCel                           Pointer to a TextCel structure (okay to                             pass NULL).RETURN VALUENothing.¾F     TextLib.h     ¾RCloneTextCel(), CreateTextCel()¾KY DetachTextCelCCB  ¾T Function¾DCCB * DetachTextCelCCB(TextCel *tCel)¾CReleases resources required for rendering new text into a cel, but retainspixels already rendered.  In addition to freeing resources, this functionremoves the reference to the FontDescriptor.  You can safely unload a fontafter calling this function, and still retain text you\xd5 ve alreadyrendered for drawing to the screen later when needed.Use DeleteCel()orDeleteCelList() to dispose of the CCB and cel data bufferwhen you no longer need them.  You cannot  use DeleteTextCel() on the celafter calling this function, since the TextCel structure has beendiscarded.ARGUMENTStCel                         pointer to a TextCel structure.RETURN VALUEA pointer to the CCB, the value that was originally in tCel->tc_CCB.¾F     TextLib.h     ¾R¾KY DisableMSEvent ¾T Function¾Dvoid DisableMSEvent(MSEventData *theEvent, int32 reserved)¾CThis function temporarily disables dispatching of the specified event.  Ifa message or signal is pending at the time this function is called thatfact is remembered and the event will be dispatched after it isre-enabled.  You can safely call this from within the handler for theevent being disabled, or from a handler for another event being controlledby the same MSEventData array.ARGUMENTStheEvent                     A pointer to the element of the MSEventData                              array that describes the event to disable.reserved                     Reserved for future expansion; pass zero.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     MsgUtils.h     ¾REnableMSEvent()¾KY DispatchMSEvents ¾T Function¾Dint32 DispatchMSEvents(MSEventHandle mseHandle, void *userContext, int32 reserved)¾CThis function waits for events and dispatches processing to the events'handlers.  It loops internally, waiting for messages and signals,dispatching the handlers when they are received, then looping back to waitagain after the handlers return.  As long as the handlers keep returningzero status this function loops internally.  As soon as a handler returnsa non-zero value this function returns that value to the caller.By convention, a negative return value is an error.  This may be an errorreturned by a handler function, or an error detected in waiting for anddecoding an event.  The latter should be very rare; the process of waitingfor a message or signal, looking up the message, and so on, is relativelyfoolproof.  It's likely to fail only if a message or port item isDeleteItem()'d out from under the dispatcher (so don't do that!).ARGUMENTSmseHandle                    An MSEventHandle returned by                              SetupMSEvents().userContext                  Any value you want; it is passed to the                             handler functions as they are dispatched.reserved                     Reserved for future expansion; pass zero.RETURN VALUEReturns negative on error, or any non-zero status returned by your eventhandler routines.IMPLEMENTATIONLib3DO function¾F     MsgUtils.h     ¾RSetupMSEvents()¾KY DrawAnimCel ¾T Function¾D void DrawAnimCel (ANIM *pAnim, Item bitmapItem, long xPos, long YPos, frac16 frameIncrement, long hotSpot)¾CDetermines the next cel to draw in the animation specified by pAnim anddraws it. Lets you draw a hotspot on that frame.ARGUMENTSpAnim                        Pointer to an ANIM structure returned by                              LoadAnim().An ANIM structure, defined in Parse3DO.h, looks as follows: typedef struct tag_ANIM{long num_Frames;                             /*max number of PDATs or CCBs in file*/                             frac16 cur_Fram/*allows fract values for                             smooth speed */long num_Alloced_Frames;                             AnimFrame *pentries;} ANIM;bitmapItem                   item  describing the bitmap into which the                             cel will be drawn.xPos                          x (horizontal) position for a hotspot in                             the cel.YPos                          y (vertical) position for a hotspot in the                             cel.frameIncrement               a frac16, 16.16 fixed point number to add to                             the current frame count. This is rounded to                             an integer to determine the next frame in                             the animation. If frameIncrement increments                             the current frame past the end of the                             animation, cur_Frame will be reset to the                             beginning. Note that this works backwards as                             well. hotSpot                       A integer (enum) equal to one of the                             following (defined in utils3do.h).#define                             CenterHotSpot1#define UpperLeftHotSpot2                             #define LowerLeftHotSpot3#define                             UpperRightHotSpot4#define LowerRightHotSpot5The cel is positioned with the hotspot at xPos, YPos.  Return Valuevoid¾F     AnimUtils.h     ¾RGetAnimCel(), LoadAnim()¾KY DrawImage ¾T Function¾D bool DrawImage (Item iScreen, ubyte* pbImage, ScreenContext *sc)¾CUses the fast SPORT mechanism, CopyVRAMPages(), to project an image into aframe buffer. The image must be stored in page aligned VRAM. The function executes during a vertical blank.ARGUMENTSiScreen                      Item for the screen into which to project                             the image.pbImage                      Pointer to a page-aligned buffer in VRAM                              containing a full-screen 16-bit image.sc                            Pointer to a screen context. RETURN VALUETRUE if successful, FALSE if not.¾F     DisplayUtils.h     ¾R¾KY DrawTextChar ¾T Function¾Dvoid DrawTextChar(FontDescriptor*fDesc, GrafCon*gcon, ItembitmapItem, uint32character)¾CDraws a character directly into a bitmap, using the colors and x/ycoordinates specified in the GrafCon.  The GrafCon\xd5 s pen coordinates are interpreted as integer (not Frac16)values. The call updates the GrafCon\xd5 s gc_PenX and gc_PenY fields toreflect the space the character pixels occupy within the bitmap. A newline(\n) character moves the gc_PenY value down by the font\xd5 sheight+leading value and sets the gc_PenX value to zero.The foreground and background colors follow the usual rules for cels: Acolor of 000 results in transparent output, for opaque black use 001.This function is an extremely inefficient way to get characters onto thescreen.  To draw more than one character, use the DrawTextString() orTextCel functions.ARGUMENTSfDesc                        Pointer to a FontDescriptor structure.gcon                         Pointer to a GrafCon structure containing                             the foreground and background colors and pen                             x/y coordinates to use in rendering the                             character.bitmapItem                   The bitmap into which the character is                             rendered.character                    The character to render.RETURN VALUENothing.¾F     TextLib.h     ¾RDrawTextString()¾KY DrawTextString ¾T Function¾Dvoid DrawTextString(FontDescriptor *fDesc, GrafCon *gcon, Item bitmapItem, char *text, ...)¾CDraws a text string directly into a bitmap, using the colors and x/ycoordinates specified in the GrafCon. The text string can be a simplestring of characters or a printf-style format string followed byadditional arguments. If you use printf-style formatting, the resultingformatted string cannot exceed 1024 characters. A maximum of tenprintf-style % formatting directives can appear in the string.  <<Thislimitation will be lifted when proper sprintf() support is added to the runtime library.>>The GrafCon\xd5 s pen coordinates are interpreted as integer (not Frac16)values. After the call, the GrafCon's gc_PenX and gc_PenY fields have beenupdated to reflect the space the character pixels occupy within thebitmap. A newline (\n) character moves the gc_PenY value down by thefont's height + leading value, and sets gc_PenX to its entry-time value. The net effect is that when there are multiple lines of text, each linebegins in the column specified by the initial value of gc_PenX. The foreground and background colors follow the usual rules for cels: acolor of 000 results in transparent output, for opaque black use 001.If you use typical double-buffering screen logic, it is more efficient touse a TextCel to hold your text string and redraw it on each frame with DrawScreenCels() than to rerender the string directly into the screenbitmap on each frame update.ARGUMENTSfDesc                        Pointer to a FontDescriptor structure.gcon                         Pointer to a GrafCon structure containing                             the foreground and background colors and pen                             x/y coordinates to use in rendering the                             character.bitmapItem                   The bitmap into which the character is                             rendered.text                         The string of characters to be rendered,                              optionally including printf-style %                             formatting commands....                          Optional arguments for printf-style                             formatting.RETURN VALUENothing.¾F     TextLib.h     ¾RDrawTextChar()¾KY EnableMSEvent ¾T Function¾Dvoid EnableMSEvent(MSEventData *theEvent, int32 reserved)¾CThis function re-enables dispatching of an event previously disabled by DisableMSEvent().  If a message or signal was pending at the time youcalled DisableMSEvent(), or if an event arrived while the handler wasdisabled, the event is dispatched to the handler as soon as it isre-enabled by this function. ARGUMENTStheEvent                     A pointer to the element of the MSEventData                              array that describes the event to disable.reserved                     Reserved for future expansion; pass zero.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     MsgUtils.h     ¾RDisableMSEvent()¾KY EraseTextInCel ¾T Function¾Dvoid EraseTextInCel(TextCel *tCel)¾CClears existing pixels from a text cel's data buffer.  All pixels are setto zero.ARGUMENTStCel                         Pointer to a TextCel structure.RETURN VALUENothing.¾F     TextLib.h     ¾KY FadeFromBlack ¾T Function¾D void FadeFromBlack (ScreenContext *sc, int32 frameCount)¾CFades all the screens in the ScreenContext from black over frameCount. ARGUMENTSsc                           Pointer to a ScreenContextframeCount                   Number of frames over which the fade will                              occur. After nFrames, all the color entries                             in the CLUT have their correct color value. RETURN VALUEvoid¾F     DisplayUtils.h     ¾KY FadeInCel ¾T Function¾D bool FadeInCel (CCB *ccb, CCB *maskccb, int32 *stepValue)¾CCalls SetCelScale() to set up the parameters for the next step in thefade-in of the cel and then increments stepValue. To fade in a cel, call SetFadeInCel() to initialize the CCBs, then iteratively call FadeInCel() and DrawCels()MAX_SCALE times. MAX_SCALE is defined in Utils3DO.h. ARGUMENTSccb                          Pointer to the CCB of the cel to fade in.maskccb                      Pointer to the scratch CCB already                             initialized by SetFadeInCel().stepValue                    Pointer to an int32 which will be                             incremented.RETURN VALUETRUE if successful, FALSE if not. Returns FALSE when stepValue reaches MAX_SCALE. ¾F     Utils3DO.h     ¾RSetCelScale(), SetFadeInCel(), SetFadeOutCel(), FadeOutCel()¾KY FadeOutCel ¾T Function¾D bool FadeOutCel (CCB *ccb, CCB *maskccb, int32 *stepValue)¾CCalls SetCelScale() to set up the parameters for the next step in thefade-out of the cel and then increments stepValue. To fade out a cel, callSetFadeInCel() to initialize the CCBs, then iteratively call FadeOutCel()and DrawCels() MAX_SCALE times.ARGUMENTSccb                          Pointer to a CCB. maskccb                      Pointer to the scratch CCB already                             initialized by SetFadeOutCel().stepValue                    Pointer to an int32 which will be                             incremented.RETURN VALUETRUE if successful, FALSE if not.¾F     Utils3DO.h     ¾RSetCelScale(), SetFadeInCel(), FadeInCel(), SetFadeOutCel()¾KY FadeToBlack ¾T Function¾D void FadeToBlack (ScreenContext *sc, int32 nFrames)¾CFades all the screens in the nFrames to black over nFrames. ARGUMENTSsc                           Pointer to a ScreenContextnFrames                      Number of frames over which the fade will                              occur. After nFrames, all the color entries                             in the CLUT will be zero, or black. RETURN VALUEvoid¾F     DisplayUtils.h     ¾RFadeFromBlack()¾KY FindChunk ¾T Function¾Dchar *FindChunk (ulong chunk_ID, char **buffer, long *bufLen)¾CSearches buffer until it finds chunk_ID. On exit, updates the bufferpointer that is to point to the next chunk and bufLen to contain thenumber of bytes remaining in the buffer. ARGUMENTSchunk_ID                     ID of the chunk you are looking for. *buffer                      Pointer to the buffer you are looking for.bufLen                       Number of bytes in the buffer that follow                             the chunk. RETURN VALUEReturns NULL or a pointer to the chunk.¾KY FinishAsyncLoadFile ¾T Function¾DErr FinishAsyncLoadFile(LoadFileInfo *lf, Err loadStatus)¾CThis function releases resources no longer needed after completion of anasync file load, leaving just the file data in the buffer (if the load wassuccessful).If you received I/O completion nofitication via message, call thisfunction passing ioreqPtr->io_Error as the loadStatus value andioreqPtr->io_User as the LoadFileInfo pointer.  If you detected I/Ocompletion using CheckAsyncLoadFile(), pass the return value from thatfunction as the loadStatus value.If the loadStatus value is negative and a buffer was automaticallyallocated by AsyncLoadFile() this function frees the buffer.  It releaseother resources (IOReq, etc) in all cases.ARGUMENTSlf                           A pointer to the LoadFileInfo structure for                             the load operation.loadStatus                   The status returned by CheckAsyncLoadFile()                             or contained in the I/O completion message                             you received.RETURN VALUEReturns the loadStatus value you passed in.IMPLEMENTATIONLib3DO function¾F     BlockFile.h     ¾RAsyncLoadFile()¾KY FPointFromFVal ¾T Function¾DFPoint* FPointFromFVal(FPoint *dst, frac16 x, frac16 y)¾CThis function stores the specified x and y values into *dst.  It is usefulfor writing inline calls such as:FPoint    wrk;OffsetCelListByFDelta(cel,FPointFromFVal(&wrk,  my_x, my_y));ARGUMENTSdst                          A pointer to the FPoint where the results                             are to be stored.x                            The value to assign to dst->x.y                            The value to assign to dst->y.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RFPointFromIVal()¾KY FPointFromIPoint ¾T Function¾DFPoint * FPointFromIPoint(FPoint *dst, IPoint *src)¾CThis function converts an IPoint to an FPoint.ARGUMENTSdst                          A pointer to the FPoint where the results                             are to be stored.src                          A pointer to the IPoint to be converted.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RIPointFromFPoint()¾KY FPointFromIVal ¾T Function¾DFPoint * FPointFromIVal(FPoint *dst, int32 x, int32 y)¾CThis function converts the specified values from integer to frac16 andstores them in *dst.  It is useful for writing inline calls such as:FPoint   wrk;OffsetCelListByFDelta(cel, FPointFromIVal(&wrk,  2, 2));ARGUMENTSdst                          A pointer to the FPoint where the results                             are to be stored.x                            The value to be converted into dst->x.y                            The value to be converted into dst->y.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RFPointFromFVal()¾KY FrameBufferToCel ¾T Function¾D bool FrameBufferToCel (Item iScreen, CCB* cel)¾CTRUE if successful, FALSE if not.CAVEATSThis function is extremely inefficient and should be avoided. Use CreateLRFormCel() instead. ¾F     Utils3DO.h     ¾R¾KY Free ¾T Function¾D void* Free (void *block)¾CFrees a block of memory previously allocated via Malloc(). Do not use thisfunction to free blocks of memory allocated by any method other than Malloc().ARGUMENTSblock                        Pointer to the memory block to be freed.RETURN VALUEAlways returns NULL.¾F     UMemory.h     ¾RMalloc(), MemBlockSize()¾KY FreeBuffer ¾T Function¾D void FreeBuffer (char *filename, long *fileBuffer)¾CThis function is obsolete ARGUMENTSfilename                     Address of a character string which                             specifies a filename.filebuffer                   Pointer to the memory buffer being released.                             Assumes the buffer is the same size as the                             file specified by filename.RETURN VALUEvoid¾F     Utils3DO.h     ¾RLoadAnim(), LoadCel(), LoadImage()¾KY GetAnimCel ¾T Function¾DCCB* GetAnimCel (ANIM *pAnim, frac16 frameIncrement)¾CReturns a pointer to the CCB of the next cel in an animation sequence.Adds frameIncrement to the current frame counter within the ANIM. Does notdraw the cel.ARGUMENTSpAnim                        pointer to an ANIM structure returned by                              LoadAnim().The ANIM structure is defined as follows:typedef struct tag_ANIM{long num_Frames;                             /*max number of PDATs or CCBs in file*/                             frac16 cur_Frame;/* allows fract values for                             smooth speed */long num_Alloced_Frames;                             AnimFrame *pentries;} ANIM;frameIncrement               a frac16 (16.16) fixed point number.RETURN VALUEPointer to the CCB that was found at the specified position in theanimation. ¾F     AnimUtils.h     ¾RDrawAnimCel, LinkCel¾KY GetCelBitsPerPixel ¾T Function¾Dint32 GetCelBitsPerPixel(CCB *cel)¾CThis function returns the bits-per-pixel value for the cel, determined by examining the cel's preamble data.This function exists primarily to support library internals, but may beuseful for applications as well.ARGUMENTScel                          A pointer to a cel.RETURN VALUEBits per pixel, one of 1, 2, 4, 6, 8, or 16.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY GetCelBytesPerRow ¾T Function¾Dint32 GetCelBytesPerRow(CCB *cel)¾CThis function returns the bytes-per-row value for the cel, determined byexaming the cel's preamble data.  The calculations take into account thecel's bit per pixel and source width values, and padding for the celengine's alignment and lookahead requirements.This function exists primarily to support library internals, but may beuseful for applications as well.ARGUMENTScel                          A pointer to a cel.RETURN VALUEBytes per row.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY GetCelDataBufferSize ¾T Function¾Dint32 GetCelDataBufferSize(CCB *cel)¾CThis function calculates the size needed for a cel data buffer based onthe values found in the cel's preamble words.  The calculations take intoaccount the cel's bit per pixel and source width and height values, andpadding for the cel engine's alignment and lookahead requirements.The return value is the size needed for the buffer, and not necessarilythe size of the buffer currently attached to the cel.  For example, usingthis function on a SubRect cel would return the size needed for thesub-rectangle, not the size currently used by the full-size source dataattached to the cel.  This function can be called when the cel has no buffer yet, providing thatthe CCB_CCBPRE flag is set.  In this sense, it can be useful forcalculating how big a data buffer to allocate.This function exists primarily to support library internals, but may beuseful for applications as well.ARGUMENTScel                          A pointer to a cel.RETURN VALUEBytes needed for the buffer.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY GetFontCharInfo ¾T Function¾Dint32 GetFontCharInfo(FontDescriptor *fDesc, int32 character, void **blitInfo)¾CReturns information about the specified character. The return value is thewidth of the character (not including intercharacter spacing). The voidpointer at *blitInfo will contain a special value to speed up processingwithin BlitFontChar().GetFontCharInfo() supports the internals of the text library; it shouldnever be necessary to call this function directly from an applicationprogram. If you are implementing your own replacement text library, use GetFontcharInfo() to obtain information about font character pixels beforeblitting them into your own memory buffer. You can use the standard textlibrary source code as a guide in creating your own text library.ARGUMENTSfDesc                        Pointer to a FontDescriptor structure.character                    The specific character you're looking for.blitInfo                     A void pointer updated by this call and then                             passed to the BlitFontChar() call.RETURN VALUEThe width of the character; zero if the character is not present in thefont.¾F     FontLib.h     ¾RBlitFontChar(), GetFontCharWidth()¾KY GetFontCharWidest ¾T Function¾Dint32 GetFontCharWidest(FontDescriptor *fDesc, char*string)¾CReturns the width in pixels of the widest character in the string.ARGUMENTSfDesc                          Pointer to a FontDescriptor structure.string                         The string to be scanned for the widest                             character width.RETURN VALUEThe width of the widest character.¾F     FontLib.h     ¾R¾KY GetFontCharWidth ¾T Function¾Dint32 GetFontCharWidth(FontDescriptor *fDesc, int32 character)¾CRetrieves the width of the specified character in the font. The returnvalue is the width of the character (not including intercharacterspacing).  ARGUMENTSfDesc                          Pointer to a FontDescriptor structure.character                      The specific character you're looking for.RETURN VALUEThe width of the character; zero if the character is not present in thefont.¾F     FontLib.h     ¾RGetFontStringWidth()¾KY GetFontStringWidth ¾T Function¾Dint32 GetFontStringWidth(FontDescriptor *fDesc, char *string)¾CCalculates the  width of the specified string.  The return value is thesum of the widths of the characters in the string.  The sum includes thespacing between each character, but not following the final character.  ARGUMENTSfDesc                          Pointer to a FontDescriptor structure.string                         The character string.RETURN VALUEThe width of the string.¾F     FontLib.h     ¾RGetFontCharWidth()¾KY GetHSecTime ¾T Function¾Dint32 GetHSecTime(Item ioreq)¾CThis function obtains the current value of the system microsecond timer,converts the seconds and microseconds into a single hundreths-of-a-secondvalue, and returns the converted value.The return value will overflow an int32 representation after the machinehas been powered on for about 250 days.  In other words, this function isprobably appropriate for debugging and performance measurement, but mayNOT be appropriate for a final application, since some applicationenvironments (such as cable TV) are almost certain to run on a machinepowered on for months at a time.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.RETURN VALUEReturns positive number of hundreths-of-a-second or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY GetTextCelColor ¾T Function¾Dvoid GetTextCelColor(TextCel *tCel, int32 *bgColor, int32*fgColor0)¾CRetrieves the background and foreground colors used when the cel is drawn.ARGUMENTSt                            Cel  Pointer to a TextCel structure.bgColor                      Pointer to a variable to receive the                             background color value.  May be NULL.fgColor                      Pointer to a variable to receive the                             foreground color value.  May be NULL.RETURN VALUENothing.¾F     TextLib.h     ¾RGetTextCelColors()¾KY GetTextCelColors ¾T Function¾Dvoid GetTextCelColors(TextCel *tCel, int32 bgColor, int32fgColors[4])¾CRetrieves the background and foreground colors used when the cel is drawn.This function gets all four foreground colors; use it with the featuresthat allow multiple text colors within a single cel. The fgColorsparameter must be a pointer to an array of exactly four int32 values.ARGUMENTStCel                         Pointer to a TextCel structure.bgColor                      Pointer to a variable to receive the                             background color value.  May be NULL.fgColor                      Pointer to an array to receive the                             foreground color values.  May be NULL.RETURN VALUENothing.¾F     TextLib.h     ¾RGetTextCelColor()¾KY GetTextCelCoords ¾T Function¾Dvoid GetTextCelCoords(TextCel *tCel, Coord *ccbX, Coord *ccbY)¾CRetrieves the TextCel CCB coordinates (ccb_XPos and ccb_YPos).    If you find it convenient to do so, work with the CCB\xd5 s position,size, and perspective fields directly; you don\xd5 t have to use thisfunction to safely obtain the on screen position.  The ccbX and ccbY values are interpreted as frac16 values (the same as theccb_XPos and ccb_YPos fields themselves).ARGUMENTStCel                         Pointer to a TextCel structure.ccbX                         Pointer to a variable to receive the x                             coordinate for the text cel CCB.ccbY                         Pointer to a variable to receive the y                             coordinate for the text cel CCB.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY GetTextCelFormatBuffer ¾T Function¾Dvoid GetTextCelFormatBuffer(TextCel *tCel, char **buffer, uint32*bufSize)¾CRetrieves the cel\xd5 s formatting buffer and size. The format buffer isused for printf-style formatting of text during rendering. If the buffersize is zero, the buffer pointer is not valid.ARGUMENTStCel                         Pointer to a TextCel structure.buffer                       Pointer to a variable to receive the pointer                             to the format buffer.bufsize                      Pointer to a variable to receive the size of                             the format buffer. RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY GetTextCelFormatFlags ¾T Function¾Duint32 GetTextCelFormatFlags(TextCel *tCel, uint32 *flags)¾CRetrieves the cel\xd5 s formatting flags.ARGUMENTStCel                         Pointer to a TextCel structure.flags                        If non-NULL, the format flags are stored at                             *flags.RETURN VALUEThe format flags.¾F     TextLib.h     ¾KY GetTextCelLeadingAdjust ¾T Function¾Dvoid GetTextCelLeadingAdjust(TextCel *tCel, int32*adjustLeading)¾CRetrieves the leading adjustment for text rendered in the cel. (Leading isthe extra vertical space between lines of text.) ARGUMENTStCel                         Pointer to a TextCel structure.adjustLeading                Pointer to a variable to receive the value                             added to the base leading value for the                             font.RETURN VALUENothing.¾F     TextLib.h     ¾KY GetTextCelMargins ¾T Function¾Dvoid GetTextCelMargins(TextCel *tCel, int32 *leftMargin, int32*topMargin)¾CRetrieves the top and left margins within the cel data buffer.  ARGUMENTStCel                         Pointer to a TextCel structure.leftMargin                   Pointer to a variable to receive the left                             margin for the cel.topMargin                    Pointer to a variable to receive the top                             margin for the cel.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY GetTextCelPenNumber ¾T Function¾Dvoid GetTextCelPenNumber(TextCel *tCel, int32 *penNumber)¾CRetrieves pen number used for text rendering.  ARGUMENTStCel                         Pointer to a TextCel structure.penNumber                    Pointer to a variable to receive the pen                             number.RETURN VALUENothing.¾F     TextLib.h     ¾KY GetTextCelSize ¾T Function¾Dvoid GetTextCelSize(TextCel *tCel, int32 *width, int32 *height)¾CRetrieves the current size for the text cel. You can also obtain thecurrent size of a cel by reading the ccb_Width and ccb_Height fields inthe cel\xd5 s CCB. Note that this retrieves the on screen size of the cel,not the size of the text currently in the cel. (The text currently in thecel may not fill the complete width or height of the cel.)ARGUMENTStCel                         Pointer to a TextCel structure.width                        Pointer to a variable to receive the width                             for the cel.height                       Pointer to a variable to receive the height                             for the cel.RETURN VALUENothing.¾F     TextLib.h     ¾KY GetTextCelSpacingAdjust ¾T Function¾Dvoid GetTextCelSpacingAdjust(TextCel *tCel, int32*adjustSpacing)¾CRetrieves the spacing adjustment for text rendered in the cel. Spacing isthe extra horizontal space between characters in the text.  ARGUMENTStCel                         Pointer to a TextCel structure.adjustSpacing                Pointer to a variable to receive the value                             added to the base spacing value for the                             font.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY GetTextCelTabStops ¾T Function¾Dvoid GetTextCelTabStops(TextCel *tCel, uint16 tabStops[16])¾CRetrieves the tab stops table for the text cel.  A full table of 16 valuesis stored even if some of the values are unused.  The end of the validentries in the table is marked with a zero.  ARGUMENTStCel                         Pointer to a TextCel structure.tabStops                     Pointer to an array of uint16 that receives                             the tab stops table.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY GetTextExtent ¾T Function¾Dchar * GetTextExtent(TextCel *tCel, int32 *pWidth, int32*pHeight, char *fmtString, ...)¾CCalculates the on-screen extent that would be used by the formatted text. GetTextExtent formats text (if necessary), calculates the pixel width andheight required to display the text, and returns width/height values viathe pointers you provide.  The function return value is a pointer to theformatted text (with printf-style formatting already resolved), a featurethat is mainly a convenience for the text library internals.This function does not take clipping into account; the returned width andheight may be larger than the current size of the text cel specified. As aresult, you can use this function to determine whether a cel needs to beexpanded by comparing the width and height it returns with the ccb_Widthand ccb_Height fields in the current cel.The related vGetTextExtent() function works exactly the same, but takes a va_list type instead of the ... parameters.ARGUMENTStCel                         Pointer to a TextCel structure.pWidth                       Pointer to the variable into which the width                             is returned.pHeight                      Pointer to the variable into which the                             height is returned.fmtString                    The string of characters to be rendered,                              optionally including printf-style %                             formatting commands....                          Arguments for printf-style formatting                             (optional).RETURN VALUEA pointer to the formatted text.¾F     TextLib.h     ¾RvGetTextExtent()¾KY GetTimerIOReq ¾T Function¾DItem GetTimerIOReq(void)¾CThis function obtains an IOReq item for use with the other timer utiltiesthat take an IOReq parm.  Use DeleteItem() to release the IOReq item whenyou no longer need it.  The timer-relatated functions which take an IOReq parm will perform much faster if you allocate an IOReq using this function and pass it to theother functions.  Letting the other functions create and delete an IOReqon each call is appropriate only if you're planning to call the functionjust a couple times throughout the run of your program.ARGUMENTSNone.  Return ValueAn IOReq item number, or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾R¾KY GetTSecTime ¾T Function¾Dint32 GetTSecTime(Item ioreq)¾CThis function obtains the current value of the system microsecond timer,converts the seconds and microseconds into a single tenths-of-a-secondvalue, and returns the converted value.The return value will overflow an int32 representation after the machinehas been powered on for about 7 years.  Chances are good that this is safeeven in a cable TV or other long-running environment.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.RETURN VALUEPositive number of tenths-of-a-second or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY GetTime ¾T Function¾Dint32 GetTime(Item ioreq)¾CThis function obtains the current value of the system microsecond timerand returns just the seconds portion.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.RETURN VALUEPositive number of seconds or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY GetVBLTime ¾T Function¾Dint32 GetVBLTime(Item ioreq, uint32 *hiorder, uint32 *loworder)¾CThis function obtains the current value of the system VBL timer and storesthe results at *hiorder and *loworder.  Either pointer can be NULL if youdon't need that part of the result.  The low-order part of the VBL timeris generally of the most interest; it doesn't roll over into thehigh-order part until after roughly 800 days of continuous running withouta reboot.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.hiorder                      A pointer to a variable into which the                             high-order portion of the VBL time is                             stored.loworder                     A pointer to a variable into which the                             low-order portion of the VBL time is stored.RETURN VALUEThe low-order portion of the VBL time (a positive value), or a negativeerror code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY GetUSecTime ¾T Function¾Dint32 GetUSecTime(Item ioreq, uint32 *seconds, uint32 *useconds)¾CThis function obtains the current value of the system microsecond timerand stores the results at *seconds and *useconds.  Either pointer can beNULL if you don't need that part of the result.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.seconds                      A pointer to a variable into which the                             high-order (full seconds) portion of the                             time is storeduseconds                     A pointer to a variable into which the                             low-order (microseconds) portion of the time                             is stored.RETURN VALUEThe high-order portion of the time (full seconds, a positive value), or anegative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY HZ_TO_USEC ¾T Function¾Dint32 HZ_TO_USEC(value)¾CThis macro converts a value expressed in hertz (cycles or ticks persecond) to the equivelent number of microseconds for each tick.  Truefloating point constant values are legal, for example HZ_TO_USEC(2.5). The compiler will resolve the constant at compile time without needingruntime floating point support.  The macro is usable in expression contextand only evaluates its argument once.ARGUMENTSvalue                        An integer constant or variable, or a                             floating point constant to be converted to                             microseconds.RETURN VALUEThe number of microseconds.IMPLEMENTATIONMacro¾F     TimerUtils.h     ¾R¾KY ICornerFromSRect ¾T Function¾DIPoint * ICornerFromSRect(IPoint *dst, SRect *src)¾CThis function calculates the opposite corner of the area described by thesrc rectangle, and stores the results at *dst.ARGUMENTSdst                          A pointer to the IPoint where the results                             are to be stored.src                          A pointer to an SRect.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RXCORNERFROMSRECT(), YCORNERFROMSRECT(), ISizeFromCRect()¾KY IPointFromFPoint ¾T Function¾DIPoint * IPointFromFPoint(IPoint *dst, FPoint *src)¾CThis function converts an FPoint to an IPoint.ARGUMENTSdst                          A pointer to the IPoint where the results                             are to be stored.src                          A pointer to the FPoint to be converted.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RFPointFromIPoint()¾KY IPointFromFVal ¾T Function¾DIPoint * IPointFromFVal(IPoint *dst, frac16 x, frac16 y)¾CThis functions converts the specified values from frac16 to integer andstores them at *dst.  It is useful for writing inline calls such as:IPoint   wrk;OffsetCelListByIDelta(cel, IPointFromFVal(&wrk,  my_x, my_y));ARGUMENTSdst                          A pointer to the IPoint where the results                             are to be stored.x                            The value to be converted into dst->x.y                            The value to be converted into dst->y.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RIPointFromIVal(), FPointFromFVal()¾KY IPointFromIVal ¾T Function¾DIPoint * IPointFromIVal(IPoint *dst, int32 x, int32 y)¾CThis functions stores the specified values at *dst.  It is useful forwriting inline calls such as:IPoint    wrk;OffsetCelListByIDelta(cel,IPointFromFVal(&wrk,  my_x, my_y));ARGUMENTSdst                          A pointer to the IPoint where the results                             are to be stored.x                            The value to be stored into dst->x.y                            The value to be stored into dst->y.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RIPointFromFVal(), FPointFromIVal()¾KY IPointIsInCRect ¾T Function¾DBoolean IPointIsInCRect(IPoint *point, CRect *rect)¾CThis function determines whether the point is within the rectangle. Points on the edge are considered within the rectange.ARGUMENTSpoint                        A pointer to an IPoint.rect                         A pointer to a CRect.RETURN VALUETRUE if the point is in the rectangle, FALSE if it is not.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RIPointIsInSRect()¾KY IPointIsInSRect ¾T Function¾DBoolean IPointIsInSRect(IPoint *point, SRect *rect)¾CThis function determines whether the point is within the rectangle. Points on the edge are considered within the rectange.ARGUMENTSpoint                        A pointer to an IPoint.rect                         A pointer to an SRect.RETURN VALUETRUE if the point is in the rectangle, FALSE if it is not.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RIPointIsInCRect()¾KY IS_LASTCEL ¾T Function¾DBoolean IS_LASTCEL(CCB *ccb)¾CThis macro evaluates to TRUE if no cels are linked to ccb, or FALSE ifother cels are linked to ccb.  This macro evaluates its argument more than once; be careful of sideeffects.   It is usable in expression context.ARGUMENTSccb                          A pointer to a cel.RETURN VALUETRUE if no cels are linked to this one; FALSE if cels are linked to thisone.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RLastCelInList()¾KY ISizeFromCRect ¾T Function¾DIPoint * ISizeFromCRect(IPoint *dst, CRect *src)¾CThis function calculates the width and height of the area described by thesrc rectangle and stores the results at *dst.ARGUMENTSdst                          A pointer to the IPoint where the results                             are to be stored.src                          A pointer to a CRECT.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RXSIZEFROMCRECT(), YSIZEFROMCRECT(), ICornerFromSRect()¾KY InsetCRect ¾T Function¾DCRect * InsetCRect(CRect *dst, IPoint *delta)¾CThis function shrinks or enlarges the amount of area described by the dst rectangle.  Positive delta values shrink the area, negative values enlargethe area.ARGUMENTSdst                          A pointer to the CRect to manipulate.delta                        A pointer to the delta values to apply to                             dst.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RInsetSRect()¾KY InsetSRect ¾T Function¾DSRect * InsetSRect(SRect *dst, IPoint *delta)¾CThis function shrinks or enlarges the amount of area described by the dst rectangle.  Positive delta values shrink the area, negative values enlargethe area.ARGUMENTSdst                          A pointer to the SRect to manipulate.delta                        A pointer to the delta values to apply to                             dst.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RInsetCRect()¾KY LastCelInList ¾T Function¾DCCB * LastCelInList(CCB *list)¾CThis function returns a pointer to the last cel in a list of one or morecels.ARGUMENTSlist                         A pointer to a list of cels; may be NULL.RETURN VALUEA pointer to the last cel in the list, or NULL if the list pointer isNULL.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RIS_LASTCEL()¾KY LinkCel ¾T Function¾D void LinkCel( CCB *ccb, CCB *nextCCB )¾CLinks nextCCB to ccb by setting ccb\xd5 s NextPtr field to nextCCBturningoff the CCB_LAST flag in ccb\xd5 s ccb_Flags field by setting CCB_LAST toNULLThis function does not splice nextCCB into an existing list. It onlyreplaces value of ccb_NextPtr in ccb to point to nextCCB. ARGUMENTSccb                          Pointer to the CCB being linked. nextCCB                      Pointer to the CCB being added to the list. RETURN VALUEvoid¾F     CelUtils.h     ¾R¾KY LoadAnim ¾T Function¾D ANIM * LoadAnim (char *fileName, uint32 memTypeBits)¾CLoads an animation file from disk. Parses the cels within the animationinto an ANIM structure and returns a pointer to the ANIM.The animation file can be single-CCB or multi-CCB format. An optional ANIMchunk may appear at the start of the file. The file can contain pixel andcolor chunks in either PDAT, PLUT or PLUT, PDAT order, but the chunks mustappear in the same order throughout the file. (3DO Animator creates PLUT,PDAT files; PDAT, PLUT files result from concatenating cel files usingMPW.) When you are finished with the animation, use UnloadAnim() to free all resources acquired by LoadAnim() for a given animation file. The frames within an animation are allocated incrementally. Initially ablock large enough to hold N_FRAMES_PER_CHUNK frames is allocated. If thisis exceeded while reading the ANIM then a block with space forN_FRAMES_PER_CHUNK additional frames is allocated, the previously computedframes are copied into this new space, and the old full buffer space isdeallocated The following structures are used by LoadAnim().typedef structtag_AnimFrame{CCB *af_CCB;/* Pointer to CCB for this frame */char*af_PLUT;/* Pointer to PLUT for this frame */char *af_pix;/* Pointer topixels for this frame */int32reserved;} AnimFrame;typedef struct tag_ANIM{long num_Frames;/*max number of PDATs or CCBs in file*/frac16 cur_Frame;/*allows fract values for smooth speed */long num_Alloced_Frames;AnimFrame*pentries;} ANIM;/**********************************************************The frames within an ANIM are allocated incrementally. Initially a blocklarge enough to hold N_FRAMES_PER_CHUNK frames is allocated. If this isexceeded while reading the ANIM then a block with space forN_FRAMES_PER_CHUNK additional AnimFrames is allocated, the previouslycomputed frames are copied into this new space, and the old full AnimFrame buffer space is deallocated ARGUMENTSfileName                     Pointer to the file name string. memTypeBits                  Type of memory to use when loading the file;                             usually MEMTYPE_ANY.RETURN VALUEA pointer to an ANIM structure, or NULL if an error occurred.¾F     AnimUtils.h     ¾RUnloadAnim(), GetAnimCel(), DrawAnimCel()¾KY LoadCel  ¾T Function¾DCCB * LoadCel (char *filename, uint32 memTypeBits)¾CThis function loads a cel or related group of  cels from a file.  Memoryfor the file is allocated according to memTypeBits, then the entire fileis loaded into the buffer using fast block I/O.  After the file is loaded,the cel(s) in the buffer are parsed by the ParseCel() function.If the file contains more than one cel, the CCBs are strung together viatheir ccb_NextPtr fields in the same order as they are encountered in thebuffer.  This allows you to store a group of related cels in one file, andtreat them as a single logical entity using the other CelUtils libraryfunctions that work with lists of cels.This function also contains special handling for anti-aliased cels. AACels are two cels stored together in the same file, but the CCBs arestored in reverse order of the way they must be drawn.  AACels arerecognized by a characteristic signature (exactly two cels, one is 4-bitcoded the other 16-bit uncoded, same size and coordinates, etc), and whendetected the CCB links are automatically reversed so the return value is alist of two cels linked in the proper order for drawing.  One drawback tothe signature-detection logic is that it prevents the storage of multiplerelated anti-aliased cels in the same file.Use DeleteCel() or UnloadCel() to release the resources acquired when thecel file is loaded.  When the file contains several cels, or ananti-aliased cel, use DeleteCel() or UnloadCel() only on the first cel inthe file.  That is, pass the pointer returned by this function. DeleteCel() will delete all the cels at once.  DeleteCelList() contains special logic to treat a group of cels loadedfrom the same file as if they were one cel.  If more cels were linked inthe list following a group loaded from the same file, DeleteCelList()calls DeleteCel() for the first cel in the group, then skips to the end ofthe group and resumes walking the ccb_NextPtr links as normal for the restof the cels.  This implies that you cannot load a group of cels from afile and then break apart the links built by LoadCel() and relink the celsinto different lists.  Doing so would confuse the logic inDeleteCelList().  ARGUMENTSfilename                     descmemTypeBits                  descRETURN VALUEA pointer to the cel or list of cels loaded from the file.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RParseCel(), DeleteCel, DeleteCelList, UnloadCel¾KY LoadFile ¾T Function¾D void* LoadFile (char *fileName, long *fileSizePtr,  uint32 memTypeBits)¾CLoads an entire file into a buffer in memory. This function allocates abuffer, loads the file into it, and returns a pointer to the allocatedbuffer. The size of the file is returned into a longword via thefileSizePtr parameter.Note that the buffer is allocated to an even multiple of the device\xd5 sblocksize (2 KB for CD-ROM and the Mac link), and thus may be slightlylarger than the actual size of the file. The file size returned viafileSizePtr, however, reflects the actual size of the file without theextra padding required to achieve an integral device block size.This function is approximately 3-4 times as fast as the old method ofloading a file using GetFileSize(), allocating a buffer, calling ReadFile(). When you are finished with the file, use UnloadFile() to freethe file buffer. If an error returns, the function return value is NULL and the longword atthe *fileSizePtr contains the error status. A return value of NULL with anerror status of zero indicates that the file exists but contains no data;in this cas, no buffer was allocated. ARGUMENTSfileName                     Pointer to the file name string.fileSizePtr                  Pointer to a longword which receives the                             length of file (in bytes). If you don\xd5 t                             need the length, a NULL pointer can be                             passed for this parameter.memTypeBits                  Type of memory to use when loading the file;                             usually MEMTYPE_ANY or MEMTYPE_VRAM.RETURN VALUEA pointer to loaded file in memory, or NULL if an error occurred.¾F     BlockFile.h     ¾RUnloadFile, LoadFileHere, AsyncLoadFile, ¾KY LoadFileHere ¾T Function¾Dvoid * LoadFileHere(char *fname, int32 *pfsize, void *buffer, int32 bufsize)¾CThis function loads a file into a buffer you allocate.  It is identical toLoadFile() except that it lets you allocate the buffer.  If the bufsizeparameter is non-zero, this function checks to ensure that the file willfit in the specified buffer.  The actual size of the file, which may besmaller than the buffer, is stored at *pfsize.  If an error occurs theword at *pfsize will contain a negative error code.  When allocating a buffer, remember that the buffer has to be an integralmultiple of the file device's blocksize.  That is, loading a 700 byte filefrom a CD still requires a 2k buffer.  A useful space-saving techniqueinvolves loading a small file into the inactive screen buffer in VRAM thencopying it (or perhaps just a small portion of it that you need) to aright-sized buffer elsewhere in memory.ARGUMENTSfname                        The name of the file to load.pfsize                       A pointer to a word which, after the call,                             holds the actual size of the file.buffer                       A pointer to a buffer large enough to hold                             the file.bufsize                      The size of the buffer, or zero to disable                             overflow checking.RETURN VALUEReturns a pointer to the buffer, or NULL on error.IMPLEMENTATIONLib3DO function¾F     BlockFile.h     ¾RLoadFile(), AsyncLoadFile()¾KY LoadFont ¾T Function¾DFontDescriptor * LoadFont(char *fileName, uint32memTypeBits)¾CLoads a font from the specified file and prepares it for use.Use UnloadFont() to release all resources acquired by LoadFont().ARGUMENTSfileName                     The font file to load.memTypeBits                  The type of memory to load the font into                             (usually MEMTYPE_ANY).RETURN VALUEA pointer to a FontDescriptor structure that describes the font; returnsNULL if the file is not found, is not a valid font file, or there is notenough memory to process the file.¾F     FontLib.h     ¾RUnloadFont(), ParseFont()¾KY LoadImage ¾T Function¾D ubyte* LoadImage (char *name, ubyte* dest, VdlChunk **rawVDLPtr, ScreenContext *sc)¾CLoads a 3DO file format image file specified by name into the bufferpointed to by dest. May optionally return a VDL (Video Display List) ifthe image file specifies per line CLUTs (Color Lookup Tables).ARGUMENTSname                         Pointer to char string containing a path                             name of an image file in 3DO file format.dest                         Pointer to destination buffer. If dest is                             NULL, a page aligned VRAM buffer large                             enough to hold an image is allocated. If                             dest is not NULL, it is assumed to point to                             a page aligned VRAM buffer large enough to                             hold a screen image.rawVDLPtr                    Pointer to a pointer to a VDL structure.                              LoadImage() fills this structure if the                             image file contains a custom VDL . sc                           Pointer to a screen context.RETURN VALUEReturns a pointer to the destination buffer if successful, NULL if not.Note that the returned buffer may have been allocated by LoadImage() ifthe dest input parameter was NULL.¾F     DisplayUtils.h     ¾RUnloadImage¾KY LoadSoundEffect ¾T Function¾D Item LoadSoundEffect (char* sFilename, int nNumVoices)¾CLoads a sound effect from the specified file and assigns it nNumVoices. Itdoes this by loading the Instrument template \xd2 sampler.ofx\xd3 ,allocating an instrument for the sound effect, loading the samplespecified by sFilename, and then attaching the sample to the allocatedinstrument.This function is being pased out and will not appear in future releases ofthe library. It uses global variables and inappropriate audio foliotechniques wwhich result in audio pops and clicks. The tsc_soundfx sourcecode in the Examples folder demonstrates proper techniques for managingsound effects. ARGUMENTSsFilename                    pointer to character string containing the                             path name of an audio sample file in AIFF                             format.nNumVoices                   number of voices to assign to this sound                             effect. 1 for Mono, 2 for stereo.RETURN VALUEThe item representing the allocated instrument.CAVEATS This function will not appear in future releases. ¾F     Parse3DO.h     ¾KY MakeNewCel ¾T Function¾D CCB* MakeNewCel (Rectf16 *r)¾CCreates a new cel with default CCB values and fills it with white pixels. This function is obsolete. Use CreateCel() or CreateBackdropCel(). ARGUMENTSr                            Pointer to a Rectf16 which specifies the                             size of the cel. RETURN VALUEA pointer to the CCB of the cel that was created. CAVEATSAllocates a new CCB structure and copies the data from ccb into this newCCB. Note that only the CCB, not the image data is duplicated. The pointerto the new image data is merely copied over to the new CCB. If you want tohave a duplicate image, then load in another copy.This function is obsolete. Use CloneCel()RETURN VALUEA pointer to the new CCB.ARGUMENTSccb                          Pointer to a CCB to duplicate.CAVEATSThis function is obsolete. Use CloneCel()¾F     Utils3DO.h          Utils3DO.h     ¾RCloneCel()¾KY Malloc ¾T Function¾D void* Malloc (uint32 size, uint32 memTypeBits)¾CAllocates a block of memory of the requested size and type.This function supports allocation of all memory types defined in thesystem header file mem.h, including valid combinations of types (forexample, MEMTYPE_CEL|MEMTYPE_FILL|0xFF to allocate cel memory which ispre-initialized to contain 0xFF in all bytes). The UMemory.h header fileautomatically includes the mem.h header file for you. This function correctly handles page-aligned VRAM allocations, returning apointer to the beginning of a VRAM memory page.A block of memory allocated with this function must be freed with the Free()not free() or FreeMem()function.ARGUMENTSsize                         Size (in bytes) of the block to be                             allocated.memTypeBits                  Type of memory to allocate.RETURN VALUEA pointer to the allocated block, or NULL if the memory couldn\xd5 t beallocated.¾F     UMemory.h     ¾RFree(), MemBlockSize()¾KY MapAACelToCQuad ¾T Function¾Dvoid MapAACelToCQuad(CCB *aacel, CQuad *quad)¾CThis function maps an anti-aliased cel to the specified quad.  It iseffectively a standard MapCel() call that stores its results into both thedata and alpha-channel CCBs.  It also works correctly if aacel points to asingle standalone cel.ARGUMENTSaacel                        A pointer to the cel to be mapped.quad                         A pointer to the CQuad to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapCelToCQuad(), MapCelListToCQuad()¾KY MapAACelToCRect ¾T Function¾Dvoid MapAACelToCRect(CCB *aacel, CRect *rect)¾CThis function maps an anti-aliased cel to the specified rectangle.  It ismuch faster than a standard MapCel() call because it only has to calculatea simple rectangular projection.  It stores its results into both the dataand alpha-channel CCBs.  It also works correctly if aacel points to asingle standalone cel.ARGUMENTSaacel                        A pointer to the cel to be mapped.rect                         A pointer to the CRect to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapAACelToSRect(), MapCelToCRect(), MapCelListToCRect()¾KY MapAACelToFPoint ¾T Function¾Dvoid MapAACelToFPoint(CCB *aacel, FPoint *newPosition)¾CThis function sets an anti-aliased cel's location to the givencoordinates.  It stores the coordinates into both the data andalpha-channel CCBs.  It also works correctly if aacel points to a singlestandalone cel.  Only the ccb_XPos and ccb_YPos values in the CCB aremodified; other CCB fields are not touched.ARGUMENTSaacel                        A pointer to the cel to be mapped.newPosition                  A pointer to the FPoint to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapAACelToIPoint(), MapCelToFPoint(), MapCelListToFPoint()¾KY MapAACelToIPoint ¾T Function¾Dvoid MapAACelToIPoint(CCB *aacel, IPoint *newPosition)¾CThis function sets an anti-aliased cel's location to the givencoordinates.  It stores the coordinates into both the data andalpha-channel CCBs.  It also works correctly if aacel points to a singlestandalone cel.  Only the ccb_XPos and ccb_YPos values in the CCB aremodified; other CCB fields are not touched.ARGUMENTSaacel                        A pointer to the cel to be mapped.newPosition                  A pointer to the FPoint to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapAACelToFPoint(), MapCelToIPoint(), MapCelListToIPoint()¾KY MapAACelToSRect ¾T Function¾Dvoid MapAACelToSRect(CCB *aacel, SRect *rect)¾CThis function maps an anti-aliased cel to the specified rectangle.  It ismuch faster than a standard MapCel() call because it only has to calculatea simple rectangular projection.  It stores its results into both the dataand alpha-channel CCBs.  It also works correctly if aacel points to asingle standalone cel.ARGUMENTSaacel                        A pointer to the cel to be mapped.rect                         A pointer to the SRect to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapAACelToCRect(), MapCelToSRect(), MapCelListToSRect()¾KY MapCelListToCQuad ¾T Function¾Dvoid MapCelListToCQuad(CCB *list, CQuad *quad)¾CThis function maps a list of cels to the specified quad.  It performs astandard MapCel() on the first cel in the list.  It then adjusts the X/Ycoordinates of the rest of the cels in the list such that all the celsmaintain the same relative X/Y relationships to each other.  It alsocopies the size and perspective fields from the first cel into all therest of the cels in the list.  The net effect is that the list of cels moves as if it were a single unit, although the operation doesn't includetrue 3D parallax calculations.ARGUMENTSlist                         A pointer to a list of one or more cels to                             be mapped.quad                         A pointer to the CQuad to which the cels are                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapAACelToCQuad(), MapCelToCQuad()¾KY MapCelListToCRect ¾T Function¾Dvoid MapCelListToCRect(CCB *list, CRect *rect)¾CThis function maps a list of cels to the specified rectangle.  It is muchfaster than a standard MapCel() call because it only has to calculate asimple rectangular projection.  It performs a MapCelToCRect() on the firstcel in the list.  It then adjusts the X/Y coordinates of the rest of thecels in the list such that all the cels maintain the same relative X/Yrelationships to each other.  It also copies the size and perspectivefields from the first cel into all the rest of the cels in the list.  The net effect is that the list of cels moves and scales as if it were asingle unit.ARGUMENTSlist                         A pointer to a list of one or more cels to                             be mapped.rect                         A pointer to the CRect to which the cels are                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapAACelToCRect(), MapCelToCRect()¾KY MapCelListToFPoint ¾T Function¾Dvoid MapCelListToFPoint(CCB *list, FPoint *newPosition, Boolean copyPerspective)¾CThis function sets a list of cels to the given coordinates.  It sets theX/Y coordinates of the first cel to the specified values.  It then adjuststhe X/Y coordinates of the rest of the cels in the list such that the celsmaintain the same relative X/Y relationships to each other.  The neteffect is that the list of cels moves as if it were a single unit. This function can optionally propagate the size and perspective valuesalready present in the first cel to the rest of the cels in the list. This is useful if you are manipulating size and perspective valuesmanually.  To propagate the size and perspective without changing thepositions, use one of the OffsetCelList() functions with delta values ofzero.ARGUMENTSlist                         A pointer to a list of one or more cels to                             be mapped.newPosition                  A pointer to the FPoint to which the cel is                             to be mapped.copyPerspective              TRUE to copy the size and perspective fields                             from the first cel to the rest of the list.                              FALSE to leave all size and perspective                             fields as is.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapCelListToIPoint(), MapAACelToFPoint(), MapCelToFPoint()¾KY MapCelListToIPoint ¾T Function¾Dvoid MapCelListToIPoint(CCB *list, IPoint *newPosition, Boolean copyPerspective)¾CThis function sets a list of cels to the given coordinates.  It thenadjusts the X/Y coordinates of the rest of the cels in the list such thatthe cels maintain the same relative X/Y relationships to each other.  Thenet effect is that the list of cels moves as if it were a single unit. This function can optionally propagate the size and perspective valuesalready present in the first cel to the rest of the cels in the list. This is useful if you are manipulating size and perspective valuesmanually.  To propagate the size and perspective without changing thepositions, use one of the OffsetCelList() functions with delta values ofzero.ARGUMENTSlist                         A pointer to a list of one or more cels to                             be mapped.newPosition                  A pointer to the FPoint to which the cel is                             to be mapped.copyPerspective              TRUE to copy the size and perspective fields                             from the first cel to the rest of the list.                              FALSE to leave all size and perspective                             fields as is.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapCelListToFPoint(), MapAACelToIPoint, MapCelToIPoint()¾KY MapCelListToSRect ¾T Function¾Dvoid MapCelListToSRect(CCB *list, SRect *rect)¾CThis function maps a list of cels to the specified rectangle.  It is muchfaster than a standard MapCel() call because it only has to calculate asimple rectangular projection.  It performs a MapCelToCRect() on the firstcel in the list.  It then adjusts the X/Y coordinates of the rest of thecels in the list such that all the cels maintain the same relative X/Yrelationships to each other.  It also copies the size and perspectivefields from the first cel into all the rest of the cels in the list.  The net effect is that the list of cels moves and scales as if it were asingle unit.ARGUMENTSlist                         A pointer to a list of one or more cels to                             be mapped.rect                         A pointer to the CRect to which the cels are                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapCelListToCRect(), MapAACelToSRect(), MapCelToSRect()¾KY MapCelToCQuad ¾T Function¾Dvoid MapCelToCQuad(CCB *cel, CQuad *quad)¾CThis function performs a standard MapCel() on a single cel.  It differsfrom the standard MapCel() call only in that it accepts a CQuad* datatype.ARGUMENTScel                          A pointer to the cel to be mapped.quad                         A pointer to the CQuad to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapAACelToCQuad(), MapCelListToCQuad()¾KY MapCelToCRect ¾T Function¾Dvoid MapCelToCRect(CCB *cel, CRect *rect)¾CThis function maps a single cel to the specified rectangle.  It is muchfaster than a standard MapCel() call because it only has to calculate asimple rectangular projection. ARGUMENTScel                          A pointer to the cel to be mapped.rect                         A pointer to the CRect to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapCelToSRect(), MapAACelToCRect(), MapCelListToCRect()¾KY MapCelToFPoint ¾T Function¾Dvoid MapCelToFPoint(CCB *cel, FPoint *newPosition)¾CThis function sets a single cel to the specified coordinates.  It simplystores the coordinates in the CCB X/Y position fields.ARGUMENTScel                          A pointer to the cel to be mapped.newPosition                  A pointer to the FPoint to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapCelToIPoint(), MapAACelToFPoint(), MapCelListToFPoint()¾KY MapCelToIPoint ¾T Function¾Dvoid MapCelToIPoint(CCB *cel, IPoint *newPosition)¾CThis function sets a single cel to the specified coordinates.  It convertsthe coordinates to frac16 and stores them in the CCB X/Y position fields.ARGUMENTScel                          A pointer to the cel to be mapped.newPosition                  A pointer to the FPoint to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapCelToFPoint(), MapAACelToIPoint(), MapCelListToIPoint()¾KY MapCelToSRect ¾T Function¾Dvoid MapCelToSRect(CCB *cel, SRect *rect)¾CThis function maps a single cel to the specified rectangle.  It is muchfaster than a standard MapCel() call because it only has to calculate asimple rectangular projection. ARGUMENTScel                          A pointer to the cel to be mapped.rect                         A pointer to the CRect to which the cel is                             to be mapped.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RMapCelToCRect(), MapAACelToSRect(), MapCelListToSRect()¾KY MapP2Cel ¾T Function¾Dvoid MapP2Cel (Point *q, CCB *ccb)¾CSets the CCB fields of a cel to draw that cel with its four cornersspecified by the array of four points addressed by q. Assumes that both the width and height of the cel are integral powers of 2. This is aspecial case of the more general MapCel()call in the graphics folio,optimized for power of 2 cels. This routine sets the CCB fields ccb_X, ccb_Y, ccb_HDX, ccb_HDY, ccb_VDX, ccb_VDY, ccb_DDX, and ccb_DDY. MapP2Cel() achieves its optimizations by performing right shifts instead of divides.ARGUMENTSq                            Pointer to an array of four points which                             specify the destination coordinates of the                             cel.ccb                          Pointer to the CCB for the cel. The cel\xd5                             s width and height must both be integral                             powers of 2 for this function to work                             properly.RETURN VALUEvoid¾F     Utils3DO.h     ¾RMapCel()¾KY MoveCel ¾T Function¾D void MoveCel (CCB *ccb, MoveRec *pMove)¾CMoves a cel from beginQuad to endQuad over numberOfFrames, using the MoveRec structure defined by PreMoveCel(). Each time MoveCel() is called, the increments calculated in PreMoveCel() are added to the current corner values and the results are applied to the corners of the cel using MapCel(). MoveCel() does not draw the cel into a frame buffer.ARGUMENTSccb                          Pointer to the CCB for the cel you want to                             move. This CCB\xd5 s position fields will be                             updatedpMove                        Pointer to the MoveRec structure that                             contains the increments and to the current                             quad.The MoveRec structure is defined as: typedef struct tag_MoveRec{MoveVect                             curQuadf16[4];/*the current coords for the                             cel*/MoveVect quadIncr[4];/*x and y                             increments for the corners*/}MoveRecThis structure, in turn, uses the MoveVect structure, which is defined as follows:typedef struct tag_MoveVect{frac16 xVector;                             frac16 yVector;} MoveVectRETURN VALUEvoid¾F     Utils3DO.h     ¾RPreMoveCel()¾KY MSEC_TO_USEC ¾T Function¾Dint32 MSEC_TO_USEC(value)¾CThis macro converts a number of milliseconds to the equivelent number of microseconds.  True floating point constant values are legal, for example MSEC_TO_USEC(2730.52).  The compiler will resolve the constant at compile time without needing runtime floating point support.  Values up to2,147,000 milliseconds (about 35 minutes) can be expressed withoutoverflowing an int32.  The macro is usable in expression context and onlyevaluates its argument once.ARGUMENTSvalue                        An integer constant or variable, or a                             floating point constant to be converted to                             microseconds.RETURN VALUEThe number of microseconds.IMPLEMENTATIONMacro¾F     TimerUtils.h     ¾R¾KY OffsetAACelByFDelta ¾T Function¾Dvoid OffsetAACelByFDelta(CCB *aacel, FPoint *deltaXY)¾CThis function adjusts an anti-aliased cel's location by the specifieddelta.  It adds the delta values to the X/Y coordinates in both the dataand alpha-channel CCBs.  It also works correctly if aacel points to asingle standalone cel.ARGUMENTSaacel                        A pointer to the cel to be moved.deltaXY                      A point to an FPoint containing the movement                             delta values.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾ROffsetAACelByIDelta(), OffsetCelByFDelta(), OffsetCelListByFDelta()¾KY OffsetAACelByIDelta ¾T Function¾Dvoid OffsetAACelByIDelta(CCB *aacel, IPoint *deltaXY)¾CThis function adjusts an anti-aliased cel's location by the specifieddelta.  It adds the delta values to the X/Y coordinates in both the dataand alpha-channel CCBs.  It also works correctly if aacel points to asingle standalone cel.ARGUMENTSaacel                        A pointer to the cel to be moved.deltaXY                      A pointer to an IPoint containing the                             movement delta values.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾ROffsetAACelByFDelta(), OffsetCelByIDelta(), OffsetCelListByIDelta()¾KY OffsetCel ¾T Function¾D void OffsetCel (CCB *ccb, int32 xOffset, int32 yOffset)¾CAdds the specified offsets to the position fields of the CCB identified byccb. ARGUMENTSccb                          Pointer to the CCB of the cel.xOffset                      Integer x offset.yOffset                      Integer y offset.RETURN VALUEvoid¾F     CelUtils.h     ¾R¾KY OffsetCRect ¾T Function¾DCRect * OffsetCRect(CRect *dst, IPoint *deltaXY)¾CThis function adjusts the location described by the dst rectangle byadding the specified delta values to the rectangle's corner values.ARGUMENTSdst                          A pointer to the CRect to move.deltaXY                      A pointer to an IPoint containing the                             movement delta values.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾ROffsetSRect(), InsetCRect()¾KY OffsetCelByFDelta ¾T Function¾Dvoid OffsetCelByFDelta(CCB *cel, FPoint *deltaXY)¾CThis function adjusts a single cel's location by the specified delta.  Itadds the delta values to the X/Y coordinates in the CCB.  ARGUMENTScel                          A pointer to the cel to be moved.deltaXY                      A pointer to an FPoint containing the                             movement delta values.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾ROffsetCelByIDelta(), OffsetAACelByFDelta(), OffsetCelListByFDelta()¾KY OffsetCelByIDelta ¾T Function¾Dvoid OffsetCelByIDelta(CCB *cel, IPoint *deltaXY)¾CThis function adjusts a single cel's location by the specified delta.  Itadds the delta values to the X/Y coordinates in the CCB.  ARGUMENTScel                          A pointer to the cel to be moved.deltaXY                      A pointer to an IPoint containing the                             movement delta values.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾ROffsetCelByFDelta(), OffsetAACelByIDelta(), OffsetCelListByIDelta()¾KY OffsetCelListByFDelta ¾T Function¾Dvoid OffsetCelListByFDelta(CCB *list, FPoint *deltaXY, Boolean copyPerspective)¾CThis function adjusts the location of all the cels in a list by adding thedelta values to the X/Y coordinates in cels' CCBs.  This function can optionally propagate the size and perspective valuesalready present in the first cel to the rest of the cels in the list. This is useful if you are manipulating size and perspective valuesmanually.  If you want to just copy the size and perspective values fromthe first cel to the rest of the cels without changing the cel positions,use a NULL deltaXY pointer and TRUE for copyPerspective.ARGUMENTSlist                         A pointer to the list of cels to be moved.deltaXY                      A pointer to an FPoint containing the                             movement delta values.copyPerspective              TRUE to copy the size and perspective fields                             from the first cel to the rest of the list.                              FALSE to leave all size and perspective                             fields as is.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾ROffsetCelListByIDelta(), OffsetAACelByFDelta(), OffsetCelByFDelta()¾KY OffsetCelListByIDelta ¾T Function¾Dvoid OffsetCelListByIDelta(CCB *list, IPoint *deltaXY, Boolean copyPerspective)¾CThis function adjusts the location of all the cels in a list by adding thedelta values to the X/Y coordinates in cels' CCBs.  This function can optionally propagate the size and perspective valuesalready present in the first cel to the rest of the cels in the list. This is useful if you are manipulating size and perspective valuesmanually.  If you want to just copy the size and perspective values fromthe first cel to the rest of the cels without changing the cel positions,use a NULL deltaXY pointer and TRUE for copyPerspective.ARGUMENTSlist                         A pointer to the list of cels to be moved.deltaXY                      A pointer to an IPoint containing the                             movement delta values.copyPerspective              TRUE to copy the size and perspective fields                             from the first cel to the rest of the list.                              FALSE to leave all size and perspective                             fields as is.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾ROffsetCelListByFDelta(), OffsetAACelByIDelta(), OffsetCelByIDelta()¾KY OffsetSRect ¾T Function¾DSRect * OffsetSRect(SRect *dst, IPoint *deltaXY)¾CThis function adjusts the location described by the dst rectangle byadding the specified delta values to the rectangle's position values.ARGUMENTSdst                          A pointer to the CRect to move.deltaXY                      A pointer to an IPoint containing the                             movement delta values.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾ROffsetCRect(), InsetSRect()¾KY OpenAudio ¾T Function¾D bool OpenAudio( void )¾COpenAudio() initializes the audio folio, opening it and loading a defaultmixer.It initializes the global variable TheMixer to make it accessible byother applications. TheMixer provides four \xd2 voices,\xd3  each with twoseparate audio channels.This function is being phased out and will not appear in future releasesof the library. It uses global variables and inappropriate audio foliotechniques which create audio pops and clicks. Use OpenAudioFolio() to initialize the audio folio for your application  RETURN VALUETRUE if successful, FALSE if not.ARGUMENTSNone  CaveatsThis function is obsolete. Use OpenAudioFolio() to initialize the audiofolio for your application.¾KY OpenGraphics ¾T Function¾D Boolean OpenGraphics (ScreenContext *sc, int nScreens)¾COpenGraphics() opens the graphics folio and sets up the specified screen context.You can allocate more than one screen buffer. The size of the screens is based on the default for the hardware in use.NTSC or PAL screen sizes are set up automatically. There are currently noprovisions in the function for opening NTSC-sized screens on a PAL system.ARGUMENTSScreenContext                The screen context to set. nScreens                     Number of screen buffers to allocate.RETURN VALUETRUE if successful, FALSE if not.¾F     DisplayUtils.h     ¾RCloseGraphics¾KY OpenMacLink ¾T Function¾Dbool OpenMacLink (void)¾CThis function is no longer needed. The actions it used to perform with thehelp of global variables are now all contained within the WriteMacFile() function. The function still exists for backward compatability, but nowsimply returns TRUE immediately. ARGUMENTSNone  Return ValueTRUE if successful, FALSE if not.CAVEATSThis function is obsolete. ¾F     Init3DO.h     ¾RWriteMacFile¾KY OpenSPORT ¾T Function¾Dbool OpenSPORT (void)¾CThis function is no longer needed. The actions it used to perform with thehelp of global variables are now all contained within the library routinesthat used to rely on the global variables. The function still exists forbackward compatibility but now simply returns TRUE immediately. ARGUMENTSnone  Return ValueTRUE if successful, FALSE if not.¾F     Init3DO.h     ¾RGetVRAMIOReq()¾KY ParseCel ¾T Function¾DCCB * ParseCel(void *inBuf, long inBufSize)¾CThis function parses cel(s) in a memory buffer.  It is useful when youhave loaded a cel file using some method other than LoadCel() and you needto parse the cels in the buffer.If the buffer contains more than one cel, the CCBs are strung together viatheir ccb_NextPtr fields in the same order as they are encountered in thebuffer.  This allows you to store a group of related cels in one file, andtreat them as a single logical entity using the other CelUtils libraryfunctions that work with lists of cels.This function also contains special handling for anti-aliased cels. AACels are two cels stored together in the same file, but the CCBs arestored in reverse order of the way they must be drawn.  AACels arerecognized by a characteristic signature (exactly two cels, one is 4-bitcoded the other 16-bit uncoded, same size and coordinates, etc), and whendetected the CCB links are automatically reversed so the return value is alist of two cels linked in the proper order for drawing.  One drawback tothe signature-detection logic is that it prevents the storage of multiplerelated anti-aliased cels in the same file.ARGUMENTSinBuf                        A pointer to a buffer containing the cel                             file image.inBufSize                    The size of cel file image in the buffer.RETURN VALUEA pointer to the list of cels parsed from the buffer.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RLoadCel()¾KY ParseFont ¾T Function¾DFontDescriptor * ParseFont(void *fontImage)¾CParses an in-memory image of a font file, creating a FontDescriptor for itand preparing it for use. Use this function when you\xd5 ve loaded a fontfile yourself (using data streaming or some other custom I/O method) andyou want to prepare the font for use by the font and text API routines.Use UnloadFont() to release resources acquired by ParseFont(). You must release the font image memory yourself; UnloadFont() only releasesresources acquired internally by ParseFont().ARGUMENTSfontImage                    A pointer to a font file image that you have                             loaded into memory.RETURN VALUEA pointer to a FontDescriptor structure that describes the font; NULL ifthe image is not a valid font file, or there is not enough memory tocreate a FontDescriptor structure.¾F     FontLib.h     ¾RLoadFont(), UnloadFont()¾KY PreMoveCel ¾T Function¾D void PreMoveCel (CCB *ccb, Point *beginQuad, Point *endQuad, int32 numberOfFrames, MoveRec *pMove)¾CCalculates the increments for each corner of a cel you want to move fromthe quadrilateral defined by beginQuad to the quadrilateral defined byendQuad. The numberOfFrames parameter specifies how many iterations areneeded to complete the movement. ARGUMENTSccb                          The CCB to be moved.beginQuad                    Four coordinates that define the starting                             position of the cel.endQuad                      Four coordinates that define the ending                             position of the cel.numberOfFrames               Number of iterations to go from beginning to                             end. Should be between 1 and 32767. pMove                        Pointer to the MoveRec to contain increments                             and the quadrilateral defined by beginQuad                             and endQuad.A MoveRec structure is defined as follows:typedef struct tag_MoveRec{MoveVect                             curQuadf16[4]; /*the current coords for the                             cel*/MoveVect quadIncr[4];  /*x and y                             increments for the corners*/}MoveRecThis structure, in turn, uses the MoveVect structure, which is defined as follows:typedef struct tag_MoveVect{frac16 xVector;                             frac16 yVector;} MoveVectRETURN VALUEvoid¾F     Utils3DO.h     ¾RMoveCel()¾KY ReadControlPad ¾T Function¾D long ReadControlPad (long lControlMask)¾CReturns the state of the first control pad:Returns the current state ofthe button for all bits that have a 1 in the corresponding position of thecontrol mask. Reports only down transitions for bits which have a 0 in thecontrol mask.  The mask functions as a report continuous mask. Relevant constants aredefined in hardware.h/* === JOYSTICK/JOYSTICK1 flags === */#defineJOYSTART 0x00000080#define JOYFIREC 0x00000040#define JOYFIREA 0x00000020#define JOYFIREB 0x00000010#define JOYDOWN  0x00000008#define JOYUP  0x00000004#define JOYRIGHT 0x00000002#define JOYLEFT  0x00000001#defineJOYSELECT JOYFIREC#define JOYMOVE   (JOYLEFT+JOYRIGHT+JOYUP+JOYDOWN)#define JOYBUTTONS (JOYFIREA+JOYFIREB+JOYFIREC+JOYSTART)ARGUMENTSlControlMask                 A long word control mask. RETURN VALUENone¾F     Utils3DO.h     ¾R¾KY ReadFile ¾T Function¾Dint ReadFile (char *filename, int32 size, long *buffer, long offset)¾CReadFile() uses the file system to read a file or a portion of a file intomemory. It performs up to four retries on each block read if the filesystem returns an error. ReadFile() is useful for loading a portion of a file, optionally startingat some offset into the file. For loading an entire file starting atoffset zero, the LoadFile() function is three to four times faster. ReadFile()fills the buffer with size bytes, beginning at offset. ARGUMENTSfilename                     Pointer to a string containing a valid                             pathname for a file in the currently mounted                             file system. size                         Number of bytes to read. buffer                       Pointer to a buffer into which the data will                             be read. Must be large enough to hold size                             bytes. offset                       Offset from the beginning of the file at                             which the read begins. RETURN VALUEThe number of bytes read, or -1 if an error occurred. ¾F     Parse3DO.h     ¾RLoadFile¾KY ReportMemoryUsage ¾T Function¾D void ReportMemoryUsage (void)¾CReports (via printf()) current system and task memory usage. This can be useful in finding memory leaks and other allocation-related problems inyour code. When your code is compiled with DEBUG defined as 0, thisfunction generates no code (a macro wrapper turns the call into a no-op).When DEBUG is non-zero, the macro wrapper invokes the display function.This lets you sprinkle ReportMemoryUsage() calls throughout your code,without any need to physically remove them for a final productioncompilation.This function is for debugging only. See Caveats below. ARGUMENTSNone.  Return ValueNothingCAVEATSThis function is for debugging only. The function walks OS private memorylists in fairly unsafe ways. It is possible that the OS could change thelists during the walk, resulting in crashes or other problems. While thisis an acceptable risk during debugging, it is absolutely unsafe for finalproduction code. ¾F     UMemory.h     ¾KY RenderCelFillRect ¾T Function¾Dvoid RenderCelFillRect(CCB *cel, int32 pixel, int32 x, int32 y, int32 w, int32 h)¾CThis function renders a filled rectangle into the cel's data buffer.This function performs no clipping internally.  You must be careful not topass coordinates that would result in rendering outside the cel's databuffer.This function supports all cel formats and bit depths except:     Packed cels.     LRForm cels.     6-bit coded cels.ARGUMENTScel                          A pointer to the cel.pixel                        The value to store into each pixel in the                             area.x                            The X coordinate within the cel data buffer.y                            The Y coordinate within the cel data buffer.w                            The width of the area to fill in the cel                             data buffer.h                            The height of the area to fill in the cel                             data buffer.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY RenderCelHLine ¾T Function¾Dvoid RenderCelHLine(CCB *cel, int32 pixel, int32 x, int32 y, int32w)¾CThis function renders a horizontal line into the cel's data buffer.This function performs no clipping internally.  You must be careful not topass coordinates that would result in rendering outside the cel's databuffer.This function supports all cel formats and bit depths except:     Packed cels.     LRForm cels.     6-bit coded cels.ARGUMENTScel                          A pointer to the cel.pixel                        The value to store into each pixel in the                             line.x                            The X coordinate within the cel data buffer.y                            The Y coordinate within the cel data buffer.w                            The width of the line to render in the cel                             data buffer.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY RenderCelOutlineRect ¾T Function¾Dvoid RenderCelOutlineRect(CCB *cel, int32 pixel, int32 x, int32 y, int32 w, int32 h)¾CThis function renders an outline (unfilled) rectangle into the cel's databuffer.This function performs no clipping internally.  You must be careful not topass coordinates that would result in rendering outside the cel's databuffer.This function supports all cel formats and bit depths except:Packed cels.LRForm cels. 6-bit coded cels.ARGUMENTScel                          A pointer to the cel.pixel                        The value to store into each pixel in the                             outline.x                            The X coordinate within the cel data buffer.y                            The Y coordinate within the cel data buffer.w                            The width of the area to outline in the cel                             data buffer.h                            The height of the area to outline in the cel                             data buffer.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY RenderCelPixel ¾T Function¾Dvoid RenderCelPixel(CCB *cel, int32 pixel, int32 x, int32 y)¾CThis function renders a single pixel into the cel's data buffer.This function performs no clipping internally.  You must be careful not topass coordinates that would result in rendering outside the cel's databuffer.This function supports all cel formats and bit depths except:   Packedcels.LRForm cels. 6-bit coded cels.ARGUMENTScel                          A pointer to the cel.pixel                        The value to store into the pixel.x                            The X coordinate within the cel data buffer.y                            The Y coordinate within the cel data buffer.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY RenderCelVLine ¾T Function¾Dvoid RenderCelVLine(CCB *cel, int32 pixel, int32 x, int32 y, int32h)¾CThis function renders a vertical line into the cel's data buffer.This function performs no clipping internally.  You must be careful not topass coordinates that would result in rendering outside the cel's databuffer.This function supports all cel formats and bit depths except: Packed cels.LRForm cels. 6-bit coded cels.ARGUMENTScel                          A pointer to the cel.pixel                        The value to store into each pixel in the                             line.x                            The X coordinate within the cel data buffer.y                            The Y coordinate within the cel data buffer.h                            The height of the line to render in the cel                             data buffer.RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY ReturnCelPixel ¾T Function¾Dint32 ReturnCelPixel(CCB *cel, int32 x, int32 y)¾CThis function returns the value of the specified pixel from the cel's databuffer.This function performs no clipping internally.  You must be careful not topass coordinates that would result in reading from outside the cel's databuffer.This function supports all cel formats and bit depths except:     Packed cels.     LRForm cels.     6-bit coded cels.ARGUMENTScel                          A pointer to the cel.x                            The X coordinate within the cel data buffer.y                            The Y coordinate within the cel data buffer.RETURN VALUEThe value of the specified pixel.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾KY SaveFile ¾T Function¾DErr SaveFile(char *filename, void *buffer, int32 bufsize, int32 extrabytes)¾CThis function stores the contents of a buffer to the named file. Currently the file has to be in NVRAM (IE, the filename must start with/NRVRAM/) but if other writable filesystems become available this functionwill work with them too.If the file doesn't already exist it is created.  If it does exist, itscontents are completely replaced by the contents of the specified buffer. When the file is created it is pre-sized to bufsize+extrabytes.  If thefile exists but needs to be expanded to hold the output it is expanded tothe size needed+extrabytes.  The point of the extrabytes parm is that expanding a file is relativelyexpensive. By specifying a non-zero extrabytes parameter you can ensurethat the file will grow enough to handle a few more slightly-growingoutputs before an expansion has to be done again.  If the nature of thedata you're saving is that it never grows, use an extrabytes value ofzero.  Remember that NVRAM is a precious limited resource; please don'tneedlessly usurp it with large extrabytes values.ARGUMENTSfilename                     The name of the file to save.buffer                       A pointer to a buffer full of data to be                             saved.bufsize                      The size of the data in the buffer.extrabytes                   The amount of extra space to allocate if and                             when the file is expanded.RETURN VALUEReturns zero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     BlockFile.h     ¾RLoadFile()¾KY SEC_TO_USE ¾T Function¾Dint32 SEC_TO_USEC(value)¾CThis macro converts a number of seconds to the equivelent number of microseconds.  True floating point constant values are legal, for example SEC_TO_USEC(2.5).  The compiler will resolve the constant at compile time without needing runtime floating point support.  Values up to 2147 seconds(about 35 minutes) can be expressed without overflowing an int32.  Themacro is usable in expression context and only evaluates its argumentonce.ARGUMENTSvalue                        An integer constant or variable, or a                             floating point constant to be converted to                             microseconds.RETURN VALUEThe number of microseconds.IMPLEMENTATIONMacro¾F     TimerUtils.h     ¾R¾KY SetCelScale ¾T Function¾D void SetCelScale (CCB *ccb, CCB *maskccb, int32 stepValue)¾CSetCelScale() sets up the multipliers and dividers of both ccb and maskccbto the level determined by stepValue. This provides a finer grained fadein by drawing the cel twice, once with ccb and once with maskccb. This function assumes that the cel has a checkerboard or random ditherP-Mode mask. The high and low words of the PPMPC are updated alternately.If the cel does not have a per pixel P-Mode mask, it fades in on evensteps only. This function is used by FadeInCel() and FadeOutCel(), and is not normallycalled by the user. ARGUMENTSccb                          Pointer to the CCB to be faded in.maskccb                      Pointer to a CCB. This CCB should be                             previously initialized by SetFadeInCel() to                             point to the same pixel data as ccb. stepValue                    Determines which scalar values entry to                             apply to the cel. The value is between 0 and                             22. RETURN VALUEvoid¾F     Utils3DO.h     ¾RSetFadeInCel(), SetFadeInCel(), SetFadeOutCel(), FadeOutCel()¾KY SetChannel ¾T Function¾D bool SetChannel (Item iInstrument, int nChannel)¾CAssigns an instrument to an audio channel.This function is being phased out and will not appear in future releasesof the library. It is associated with OpenAudio() and LoadSoundEffect(),and it uses global variables and inappropriate audio folio techniqueswhich create audio pops and clicks. The tsc_soundfx source code in theExamples folder demonstrates proper techniques for managing sound effects. ARGUMENTSiInstrument                  Item descriptor for an instrument. Usually                              obtained from LoadSoundEffect().nChannel                     The channel to use.RETURN VALUETRUE if successful, FALSE if not. ¾F     Utils3DO.h     ¾RLoadSoundEffect()¾KY SetFadeInCel ¾T Function¾D void SetFadeInCel (CCB *ccb, CCB *maskccb, int32 *stepValue)¾CSets up a cel for a FadeInCel() call as follows:copies the CCB data fromccb into maskccbinitializes the relevant CCB control fields in ccb andmaskccbinitializes stepValue to 0 SetFadeInCel() also links maskccb to cbb so that drawing ccb isautomatically followed by drawing maskccb. The two CCBs together allow afiner grained fade-in than is possible with a single CCB.ARGUMENTSccb                          Pointer to the CCB of a cel to be faded in.maskccb                      Pointer to a scratch CCB.stepValue                    Pointer to an Int32 used to hold the current                             step value index. RETURN VALUEvoid¾F     Utils3DO.h     ¾RSetCelScale(), FadeInCel(), SetFadeOutCel(), FadeOutCel()¾KY SetFadeOutCel ¾T Function¾D void SetFadeOutCel (CCB *ccb, CCB *maskccb, int32 *stepValue)¾CSets up the cel ccb points to for the FadeOutCel() function:copies the CCBdata from ccb into maskccbsets up the proper CCB control fields in the twoCCBsinitializes stepValue to 0 This function also links maskccb to cbb, so that drawing cbb willautomatically draw maskccb in succession. The two CCBs together allow afiner grained fade-in than a single CCB would allow.ARGUMENTSccb                          Pointer to the CCB of a cel to be faded out.maskccb                      Pointer to a scratch CCB.stepValue                    Pointer to an Int32 used to hold the current                             stepValue index. RETURN VALUETRUE if successful, FALSE if not.¾F     Utils3DO.h     ¾RSetCelScale(), SetFadeInCel(), FadeInCel(), FadeOutCel()¾KY SetMixer ¾T Function¾D bool SetMixer (int nChannel, int32 nVolume, int32 nBalance)¾CSets the overall volume and balance of a given audio channel.This function is being phased out and will not appear in future releasesof the libaray. It is associated with OpenAudio() and LoadSoundEffect()and it uses global variables and inappropriate audio folio techniqueswhich create audio pops and clicks. The tsc_soundfx source code in theExamples folder demonstrates proper techniques for managing sound effects.ARGUMENTSnChannel                     Audio channel to set.nVolume                      Overall volume for this channel. Ranges from                             0 to 0x7FFF. The volume passed in is                             actually divided by four, assuming a 4x2                             mixer.nBalance                     Balance setting for this channel. 0x4000 is                             the mid point. 0x7FFF is full right.RETURN VALUETRUE if successful, FALSE if not. ¾F     Utils3DO.h     ¾R¾KY SetQuad ¾T Function¾D void SetQuad (Point *r, Coord left, Coord top, Coord right, Coord bottom)¾CSet an array of four points (a quad) to conform to the rectangle definedby the values of left, top, right, and bottom.ARGUMENTSr                            pointer to an array of four Point                             structures. left                         Coordinate of the left edge of the                             rectangle.top                          Coordinate of the top edge of the rectangle.right                        Coordinate of the right edge of the                             rectangle.bottom                       Coordinate of the bottom edge of the                             rectangle.RETURN VALUEvoid¾F     Utils3DO.h     ¾RSetRect()¾KY SetRectf16 ¾T Function¾D void SetRectf16 (Rectf16 *r, Coord left, Coord top, Coord right, Coord bottom)¾CSets the four corners of the specified rectangle to be fixed point 16.16conversions of the four integer coordinates passed to the function. TheRectf16 structure is defined as follows:typedef struct tag_Rectf16{frac16rectf16_XLeft;frac16 rectf16_YTop;frac16 rectf16_XRight;frac16rectf16_YBottom;} Rectf16;ARGUMENTSr                            Pointer to a Rectf16 structure.left                         Integer Coord.top                          Integer Coord.right                        Integer Coord. bottom                       Integer Coord. RETURN VALUEvoid¾F     Utils3DO.h     ¾RSetQuad()¾KY SetTextCelColor ¾T Function¾Dvoid SetTextCelColor(TextCel *tCel, int32 bgColor, int32fgColor0)¾CSets the background and foreground colors to use when the cel is drawn.Because of special internal logic that calculates scaled colors foranti-aliasing, you must use this function to change the colors, ratherthan manipulating the cel\xd5 s PLUT directly. After you use this call tochange the colors, the next DrawCels() call renders the existing contentsof the cel using the new colors.Colors follow the usual rules for 3DO cels. The bgColor and fgColor valuesare interpreted as RGB555 values.  A color of 0,0,0 is transparent. To getopaque black,  use MakeRGB15(0,0,1).  If bgColor or fgColor0 is passed as-1L, the corresponding values in the text cel remain unchanged.When created, a text cel has default colors of transparent for background,and pure white for foreground. ARGUMENTStCel                         Pointer to a TextCel structure.bgColor                      The background color, used by zero-value                             pixels in the character bitmap.fgColor                      The foreground color, used by non-zero-value                             pixels in the character bitmap.RETURN VALUENothing.¾F     TextLib.h     ¾RSetTextCelColors()¾KY SetTextCelColors ¾T Function¾Dvoid SetTextCelColors(TextCel *tCel, int32 bgColor, int32fgColors[4])¾CSets the background and foreground colors to  use when the cel is drawn.This Function sets all four foreground colors; use it with features thatallow multiple text colors within a single cel. Because of specialinternal logic that calculates scaled colors for anti-aliasing, you mustuse this function to change the colors, rather than manipulating thecel\xd5 s PLUT directly. After you use this call  to change the colors,the next DrawCels() call renders the contents already in the cel in  newcolors.Colors follow the usual rules for 3DO cels.  The bgColor and fgColor values are interpreted as RGB555 values.  A color of 0,0,0 istransparent.  To get opaque black,  use MakeRGB15(0,0,1). If bgColoror anyof the fgColorsare passed as -1L, the corresponding values in the text celremain unchanged.When created, a TextCel has default colors of transparent for background,pure white for foreground pen 0, and no color (transparent) for foregroundpens 1-3. ARGUMENTStCel                         Pointer to a TextCel structure.bgColor                      The background color, used by zero-value                             pixels in the character bitmap.fgColor                      The foreground colors, used by                              non-zero-value pixels in the character                             bitmap, according the TextCel\xd5 s pen                             color value when the pixels were rendered.RETURN VALUENothing.¾F     TextLib.h     ¾KY SetTextCelCoords ¾T Function¾Dvoid SetTextCelCoords(TextCel *tCel, Coord ccbX, Coord ccbY)¾CSets the TextCel CCB coordinates (ccb_XPos and ccb_YPos).  Use this callas a convenience so that you don\xd5 t need to dereference through twolevels of pointers to update the CCB\xd5 s on-screen position.  If  it\xd5 s convenient, you can manipulate the CCB\xd5 s position, size,and perspective fields directly; you don\xd5 t have to use this functionto safely modify the on-screen position. Other utility routines forpositioning cels, such as MapCel(), may also be safely used.The ccbX and ccbY values are interpreted as integer values if, when viewedas a longword, they are in the range of -1024<value<1024.  (That is, ifinterpreting the values as frac16 types would result in a very smallfraction  almost zero they are assumed to be integers.)  In this case, SetTextCelCoords() converts the values to frac16 before storing them intothe CCB. Values outside that range are considered to be frac16 valuesalready, and are stored into the CCB without conversion.ARGUMENTStCel                         Pointer to a TextCel structure.ccbX                         The x coordinate for the text cel CCB.ccbY                         The y coordinate for the text cel CCB.RETURN VALUENothing.¾F     TextLib.h     ¾KY SetTextCelFormatBuffer ¾T Function¾DErr SetTextCelFormatBuffer(TextCel *tCel, char *buffer, uint32bufSize)¾CAttaches a text-formatting buffer to a TextCel. The buffer is used forprintf-style formatting of text during rendering. If a text cel has aformat buffer, text rendered into the cel passes first through sprintf() for formatting. If there is no format buffer attached to the cel (thedefault), sprintf() is not invoked at render time.  If the bufSize parameter is zero, any buffer already in the cel isremoved, and if the buffer was acquired internally, it is released. (DeleteTextCel() also automatically releases an internally acquiredbuffer.)  If the bufSize parameter is non-zero, a format buffer is attached to thecel. In this case, if the buffer parameter is NULL, a buffer of thespecified size is dynamically allocated internally. If the bufferparameter is non-NULL, it is a pointer to a buffer that you have eitherdynamically allocated or a static buffer within your application. When youspecify your own buffer, you are responsible for releasing it; the libraryinternals will not attempt to release a buffer you provided via a non-NULLbuffer parameter.A format buffer must be large enough to hold the largest possibleformatted string that you try to render. Internally, at rendering time,the printf-style format string and arguments you supply are passed to sprintf() for formatting. If the resulting string is larger than theformat buffer, the Debugger window displays a message, but memory beyondthe end of the buffer has already been corrupted at that point. (This is atypical limitation of sprintf() processing.)Many text cels can share the same format buffer to save memory. The bufferis only used while text is being rendered into the cel. Once UpdateTextInCel()returns, the buffer is no longer in use by that cel, andcan be used in formatting the contents of another cel. The only time it isnot safe to use the same format buffer for multiple text cels is in amultithreaded application where more than one thread might be calling UpdateTextInCel() simultaneously.ARGUMENTStCel                         Pointer to a TextCel structure.buffer                       Pointer to a buffer to use for text                             formatting, or NULL to have a buffer                             dynamically allocated for you.bufsize                      Size of the format buffer. RETURN VALUEZero if successful, or -1 if dynamic buffer allocation fails; that is, ifthere is not enough memory.¾F     TextLib.h     ¾KY SetTextCelFormatFlags ¾T Function¾Dvoid SetTextCelFormatFlags(TextCel *tCel, uint32 formatFlags)¾CSet the text formatting options used for subsequent rendering.The formatFlags parameter contains one or more formatting options, ORed together.   Available options are:TC_FORMAT_LEFT_JUSTIFY - left-justifytextTC_FORMAT_RIGHT_JUSTIFY - right-justify textTC_FORMAT_CENTER_JUSTIFY -center-justify textTC_FORMAT_WORDWRAP - auto-word-wrap textChanging the formatting options does not affect pixels already in the cel.You can make a series of calls to UpdateTextInCel()with thereplaceExisting flag set to FALSE, intermixed with calls to  SetTextCelFormatFlags().   This allows you to create, for example, aparagraph of word-wrapped text, followed by a line of centered text,followed by another word-wrapped paragraph.  Turning word wrap on and offat locations other than a paragraph boundary might produce undesirableresults.  Word wrapping should only be changed immediately following anewline.ARGUMENTStCel                           Pointer to a TextCel structure.formatFlags                    The new formatting options.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY SetTextCelLeadingAdjust ¾T Function¾Dvoid SetTextCelLeadingAdjust(TextCel *tCel, int32 adjustLeading)¾CSets a leading adjustment for text rendered in the cel. Leading is theextra vertical space between lines of text. The base leading value comesfrom theFontDescriptor attached to the cel. The value you specify in thiscall is a signed adjustment to the leading. Negative values render linesof text closer together; positive values render lines farther apart.ARGUMENTStCel                           Pointer to a TextCel structure.adjustLeading                  The value (in pixels) to add to the base                             leading value for the font.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY SetTextCelMargins ¾T Function¾Dvoid SetTextCelMargins(TextCel *tCel, int32 leftMargin, int32topMargin)¾CSets the top and left margins within the cel data buffer. When you erasethe text in a cel, the pen returns to the top and left margin values. Whenthe pen encounters a newline in the text, the pen returns to theleft-margin value (and down to the next text line).If you set a margin value greater than the width and/or height of the cel,all text rendered into the cel will be clipped.ARGUMENTStCel                           Pointer to a TextCel structure.leftMargin                     New left margin for the cel.topMargin                      New top margin for the cel.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY SetTextCelPenNumber ¾T Function¾Dvoid SetTextCelPenNumber(TextCel *tCel, int32 penNumber)¾CSets the pen number used for subsequent text rendering. The pen number,which must be in the range of 0 through 3, indexes to one of the fourpossible foreground colors. Whenyou create a text cel, only pen 0 has a default color assigned; otherpens are initialized to no color (transparent). Therefore you must use SetTextCelColors() and specify nontransparent colors for pens 1-3 before text you render with those pens will appear.ARGUMENTStCel                           Pointer to a TextCel structure.penNumber                      Pen number to use for text subsequently                              rendered into the cel.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY SetTextCelSize ¾T Function¾DErr SetTextCelSize(TextCel *tCel, int32 width, int32 height)¾CSets a new size for the text cel. If width and/or height are zero, the celis set to a 1 x 1 pixel size initially, and each time text is placed intothe cel the size automatically changes to reflect the size of thecharacters actually in the cel.Whenever you change a cel\xd5 s size, you lose the cel\xd5 s  currentcontents, because the data buffer is discarded and reallocated at the newsize, and after allocation all pixels in the buffer are set to zero.ARGUMENTStCel                           Pointer to a TextCel structure.width                          New width for the cel.height                         New height for the cel.RETURN VALUENon-negative if successful, or negative if a new cel  data buffer can\xd5t be allocated.¾F     TextLib.h     ¾R¾KY SetTextCelSpacingAdjust ¾T Function¾Dvoid SetTextCelSpacingAdjust(TextCel *tCel, int32 adjustSpacing)¾CSets a spacing adjustment for text rendered in the cel. Spacing is theextra horizontal space between characters in the text. The base spacingvalue comes from the FontDescriptor attached to the cel. The value youspecify in this call is a signed adjustment to the spacing. Negativevalues render characters in the text closer together; positive valuesrender characters farther apart.ARGUMENTStCel                         Pointer to a TextCel structure.adjustSpacing                The value (in pixels) to add to the base                             spacing value for the font.RETURN VALUENothing.¾F     TextLib.h     ¾R¾KY SetTextCelTabStops ¾T Function¾Dvoid SetTextCelTabStops(TextCel *tCel, uint16 tabStops[16], ...)¾CSets the tab stops table for the text cel.  The tabStops parameter is apointer to an array of up to 16 uint16 values, or it is NULL to indicatethat up to 15 tab stops are available as a comma-delimited list in the ...args.  In either case, the list of tab stops must be in ascending numericorder.  Entering a zero value terminates the list.  If more than 15 tabstops are read without encountering a terminating zero, a zero is forcedinto the 16th array element in the text cel\xd5 s internal tabs table.Tab stops are specified in terms of pixels from the left edge of the cel. The tab stops are relative to zero, not to the left margin.ARGUMENTSt                            Cel  Pointer to a TextCel structure.tabStops                     Pointer to an array of uint16 that contains                             the new tab stops table.  NULL means read                             tab stops from ... args....                          List of tab stops, terminated with a zero.                              Used if tabStops parameter is NULL.                             (Optional.) RETURN VALUENothing.¾F     TextLib.h     ¾KY SetupMSEvents ¾T Function¾DMSEventHandle SetupMSEvents(MSEventData eventData[], int32 numEvents, int32 reserved)¾CThis function creates resources needed to dispatch message and signalevents.  It uses the array of MSEventData structures you pass in to decidewhat type of setups to do.  It allocates signal and port items that youdidn't allocate yourself, and also builds internal control data to assistin waiting for and dispatching the events. The MSEventData structure is defined in MsgUtils.h as follows:typedefstruct MSEventData {    char *  name;    int32  (*handler)(MSEventData*eventData, void *userContext);    void *  userData;    int32  signal;   Item  port;    Item  msgItem;    Message *  msgPtr;    MsgValueTypes * msgValues;    MSEventHandle  backLink;} MSEventData;The values you place in the MSEventData structures before calling thisfunction control resource allocation, as described in the followingparagraphs.If you provide a non-NULL name pointer the MSEventData describes a messageport.  If the name field is NULL it describes a signal.  For messageports, the port is created using the name you provide; if you don't need aname just provide an empty string ("") for the name.The handler field is a pointer to your function to handle events for themessage port or signal.  Every event must have a non-NULL handler pointer.If you set the signal field to zero and the name field is NULL,SetupMSEvents() will allocate a signal for you and store it in this field. If the signal field is non-zero and the name field is NULL the signalfield is used as the signal(s) to be waited on for this event.  If thename field is non-NULL (IE, this is a message event) any value alreadyexisting in the signal field is replaced with the port's signal mask during setup.If you set the port field to zero and the name field is non-NULL,SetupMSEvents() will allocate a message port for you and store it in thisfield.  If the port field is non-zero, it is assumed to be a message portitem number for a port you allocated yourself.  If the name field is NULL(IE, this is a signal event) the port field is ignored.The remaining fields, (msgItem, msgPtr, msgValues, and backLink) areread-only fields from your point of view.  When a message event arrives,the dispatcher fills in the msgItem, msgPtr, and msgValues fields beforecalling your handler function.  Your handler can refer to these valueswhen processing the message.The MSEventData array can contain some elements for which you've allocatedyour own signal or port and other elements with zero values that request automatic allocation at setup time.  The internals keep track of whoallocated which resources and at cleanup time only automatically allocatedresources are freed automatically.ARGUMENTSeventData                    A pointer to an array of MSEventData                             structures which describe the event(s).numEvents                    The number of elements in the MSEventData                              array.reserved                     Reserved for future expansion; pass zero.RETURN VALUEReturns negative on error, or non-negative on success.  The non-negativereturn value is a handle which must be passed to the Dispatch and Cleanuproutines.IMPLEMENTATIONLib3DO function¾F     MsgUtils.h     ¾RCleanupMSEvents(), DispatchMSEvents()¾KY Sleep ¾T Function¾DErr Sleep(Item ioreq, uint32 seconds)¾CThis function puts the calling task in a wait state for the specifiednumber of seconds.  The function does not return until the time haspassed.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.seconds                      The number of seconds to sleep.RETURN VALUEZero for success, or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY SleepHSec ¾T Function¾DErr SleepHSec(Item ioreq, uint32 hseconds)¾CThis function puts the calling task in a wait state for the specifiednumber of hundreths-of-a-second. The function does not return until thetime has passed.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.hseconds                     The number of hundredths-of-a-second to                             sleep.  This value can be larger than 100.RETURN VALUEZero for success, or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY SleepMSec ¾T Function¾DErr SleepMSec(Item ioreq, uint32 mseconds)¾CThis function puts the calling task in a wait state for the specifiednumber of milliseconds. The function does not return until the time haspassed.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.mseconds                     The number of milliseconds to sleep.  This                             value can be larger than 1000.RETURN VALUEZero for success, or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY SleepTSec ¾T Function¾DErr SleepTSec(Item ioreq, uint32 tseconds)¾CThis function puts the calling task in a wait state for the specifiednumber of tenths-of-a-second.  The function does not return until the timehas passed.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.tseconds                     The number of tenths-of-a-second to sleep.                              This value can be larger than 10.RETURN VALUEZero for success, or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY SleepUSec ¾T Function¾DErr SleepUSec(Item ioreq, uint32 seconds, uint32 useconds)¾CThis function puts the calling task in a wait state for the specifiedperiod of time.  The function does not return until the time has passed.ARGUMENTSioreq                        An IOReq item obtained from GetTimerIOReq(),                             or zero to have an IOReq dynamically                             created/deleted during the call.seconds                      The number of seconds to sleep.useconds                     The number of microseconds to sleep.RETURN VALUEZero for success, or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RGetTimerIOReq()¾KY SRectFromCRect ¾T Function¾DSRect * SRectFromCRect(SRect *dst, CRect *src)¾CThis function converts a CRect to an SRect that describes the same area.ARGUMENTSdst                          A pointer to an SRect where the results are                             to be stored.src                          A pointer to a CRect to be converted to an                             SRect.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCRectFromSRect()¾KY SRectFromCel ¾T Function¾DSRect * SRectFromCel(SRect *dst, CCB *cel)¾CThis function calculates the rectangle occupied by a cel as projected andstores the results into *dst.  If the cel is projected to anon-rectangular shape the results will be invalid.ARGUMENTSdst                          A pointer to an SRect where the results are                             to be stored.cel                          A pointer to the cel.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RCRectFromCel()¾KY SRectFromIVal ¾T Function¾DSRect * SRectFromIVal(SRect *dst, int32 x, int32 y, int32 w, int32 h)¾CThis function stores the specified position and size value into *dst.  ARGUMENTSdst                          A pointer to an SRect where the results are                             to be stored.x                            The value to assign to dst->pos.x.y                            The value to assign to dst->pos.y.w                            The value to assign to dst->size.x.h                            The value to assign to dst->size.y.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RSRectFromCRect()¾KY SRectIntersection ¾T Function¾DSRect * SRectIntersection(SRect *dst, SRect *rect1, SRect *rect2)¾CThis function calculates the intersection of two rectangles, returning arectangle that describes the common area.  The dst rectangle can be thesame as either source rectangle.  If there is no common area between thetwo source rectangles, the function return value is NULL, but the valuesin *dst are still modified.ARGUMENTSdst                          A pointer to an SRect where the results are                             to be stored.rect1                        A pointer to one of the source SRects.rect2                        A pointer to the other source SRect.RETURN VALUEThe input parameter dst, or NULL if there is no common area between thesource rectangles.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RSRectUnion(), CRectIntersection()¾KY SRectUnion ¾T Function¾DSRect * SRectUnion(SRect *dst, SRect *rect1, SRect *rect2)¾CThis function calculates the union of two rectangles, returning arectangle that encompases all the area described by the two sourcerectangles.  The dst rectangle can be the same as either source rectangle.ARGUMENTSdst                          A pointer to an SRect where the results are                             to be stored.rect1                        A pointer to one of the source SRects.rect2                        A pointer to the other source SRect.RETURN VALUEThe input parameter dst.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RSRectIntersection(), CRectUnion()¾KY ShutDown ¾T Function¾D void ShutDown (void)¾CThis function calls CloseAudioFolio(). The fucntion is being phased outand will not appear in future releases of the library.  You should justcall CloseAudioFolio() directly. ARGUMENTSnone  Return ValuevoidCAVEATSThis function is obsolete. Use CloseAudioFolio() instead. ¾F     Init3DO.h     ¾RCloseAudioFolio()¾KY taCreateTextCel ¾T Function¾DTextCel * taCreateTextCel(TagArg *tags)¾CCreates a new text cel.  Specifying appropriate tags and values during celcreation sets all configurable attributes of the text cel.   If youinclude TCEL_TAG_UPDATE_TEXT_STRING in the tags, the specified text isrendered into the cel after processing all other tags.The only required tag is TCEL_TAG_FONT.  All unspecified attributes areset to default values as per CreateTextCel().  If width and/or height tagsare not specified, the associated values are set to zero, resulting in anauto size cel.  Tags are documented in Appendix A of this document. ARGUMENTStags                         Pointer to an array of tags and associated                             values.RETURN VALUEA pointer to the newly created TextCel structure; returns NULL if thereisn\xd5 t enough memory to create the new TextCel, which indicates thatinvalid tags are present.¾F     TextLib.h     ¾RCreateTextCel()¾KY taModifyTextCel ¾T Function¾DTextCel * taModifyTextCel(TextCel *tCel, TagArg *tags)¾CChanges attributes already in a text cel.  You can set all configurableattributes of the text cel by specifying appropriate tags and values.   Ifyou include TCEL_TAG_UPDATE_TEXT_STRING  in the tags, the specified textis rendered into the cel after processing all other tags.A negative return value is possible when the text cel size or formatbuffer attributes are changed and a memory allocation failure occurs.  Apositive non-zero return value is possible if TCEL_TAG_UPDATE_TEXT_STRINGis specified and characters are clipped.  Otherwise, the return value iszero.Tags are documented in Appendix A of this document. ARGUMENTStCel                         Pointer to a TextCel structure.tags                         Pointer to an array of tags and associated                             values.RETURN VALUENegative on error, non-negative if successful.¾F     TextLib.h     ¾RSetTextCel...() functions¾KY TimerCancel ¾T Function¾DErr TimerCancel(TimerHandle thandle)¾CThis function cancels a timer (if active) and releases all resourcesacquired when it was created.  The timer's handle is no longer valid afterthis call.  If an event had occurred for this timer and a notification message wassent, this function withdraws the notification message from your port.  Ifyou had already received the message but not yet replied to it, thetimer's resources are released after you reply to the message.  In otherwords, you can respond to a timer event message by cancelling the timerthat sent the message, and you can safely do so before replying to themessage.If the timer notification was signal-based and a notification signal wassent, you will still receive it since there is no way to withdraw a signalonce it has been sent.ARGUMENTSthandle                      The handle for a timer created by one of the                             TimerMsg or TimerSignal functions.RETURN VALUEZero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerSuspend()¾KY TimerChangeUserdata ¾T Function¾DErr TimerChangeUserdata(TimerHandle thandle, uint32 userdata1, uint32 userdata2)¾CThis function changes the user data associated with a timer.  The userdata is delivered to you as part of the notification message formessage-based timers.  The user data is not meaningful for signal-basedtimers.ARGUMENTSthandle                      The handle for a timer created by one of the                             TimerMsg or TimerSignal functions.userdata1                    A value passed back to you in the                             msg_DataPtr field of the notification                             message.userdata2                    A value passed back to you in the                             msg_DataSize field of the notification                             message.RETURN VALUEZero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾R¾KY TimerReset ¾T Function¾DErr TimerReset(TimerHandle thandle, uint32 seconds, uint32 usecs_or_fields)¾CThis function restarts a timer using new time values.  If the timer wassuspended, this reactivates it.  If the timer was active, this stops thecurrent action and restarts the timer with the new time values.  This canbe used to start a new delay even if the old one hadn't triggered yet.For microsecond-based timers, pass both seconds and microseconds values. For VBL-based timers, pass zero for seconds and put the new field count inthe usecs_or_fields parm.If an event had occurred for this timer and a notification message wassent, this function withdraws the notification message from your port.  Ifyou had already received the message but not yet replied to it, the timeris still restarted properly.  In other words, you can respond to a timerevent message by resetting the timer that sent the message, and you cansafely do so before replying to the message.ARGUMENTSthandle                      The handle for a timer created by one of the                             TimerMsg or TimerSignal functions.seconds                      The new seconds value for the timer.usecs_or_fields              The new microseconds or field-count value                             for the timer.RETURN VALUEZero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerRestart()¾KY TimerRestart ¾T Function¾DErr TimerRestart(TimerHandle thandle)¾CThis function restarts a timer using the same time values as the last timethe timer was active.  If the timer was suspended, this reactivates it. If the timer was active, this stops the current action and restarts thetimer.  This can be used to start a new delay even if the old one hadn'ttriggered yet.  It can also be used to re-sync a heartbeat timer to someexternal event.If an event had occurred for this timer and a notification message wassent, this function withdraws the notification message from your port.  Ifyou had already received the message but not yet replied to it, the timeris still restarted properly.  In other words, you can respond to a timerevent message by restarting the timer that sent the message, and you cansafely do so before replying to the message.ARGUMENTSthandle                      The handle for a timer created by one of the                             TimerMsg or TimerSignal functions.RETURN VALUEZero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerReset()¾KY TimerServicesClose ¾T Function¾Dvoid TimerServicesClose(void)¾CThis function closes your task's connection to a TimerServices threadstarted by some other task.  Before calling this function, ensure thatyour task and all its child threads have called TimerCancel() to releaseany timers they were using.ARGUMENTSNone.  Return ValueZero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerServicesShutdown()¾KY TimerServicesOpen ¾T Function¾DErr TimerServicesOpen(void)¾CThis function establishes your task's connection to a TimerServices threadstarted by some other task.  After a successful return from this functionyour task and all its child threads can use timer services.ARGUMENTSNone.  Return ValueZero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerServicesStartup()¾KY TimerServicesShutdown ¾T Function¾Dvoid TimerServicesShutdown(void)¾CThis function shuts down the TimerServices thread.  Before calling thisfunction, ensure that your task and all its child threads have calledTimerCancel() to release any timers they were using.Only the task which started the TimerServices thread may shut it down.ARGUMENTSNone.  Return ValueZero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerServicesClose()¾KY TimerServicesStartup ¾T Function¾DErr TimerServicesStartup(int32 delta_priority)¾CThis function starts the timer services thread.  The thread's priority isset to your task's priority plus the delta_priority.  After calling thisfunction your task and all its child threads can use timer services.The service thread doesn't use many CPU cycles, and it uses them only whenyou make requests for services and when time events occur.  Generally, youshould run the service thread at a slightly higher priority than the restof your tasks/threads, especially if timely notifications are critical.If this function returns positive 1, that indicates that someone else hasalready started the service thread.  In this case, you should respond bycalling TimerServicesOpen() to connect with the already-running thread.ARGUMENTSdelta_priority               A value added to your task's priority, the                             result becomes the thread's priority.RETURN VALUEZero on success, one if the thread is already running, or a negative errorcode.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerServicesOpen()¾KY TimerServicesVerify ¾T Function¾DErr TimerServicesVerify(void)¾CThis function causes the TimerServices thread to check all outstandingtimers to make sure the tasks and threads that created them are stillrunning.  If any tasks or threads have died without releasing theirtimers, this function releases them.  This function is intended to be called by the task that started theservice thread.  If a main task starts the service thread and then spawnsother tasks that may use the services, it can call this function aftereach child task has completed.  This function forces a cleanup of anytimers a child task left outstanding, which can help prevent the leakingaway of resources from the main task's memory/item pools.  The cleanupwill not affect any timers belonging to child tasks or threads which arestill running.When the library is compiled with DEBUG=1 in effect, this function reportsin the debugger terminal window any cleanup actions it has to take .  Thiscan help you identify tasks or threads which are leaving timersoutstanding when they terminate.ARGUMENTSNone.  Return ValueZero on success or a negative error code.  If some timers had to bereleased because their owners died, that is NOT considered to be an error.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾R¾KY TimerSuspend ¾T Function¾DErr TimerSuspend(TimerHandle thandle)¾CThis function suspends an active timer but does not release resourcesassociated with the timer.  If the timer was already suspended thisfunction acts as a no-op.If an event had occurred for this timer and a notification message wassent, this function withdraws the notification message from your port.  Ifyou had already received the message but not yet replied to it, the timeris still properly suspended.  In other words, you can respond to a timerevent message by suspending the timer that sent the message, and you cansafely do so before replying to the message.Use TimerRestart() to reactivate the timer using the old time values.  UseTimerReset() to reactivate it using new time values.   If the timer isdelay-based, suspending then restarting the timer does not resume thedelay count from the point it was suspended, it starts a new delay of thespecified period.ARGUMENTSthandle                      The handle for a timer created by one of the                             TimerMsg or TimerSignal functions.RETURN VALUEZero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerCancel()¾KY TimerMsgAfterDelay ¾T Function¾DTimerHandle TimerMsgAfterDelay(Item msgport, uint32 seconds, uint32 microseconds, uint32 userdata1, uint32 userdata2)¾CThis function creates a timer that notifies you by message after thespecified delay.  The timer is a one-shot; after sending a notificationmessage the timer enters a suspended state.  Use TimerReset() toreactivate the timer using new time values, TimerRestart() to startanother delay period of the same length as last time, or TimerCancel() todelete the timer.The TimerServices thread must be active before calling this function.ARGUMENTSmsgport                      The port to which the notification message                             is sent.seconds                      The seconds portion of the delay.microseconds                 The microseconds portion of the delay.  This                             value can be larger than 1 million.userdata1                    A value passed back to you in the                             msg_DataPtr field of the notification                             message.userdata2                    A value passed back to you in the                             msg_DataSize field of the notification                             message.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerMsgAtTime(), TimerMsgHeartbeat()¾KY TimerMsgAfterDelayVBL ¾T Function¾DTimerHandle TimerMsgAfterDelayVBL(Item msgport, uint32 fields, uint32 userdata1, uint32 userdata2)¾CThis function creates a timer that notifies you by message after thespecified number of VBLs have occurred.  The timer is a one-shot; aftersending a notification message the timer enters a suspended state.  UseTimerReset() to reactivate the timer using new time values, TimerRestart()to start another delay period of the same length as last time, orTimerCancel() to delete the timer.The TimerServices thread must be active before calling this function.ARGUMENTSmsgport                      The port to which the notification message                             is sent.fields                       The number of VBLs to occur before sending                             the message.userdata1                    A value passed back to you in the                             msg_DataPtr field of the notification                             message.userdata2                    A value passed back to you in the                             msg_DataSize field of the notification                             message.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerMsgAtTimeVBL(), TimerMsgHeartbeatVBL()¾KY TimerMsgAtTime ¾T Function¾DTimerHandle TimerMsgAtTime(Item msgport, uint32 seconds, uint32 microseconds, uint32 userdata1, uint32 userdata2) ¾CThis function creates a timer that notifies you by message at thespecified time.  The timer is a one-shot; after sending a notificationmessage the timer enters a suspended state.  Use TimerReset() toreactivate the timer using new time values, or TimerCancel() to delete thetimer.The notification message is a SMALL message containing as values theuserdata1 and userdata2 values specified in this call.AtTime messages are useful primarily for synchronizing with real-worldevents.  For a one-shot delay use TimerMsgDelay().  For a periodic seriesof messages, use TimerMsgHeartbeat().The TimerServices thread must be active before calling this function.ARGUMENTSmsgport                      The port to which the notification message                             is sent.seconds                      The seconds portion of the time.microseconds                 The microseconds portion of the time.  This                             value can be larger than 1 million.userdata1                    A value passed back to you in the                             msg_DataPtr field of the notification                             message.userdata2                    A value passed back to you in the                             msg_DataSize field of the notification                             message.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerMsgAfterDelay(), TimerMsgHeartbeat()¾KY TimerMsgAtTimeVBL ¾T Function¾DTimerHandle TimerMsgAtTimeVBL(Item msgport, uint32 fields, uint32 userdata1, uint32 userdata2)¾CThis function creates a timer that notifies you by message at thespecified VBL time.  The timer is a one-shot; after sending a notificationmessage the timer enters a suspended state.  Use TimerReset() toreactivate the timer using new time values, or TimerCancel() to delete thetimer.The notification message is a SMALL message containing as values theuserdata1 and userdata2 values specified in this call.The TimerServices thread must be active before calling this function.ARGUMENTSmsgport                      The port to which the notification message                             is sent.fields                       The VBL field count at which the event                             occurs.userdata1                    A value passed back to you in the                             msg_DataPtr field of the notification                             message.userdata2                    A value passed back to you in the                             msg_DataSize field of the notification                             message.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerMsgAfterDelayVBL(), TimerMsgHeartbeatVBL()¾KY TimerMsgHeartbeat ¾T Function¾DTimerHandle TimerMsgHeartbeat(Item msgport, uint32 seconds, uint32 microseconds, uint32 userdata1, uint32 userdata2)¾CThis function creates a timer that repeatedly notifies you by message atthe specified interval.  The timer continues sending notifications on aregular interval until you use TimerSuspend() to temporarily halt it orTimerCancel() to delete it.The Heartbeat support in the TimerServices thread contains logic toprevent drift in the frequency of timer events.  Messages are delivered atthe specified frequency even if it takes you significant time to respondto each message event.  If an entire frequency interval elapses and youstill haven't replied to the prior message you will miss one timer event,but the frequency of subsequent events is not disturbed.The TimerServices thread must be active before calling this function.ARGUMENTSmsgport                      The port to which the notification message                             is sent.seconds                      The seconds portion of the frequency.microseconds                 The microseconds portion of the frequency.                              This value can be larger than 1 million.userdata1                    A value passed back to you in the                             msg_DataPtr field of the notification                             message.userdata2                    A value passed back to you in the                             msg_DataSize field of the notification                             message.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerMsgAtTime(), TimerMsgAfterDelay(), HZ_TO_USEC()¾KY TimerMsgHeartbeatVBL ¾T Function¾DTimerHandle TimerMsgHeartbeatVBL(Item msgport, uint32 fields, uint32 userdata1, uint32 userdata2)¾CThis function creates a timer that repeatedly notifies you by messageafter the specified number of VBLs have occurred.  The timer continuessending notifications on a regular interval until you use TimerSuspend()to temporarily halt it or TimerCancel() to delete it.The Heartbeat support in the TimerServices thread contains logic toprevent drift in the frequency of timer events.  Signals are delivered atthe specified frequency even if it takes you significant time to respondto each signal event. The TimerServices thread must be active before calling this function.ARGUMENTSmsgport                      The port to which the notification message                             is sent.fields                       The number of VBLs to occur between each                              event.userdata1                    A value passed back to you in the                             msg_DataPtr field of the notification                             message.userdata2                    A value passed back to you in the                             msg_DataSize field of the notification                             message.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerMsgAtTimeVBL(), TimerMsgAfterDelayVBL()¾KY TimerSignalAfterDelay ¾T Function¾DTimerHandle TimerSignalAfterDelay(int32 signal, uint32 seconds, uint32 microseconds)¾CThis function creates a timer that notifies you by signal after thespecified delay.  The timer is a one-shot; after sending a notificationmessage the timer enters a suspended state.  Use TimerReset() toreactivate the timer using new time values, TimerRestart() to startanother delay period of the same length as last time, or TimerCancel() todelete the timer.The TimerServices thread must be active before calling this function.ARGUMENTSsignal                       The signal to send to your task.seconds                      The seconds portion of the delay.microseconds                 The microseconds portion of the delay.  This                             value can be larger than 1 million.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerSignalAtTime(), TimerSignalHeartbeat()¾KY TimerSignalAfterDelayVBL ¾T Function¾DTimerHandle TimerSignalAfterDelayVBL(int32 signal, uint32 fields)¾CThis function creates a timer that notifies you by signal after thespecified number of VBLs have occurred.  The timer is a one-shot; aftersending a notification message the timer enters a suspended state.  UseTimerReset() to reactivate the timer using new time values, TimerRestart()to start another delay period of the same length as last time, orTimerCancel() to delete the timer.The TimerServices thread must be active before calling this function.ARGUMENTSsignal                       The signal to send to your task.fields                       The number of VBLs to occur before sending                             the message.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerSignalAtTimeVBL(), TimerSignalHeartbeatVBL()¾KY TimerSignalAtTime ¾T Function¾DTimerHandle TimerSignalAtTime(int32 signal, uint32 seconds, uint32 microseconds)¾CThis function creates a timer that notifies you by signal at the specifiedtime.  The timer is a one-shot; after sending a notification message thetimer enters a suspended state.  Use TimerReset() to reactivate the timerusing new time values, or TimerCancel() to delete the timer.AtTime signals are useful primarily for synchronizing with real-worldevents.  For a one-shot delay use TimerSignalDelay().  For a periodicseries of signals, use TimerSignalHeartbeat().The TimerServices thread must be active before calling this function.ARGUMENTSsignal                       The signal to send to your task.seconds                      The seconds portion of the time.microseconds                 The microseconds portion of the time.  This                             value can be larger than 1 million.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerSignalAfterDelay(), TimerSignalHeartbeat()¾KY TimerSignalAtTimeVBL ¾T Function¾DTimerHandle TimerSignalAtTimeVBL(int32 signal, uint32 fields)¾CThis function creates a timer that notifies you by signal at the specifiedVBL time.  The timer is a one-shot; after sending a notification messagethe timer enters a suspended state.  Use TimerReset() to reactivate thetimer using new time values, or TimerCancel() to delete the timer.The TimerServices thread must be active before calling this function.ARGUMENTSsignal                       The signal to send to your task.fields                       The VBL field count at which the event                             occurs.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerSignalAfterDelayVBL(), TimerSignalHeartbeatVBL()¾KY TimerSignalHeartbeat ¾T Function¾DTimerHandle TimerSignalHeartbeat(int32 signal, uint32 seconds, uint32 microseconds)¾CThis function creates a timer that repeatedly notifies you by signal atthe specified intervals..  The timer continues sending notifications on aregular interval until you use TimerSuspend() to temporarily halt it orTimerCancel() to delete.The Heartbeat support in the TimerServices thread contains logic toprevent drift in the frequency of timer events.  Signals are delivered atthe specified frequency even if it takes you significant time to respondto each signal event. The TimerServices thread must be active before calling this function.ARGUMENTSsignal                       The signal to send to your task.seconds                      The seconds portion of the frequency.microseconds                 The microseconds portion of the frequency.                              This value can be larger than 1 million.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerSignalAtTime(), TimerSignalAfterDelay(), HZ_TO_USEC()¾KY TimerSignalHeartbeatVBL ¾T Function¾DTimerHandle TimerSignalHeartbeatVBL(int32 signal, uint32 fields)¾CThis function creates a timer that repeatedly notifies you by signal afterthe specified number of VBLs have occurred.  The timer continues sending notifications on a regular interval until you use TimerSuspend() totemporarily halt it or TimerCancel() to delete it.The Heartbeat support in the TimerServices thread contains logic toprevent drift in the frequency of timer events.  Signals are delivered atthe specified frequency even if it takes you significant time to respondto each signal event. The TimerServices thread must be active before calling this function.ARGUMENTSsignal                       The signal to send to your task.fields                       The number of VBLs to occur between each                              event.RETURN VALUEA TimerHandle (a positive value) on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     TimerUtils.h     ¾RTimerSignalAtTimeVBL(), TimerSignalAfterDelayVBL()¾KY UnloadAnim ¾T Function¾D void UnloadAnim (ANIM * animPtr)¾CUnloads an animation file previously loaded with LoadAnim(), and frees allresources acquired during the load process.ARGUMENTSanimPtr                      Pointer to an ANIM structure which was                              returned from the LoadAnim() function.RETURN VALUENothing¾F     Parse3DO.h     ¾RLoadAnim()¾KY UnloadCel ¾T Function¾Dvoid UnloadCel(CCB *cel)¾CThis function releases all resources acquired when a cel was loaded viaLoadCel().  A NULL pointer is valid as input, and is quietly treated as ano-op.   UnloadCel() just calls DeleteCel(); it differs only in that it doesn'treturn a NULL pointer.DeleteCel() and DeleteCelList() may also be used on files loaded via LoadCel(). ARGUMENTScel                          A pointer to a cel loaded via LoadCel().RETURN VALUENothing.IMPLEMENTATIONLib3DO function¾F     CelUtils.h     ¾RLoadCel(), DeleteCel()¾KY UnloadFile ¾T Function¾D void UnloadFile (void *buffer)¾CUnloads a file previously loaded with LoadFile(), and frees all resources acquired during the load process.ARGUMENTSbuffer                       Pointer to a file buffer which was returned                             from the LoadFile() function.RETURN VALUENothing¾F     BlockFile.h     ¾RLoadFile()¾KY UnloadFont ¾T Function¾Dvoid UnloadFont(FontDescriptor * fDesc)¾CReleases resources acquired during LoadFont() or ParseFont() processing.If the font was loaded via LoadFont(), releases the FontDescriptor and unloads the file image, releasing the memory it occupied. If you loadedthe font file image yourself and called ParseFont(),UnloadFont() releasesthe FontDescriptor. In that case, you must unload/release the font fileimage yourself.Because TextCel structures contain a reference to a FontDescriptor, youmust delete all TextCels that reference a FontDescriptor before you call UnloadFont()for that descriptor.ARGUMENTSFontDescriptor               Pointer to a FontDescriptor structure.RETURN VALUENothing.¾F     FontLib.h     ¾RLoadFont(), ParseFont()¾KY UnloadImage ¾T Function¾D void UnloadImage (void *imageBuffer)¾CUnloads an image file previously loaded with LoadImage(), and frees all resources acquired during the load process.Call this function only if you allowed LoadImage() to allocate thedestination buffer for you by passing a NULL buffer pointer to LoadImage(). If you allocated your own image buffer and passed it to LoadImage(), youmust free the buffer yourself. ARGUMENTSimageBuffer                  Pointer to a buffer which was allocated                              previously by the LoadImage() function.RETURN VALUENothing¾F     Parse3DO.h     ¾RLoadImage()¾KY UpdateTextInCel ¾T Function¾DErr UpdateTextInCel(TextCel *tCel, Boolean replaceExisting, char*fmtString, ...)¾CRenders text into a cel.  If the cel has a format buffer attached to it,the fmtString and related arguments pass first through sprintf() forformatting.  If replaceExisting is TRUE, the new text replaces any text already in thecel. The cel data buffer is zeroed, the pen position within the cel databuffer is set back to the top- and left-margin values, and the new text isrendered.If replaceExisting is FALSE, the new text is added to the text already inthe cel, using the cel\xd5 s current pen position.  This effectively addsnew characters to the end of the text already in the cel.If you created the cel with a width or height of zero (an autosize cel),its size is adjusted to fit the formatted text exactly, if thereplaceExisting flag is TRUE. If the replaceExisting flag is FALSE for anautosize cel, the net effect is that no characters are rendered.  Thishappens  because the cel was sized exactly right for the charactersrendered last time replaceExisting was TRUE. Attempting to add more characters to the cel always results in those characters falling outsidethe cel\xd5 s boundaries, where they will be clipped.The related vUpdateTextInCel() function works exactly the same, but takesa va_list type instead of the ... parameters.ARGUMENTStCel                         Pointer to a TextCel structure.replaceExisting              Flag indicating whether the new text is                             added to or replaces text already in the                             cel. fmtString                    The string of characters to be rendered,                              optionally including printf-style %                             formatting commands....                          Arguments for printf-style formatting.                               (Optional.) RETURN VALUEZero if all characters were rendered, positive if any characters wereclipped, negative if a bigger data buffer could not be allocated for anautosize cel. If the cel is not an autosize type, it can\xd5 t return anegative value.¾F     TextLib.h     ¾RvUpdateTextInCel()¾KY vGetTextExtent ¾T Function¾Dchar * vGetTextExtent(TextCel *tCel, int32 *pWidth, int32 *pHeight, char *fmtString, va_list fmtArgs)¾CIdentical to GetTextExtent() except that it takes a va_list rather than a variable argument list for printf-style formatting.¾KY vUpdateTextInCel ¾T Function¾DErr vUpdateTextInCel(TextCel *tCel, Boolean replaceExisting, char *fmtString, va_list fmtArgs)¾CIdentical to UpdateTextInCel() except that it takes a va_list rather thana variable argument list for printf-style formatting.¾KY WaitAsyncLoadFile ¾T Function¾DErr WaitAsyncLoadFile(LoadFileInfo *lf)¾CThis function waits for completion of an async file load started earlier. Do not call FinishAsyncLoadFile() after calling this function; thisfunction performs the Finish actions internally.ARGUMENTSlf                           A pointer to the LoadFileInfo structure for                             the load operation.RETURN VALUEReturns zero on success or a negative error code.IMPLEMENTATIONLib3DO function¾F     BlockFile.h     ¾RAsyncLoadFile()¾KY WriteMacFile ¾T Function¾D long WriteMacFile (char *filename, char *buf, long count)¾CWrites count bytes from the specified buffer into the file named byfilename, creating the MAC file, writing the specified number of bytes,and closing the Macintosh file. Returns the number of bytes written to theMacintosh file.  ARGUMENTSfilename                     pointer to char string specifying the name                             of the file to write on the Macintosh. buf                          pointer to the data bytes to write.count                         number of bytes to write.RETURN VALUEThe number of bytes written to the Macintosh file.¾F     Utils3DO.h     ¾KY XCORNERFROMSRECT ¾T Function¾Dint32 XCORNERFROMSRECT(SRect *rect)¾CThis macro evaluates to the X location for the corner opposite to thecorner described by rect->pos.This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in expression context.ARGUMENTSrect                         A pointer to an SRect.RETURN VALUEThe X location of the opposite corner.IMPLEMENTATIONMacro¾F     CelUtils.h     ¾RICornerFromSRect(), YCORNERFROMSRECT()¾KY XSIZEFROMCRECT ¾T Function¾DCCB * XSIZEFROMCRECT(CRect *rect)¾CThis macro evaluates to the size in the X dimension of the area describedby rect.  This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in expression context.ARGUMENTSrect                         A pointer to a CRect.RETURN VALUEThe size of the area in the X dimension.IMPLEMENTATIONMacro¾F     CelUtils.h     ¾RISizeFromCRect(), YSIZEFROMCRECT()¾KY YCORNERFROMSRECT ¾T Function¾DCCB * YCORNERFROMSRECT(SRect *rect)¾CThis macro evaluates to the Y location for the corner opposite to thecorner described by rect->pos.  This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in expression context.ARGUMENTSrect                         A pointer to an SRect.RETURN VALUEThe Y location of the opposite corner.IMPLEMENTATIONMacro¾F     CelUtils.h     ¾RICornerFromSRect(), XCORNERFROMSRECT()¾KY YSIZEFROMCRECT ¾T Function¾DCCB * YSIZEFROMCRECT(CRect *rect)¾CThis macro evaluates to the size in the Y dimension of the area describedby rect.  This macro evaluates its argument more than once; be careful of sideeffects.  It is usable in expression context.ARGUMENTSrect                         A pointer to an SRect.RETURN VALUEThe size of the area in the Y dimension.IMPLEMENTATIONMacro¾F     CelUtils.h     ¾RISizeFromCRect(), XSIZEFROMCRECT()¾KY FPoint ¾T Function¾Dtypedef struct FPoint {frac16 x;frac16 y;} FPoint;¾CThis structure bundles together a pair of related X/Y values in frac16format.  It is most often used to express screen locations.  It can alsobe used to describe the width and height of something, for example, as insize.x and size.y.FIELDSx                            X value.y                            Y value.¾F     CelUtils.h     ¾RIPoint¾KY IPoint ¾T Function¾Dtypedef struct IPoint {int32 x;int32 y;} IPoint;¾CThis structure bundles together a pair of related X/Y values in int32format.  It is most often used to express screen locations.  It can alsobe used to describe the width and height of something, for example, as inthe size.x and size.y fields found in the SRect structure.FIELDSx                            The X value.y                            The Y value.¾F     CelUtils.h     ¾RFPoint, SRect, CRect, CQuad¾KY CRect ¾T Function¾Dtypedef struct CRect {IPoint tl;IPoint br;} CRect;¾CThis structure describes a rectangular area by specifying the X/Ycoordinates of opposing corners.  By convention the top left and bottomright corners are specified, but this does not limit the values that canbe stored in the fields.  For example, using MapCelToCRect() where thebr.x and br.y fields specify a point that is above and to the left of thetl.x and tl.y location results in a cel that projects as a mirror image inboth dimensions.  Negative values are allowed in any of the fields.FIELDStl                           The X/Y location of the top left corner of                             the area.br                           The X/Y location of the bottom right corner                             of the area.¾F     CelUtils.h     ¾RIPoint, SRect, CQuad¾KY SRect ¾T Function¾Dtypedef struct SRect {IPoint pos;IPoint size;} SRect;¾CThis structure describes a rectangular area by specifying the X/Ycoordinates of the top left corner and the X/Y sizes of the area. Negative values are allowed in any of the fields.  For example, usingMapCelToSRect() where the size.x and size.y fields are negative results ina cel that projects as a mirror image in both dimensions.FIELDSpos                          The X/Y location of the top left corner of                             the area.size                         The X/Y sizes of the area.¾F     CelUtils.h     ¾RIPoint, CRect, CQuad¾KY CQuad ¾T Function¾Dtypedef struct CQuad {IPoint tl;IPoint tr;IPoint br;IPoint bl;} CQuad;¾CThis structure describes an arbitrary quadrangle by specifying the X/Y coordinates of all four corners.  Negative values are allowed in any ofthe fields.  You can use this structure with the MapCel() and FastMapCel() functions byusing a (Point *) typecast in the function call.FIELDStl                           The X/Y location of the top left corner of                             the area.tr                           The X/Y location of the top right corner of                             the area.br                           The X/Y location of the bottom right corner                             of the area.bl                           The X/Y location of the bottom left corner                             of the area.¾F     CelUtils.h     ¾RIPoint, SRect, CRect¾KY BlockFile ¾T Function¾Dtypedef struct BlockFile {Item fDevice;FileStatus fStatus;} BlockFile;¾CThis structure holds information about a file opened by theOpenBlockFile() function.FIELDSfDevice                      Filesystem folio item number for the open                             file.fStatus                      Information provided by the filesystem folio                             describing the file and device                             characteristics.¾F     BlockFile.h, filesystem.h     ¾ROpenBlockFile()¾KY FontDescriptor ¾T Function¾Dtypedef struct FontDescriptor {uint32fd_fontFlags;uint32fd_charHeight;uint32fd_charWidth;uint32fd_bitsPerPixel;uint32fd_firstChar;uint32fd_lastChar;uint32fd_charExtra;uint32fd_acsent;uint32fd_descent;uint32fd_leading;uint32fd_reserved[4];void *fd_userDatavoid *fd_fontHeader;void *fd_charInfo;void *fd_charData;} FontDescriptor;¾CThe FontDescriptor structure contains values that describe the font, andvalues used by the font library routines to render characters.  Nevermodify the values in any of the fields of this structure other thanfd_userData.  The count and content of fields documented for internal useonly are subject to change in future releases.FIELDSfd_fontFlags                 Bitmapped flags describing the                             characteristics of the font.fd_charHeight                Height, in pixels,  of characters in the                             font, not including leading.  Equal to                             ascent + descent.fd_charWidth                 Maximum width,  in pixels, of characters  in                             the font.  There may be no characters in the                             font that are actually as wide as this                             value.  The creator of the font supplies                             this value.  It limits the view and painting                             area in the FontWriter program, but does not                             imply that any characters use the full area.fd_bitsPerPixel              Number of bits per pixel used to store the                             font data in the file.  Values currently                             supported are 3  bpp for single-color fonts,                             and 5  bpp for two-color shadowed/outlined                             fonts.f                            d_firstChar  ASCII value of the first                             character present in the font file.fd_lastChar                  ASCII value of the last character present in                             the font file.fd_charExtra                 Amount of extra spacing, in pixels, to place                             between characters when rendering.fd_ascent                    Distance, in pixels,  from the baseline to                             the top of uppercase characters.fd_descent                   Distance, in pixels, from the baseline to                             the bottom of lowercase descenders.fd_leading                   Amount of extra spacing, in pixels, to place                             between lines of text when rendering.fd_reserved                  Four words reserved for future use.                              Currently always set to zero.fd_userData                  You may strore any value into this field, it                             is not touched internally. fd_fontHeader                For internal use only.fd_charInfo                  For internal use only.fd_charData                  For internal use only.FLAGSFFLAG_MONOSPACED             Monospaced font.FFLAG_ITALIC                 Italic font.FFLAG_BOLD                   Boldface font.FFLAG_OUTLINED               Outlined font.FFLAG_SHADOWED               Shadowed font.FFLAG_UNDERLINED             Underlined font.FFLAG_TWOCOLOR               Font contains two-color characters. ¾F     Fontlib.h     ¾KY LoadFileInfo ¾T Function¾Dtypedef struct LoadFileInfo {void *userData;void *buffer;uint32 bufSize;uint32 memTypeBits;Item ioDonePort;uint32 reserved1[2];BlockFile bf;Item internalIOReq;IOReq *internalIORPtr;uint32 internalFlags;uint32 reserved2[2];BlockFile} LoadFileInfo;¾CThis structure is the interface between your code and the AsyncLoadFile()family of functions.  You fill in some of the fields and callAsyncLoadFile() and it acts on the fields you specified and fills in theother fields for you, as described below.  The userData through reserved1fields are set by you before calling AsyncLoadFile(), the remaining fieldsare set by AsyncLoadFile().FIELDSuserData                     This field is for your use; library                             internals don't touch it.  Useful as a                             backlink or context pointer when using I/O                             completion notification messages.buffer                       Pointer to the file buffer.  If NULL,                              AsyncLoadFile() allocates a buffer for you                             and stores a pointer to it here.  If                             non-NULL the file is loaded into the buffer                             this points to.bufSize                      Size of the file buffer.  If the buffer                             pointer is non-NULL, AsyncLoadFile() uses                             this value to verify that the file will fit                             into the buffer.  If the buffer pointer is                             NULL, the size of the internally-allocated                             buffer is stored here for you.memTypeBits                  The memTypeBits parameter passed to Malloc()                             when a buffer is allocated for you                             internally.  Not used when you have                             allocated your own buffer.ioDonePort                   Item number of a message port to receive a                              message when the I/O completes.  May be zero                             if you don't want notification of completion                             via message.reserved1                    Reserved for future expansion; set this to                             zero.bf                           A BlockFile structure which is filled in by                              AsyncLoadFile().  The values in this fields                             are available to you (read-only) upon return                             from AsyncLoadFile().  The actual size of                             the file (which may be slightly less than                             the buffer size) can be obtained from here.internalIOReq                Used internally; don't touch.internalIORPtr               Used internally; don't touch.internalFlags                Used internally; don't touch.reserved2                    Reserved for future expansion; don't touch.¾F     BlockFile.h, filesystem.h     ¾RBlockFile, AsyncLoadFile()¾KY TextCel ¾T Function¾Dtypedef struct TextCel {CCB *tc_CCB;void *tc_userData;/* private fields appear here */} TextCel;¾CThe TextCel structure contains values used by the text library routines tomanage a text cel.  The only fields you can reference are tc_CCB andtc_userData.  The number, meaning, location, and contents of all otherfields in the structure are for internal use only, and are subject tochange.FIELDStc_CCB                       Pointer to the CCB for the text cel.tc_userData                  You may store any value in this filed; it is                             not touched internally. Format FlagsTC_FORMAT_LEFT_JUSTIFY       left-justify text      TC_FORMAT_RIGHT_JUSTIFY      right -justify textTC_FORMAT_CENTER_JUSTIFY     center-justify textTC_FORMAT_WORDWRAP           auto-word-wrap textARGUMENTSTCEL_TAG_FONT                Pointer to the FontDescriptor to use when                              rendering text .TCEL_TAG_FORMAT_FLAGS        Formatting flags for rendering text.                              Default is TC_FORMAT_LEFT_JUSTIFY.TCEL_TAG_WIDTH               Width of the text cel.  Default is zero.TCEL_TAG_HEIGHT              Height of the text cel.  Default is zero.TCEL_TAG_SPACING_ADJUST      Adjustment to intercharacter spacing.                              Default is zero.TCEL_TAG_LEADING_ADJUST      Adjustment to interline leading.  Default is                             zero.TCEL_TAG_BG_COLOR            Background color.  Default is zero                             (transparent).TCEL_TAG_FG_COLOR0           Pen number 0 color.  Default is white                             (31,31,31).TCEL_TAG_FG_COLOR1           Pen number 1 color.  Default is zero                             (transparent) for single-color fonts, black                             (0,0,1) for two-color shadowed/outlined                             fonts.TCEL_TAG_FG_COLOR2           Pen number 2 color.  Default is zero                              (transparent).TCEL_TAG_FG_COLOR3           Pen number 3 color.  Default is zero                              (transparent).TCEL_TAG_FG_COLORS           Pointer to an array of four int32 values,                              corresponding to the pen number colors 0                              through 3.  Any element of the array can be                             -1L to leave the corresponding color                             unchanged.TCEL_TAG_CCB_X                CCB x coordinate.  Interpreted as an                             integer and internally converted to frac16                             if the longword value is in the range -1024<                             value<1024.  Otherwise assumed to be a                             frac16 value already.  Default is zero.  TCEL_TAG_CCB_Y               CCB y coordinate.  Interpretation as for                             CCB_X. Default is zero.  TCEL_TAG_LEFT_MARGIN         Left margin value.  Default is zero.TCEL_TAG_TOP_MARGIN          Top margin value.  Default is zero.TCEL_TAG_PEN_NUMBER          Pen number for  rendering pixels for                             single-color fonts.  Not valid for two-color                             fonts.  Default is zero.TCEL_TAG_FORMAT_BUFFER       Pointer to a text formatting buffer, or NULL                             to remove an existing buffer.  See                              SetTextCelFormatBuffer() for more details.                               Default is no buffer.  TCEL_TAG_FORMAT_BUFFER_SIZE Size of the text formatting buffer.  See SetTextCelFormatBuffer() for more details.TCEL_TAG_TAB_STOPS            A pointer to an array of tab stops.  See                              SetTextCelTabStops() for more details.                               Default is no tab stops.  TCEL_TAG_REPLACE_EXISTINGIf non-zero, it clears text already in the cel before rendering new text.  Meaningful only in                              conjunction with                              TCEL_TAG_UPDATE_TEXT_STRING. Default is                             TRUE.TCEL_TAG_UPDATE_TEXT_STRINGPointer to a text string to be rendered into the cel.  If the string contains printf-style                             formatting, you must also specify                              TCEL_TAG_UPDATE_TEXT_ARGS.Default is no text                             to be rendered.TCEL_TAG_UPDATE_TEXT_ARGSA va_list that points to the substitution arguments for printf-style formatting.                              Default is NULL.