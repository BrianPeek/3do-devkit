<HTML><HEAD><TITLE>Map and Multimap Operations</TITLE></HEAD>
<BODY>
<A HREF="ug.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the user guide home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>Map and Multimap Operations</H2>
<P>The member functions provided by the map and multimap data types will shortly be described in more detail.  Note that while member functions provide basic operations, the utility of the data structure is greatly extended through the use of the generic algorithms described in Chapters <a href="gen_9895.htm">13</a> and <a href="ord_1635.htm">14</a>.</P>
<A NAME="declarationandinitializationofmap"><H3>Declaration and Initialization of map</H3></A>
<P>The declaration of a map follows the pattern we have seen repeatedly in the standard library.  A map is a template data structure, specialized by the type of the key elements, the type of the associated values, and the operator to be used in comparing keys. If your compiler supports default template types (a relatively new feature in C++ not yet supported by all vendors), then the last of these is optional, and if not provided, the less than operator for the key type will be assumed.  Maps can be declared with no initial elements, or initialized from another container by providing a pair of iterators.  In the latter case the iterators must denote values of type <A HREF="../stdref/pai_5818.htm"><B><I>pair</I></B></A>; the first field in each pair is taken to be a key, while the second field is a value.  A copy constructor also permits maps to be created as copies of other maps.</P>
<PRE>   // map indexed by doubles containing strings
   map&#60;double, string, less&#60;double> > map_one;
   // map indexed by integers, containing integers   
   map&#60;int, int> map_two(aContainer.begin(), aContainer.end());
   // create a new map, initializing it from map two
   map&#60;int, int> map_three (map_two);   // copy constructor
</PRE>
<P>A map can be assigned to another map, and two maps can exchange their values using the <SAMP>swap()</SAMP> operation (in a manner analogous to other standard library containers).</P>

<A NAME="typedefinitions"><H3>Type Definitions</H3></A>
<P>The classes <A HREF="../stdref/map_8018.htm"><B><I>map</I></B></A> and <A HREF="../stdref/mul_8396.htm"><B><I>multimap</I></B></A> include a number of type definitions.  These are most commonly used in declaration statements.  For example, an iterator for a map of strings to integers can be declared in the following fashion:</P>
<PRE>map&#60;string, int>::iterator location;
</PRE>
<P>In addition to <SAMP>iterator</SAMP>, the following types are defined:</P>

<CENTER><TABLE CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD>
<SAMP>key_type</SAMP><BR>
</TD>

<TD>
The type associated with the keys used to index the map.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>value_type</SAMP><BR>
</TD>

<TD>
The type held by the container, a key/value pair.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>const_iterator</SAMP><BR>
</TD>

<TD>
An iterator that does not allow modification of the underlying sequence.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>reverse_iterator</SAMP><BR>
</TD>

<TD>
An iterator that moves in a backward direction.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>const_reverse_iterator</SAMP><BR>
</TD>

<TD>
A combination constant and reverse iterator.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>reference</SAMP><BR>
</TD>

<TD>
A reference to an underlying value.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>const_reference</SAMP><BR>
</TD>

<TD>
A reference to an underlying value that will not permit the element to be modified.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>size_type</SAMP><BR>
</TD>

<TD>
An unsigned integer type, used to refer to the size of containers.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>key_compare</SAMP><BR>
</TD>

<TD>
A function object that can be used to compare two keys.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>value_compare</SAMP><BR>
</TD>

<TD>
A function object that can be used to compare two elements.<BR>
</TD>
</TR>

<TR VALIGN=top>
<TD>
<SAMP>difference_type</SAMP><BR>
</TD>

<TD>
A signed integer type, used to describe the distances between iterators.<BR>
</TD>
</TR>
</TABLE></CENTER>
<A NAME="insertionandaccess"><H3>Insertion and Access</H3></A>
<P>Values can be inserted into a map or a multimap using the <SAMP>insert()</SAMP> operation.  Note that the argument must be a key-value pair.  This pair is often constructed using the data type <SAMP>value_type</SAMP> associated with the map.</P>
<PRE>   map_three.insert (map&#60;int>::value_type(5, 7));
</PRE>
<P>Insertions can also be performed using an iterator pair, for example as generated by another map.</P>
<PRE>   map_two.insert (map_three.begin(), map_three.end());
</PRE>
<P>With a map (but not a multimap), values can be accessed and inserted using the subscript operator.  Simply using a key as a subscript creates an entry - the default element is used as the associated value.  Assigning to the result of the subscript changes the associated binding.</P>
<PRE>   cout &#60;&#60; "Index value 7 is " &#60;&#60; map_three[7] &#60;&#60; endl;
      // now change the associated value
   map_three[7] = 5;
   cout &#60;&#60; "Index value 7 is " &#60;&#60; map_three[7] &#60;&#60; endl;
</PRE>

<A NAME="removalofvalues"><H3>Removal of Values</H3></A>
<P>Values can be removed from a map or a multimap by naming the key value.  In a multimap the erasure removes all elements with the associated key.  An element to be removed can also be denoted by an iterator; as, for example, the iterator yielded by a <SAMP>find()</SAMP> operation.  A pair of iterators can be used to erase an entire range of elements.</P>
<PRE>   // erase the 4th element 4
   map_three.erase(4);
   // erase the 5th element 
   mtesttype::iterator five = map_three.find(5);
   map_three.erase(five);
   
   // erase all values between the 7th and 11th elements
   mtesttype::iterator seven = map_three.find(7);
   mtesttype::iterator eleven = map_three.find(11);
   map_three.erase (seven, eleven);
   </PRE>
<P>If the underlying element type provides a destructor, then the destructor will be invoked prior to removing the key and value pair from the collection.</P>

<A NAME="iterators"><H3>Iterators</H3></A>
<A HREF="sidebar.htm#sidebar31"><IMG SRC="images/note.gif" BORDER=0> <STRONG>No Iterator Invalidation</STRONG></A>

<P>The member functions <SAMP>begin()</SAMP> and <SAMP>end()</SAMP> produce bidirectional iterators for both maps and multimaps.  Dereferencing an iterator for either a map or a multimap will yield a <A HREF="../stdref/pai_5818.htm"><B><I>pair</I></B></A> of key/value elements.  The field names <SAMP>first</SAMP> and <SAMP>second</SAMP> can be applied to these values to access the individual fields.   The first field is constant, and cannot be modified.  The second field, however, can be used to change the value being held in association with a given key.  Elements will be generated in sequence, based on the ordering of the key fields.</P>
<P>The member functions <SAMP>rbegin()</SAMP> and <SAMP>rend()</SAMP> produce iterators that yield the elements in reverse order.</P>
<A NAME="searchingandcounting"><H3>Searching and Counting</H3></A>
<P>The member function <SAMP>size()</SAMP> will yield the number of elements held by a container.  The member function <SAMP>empty()</SAMP> will return a boolean true value if the container is empty, and is generally faster than testing the size against zero.</P>
<P>The member function <SAMP>find()</SAMP> takes a key argument, and returns an iterator denoting the associated key/value pair.  In the case of multimaps, the first such value is returned.  In both cases the past-the-end iterator is returned if no such value is found.</P>
<PRE>   if (map_one.find(4) != map_one.end())
      cout &#60;&#60; "contains a 4th element" &#60;&#60; endl;
</PRE>
<P>The member function<SAMP> lower_bound()</SAMP> yields the first entry that matches the argument key, while the member function <SAMP>upper_bound()</SAMP> returns the first value past the last entry matching the argument.  Finally, the member function <SAMP>equal_range()</SAMP> returns a <A HREF="../stdref/pai_5818.htm"><B><I>pair</I></B></A> of iterators, holding the lower and upper bounds. An example showing the use of these procedures will be presented later in this section. </P>
<P>The member function <SAMP>count()</SAMP> returns the number of elements that match the key value supplied as the argument.  For a map, this value is always either zero or one, whereas for a multimap it can be any nonnegative value.  If you simply want to determine whether or not a collection contains an element indexed by a given key, using <SAMP>count()</SAMP> is often easier than using the <SAMP>find()</SAMP> function and testing the result against the end-of-sequence iterator.</P>
<PRE>   if (map_one.count(4))
      cout &#60;&#60; "contains a 4th element" &#60;&#60; endl;
</PRE>

<A NAME="elementcomparisons"><H3>Element Comparisons</H3></A>
<P>The member functions <SAMP>key_comp()</SAMP> and <SAMP>value_comp(),</SAMP> which take no arguments, return function objects that can be used to compare elements of the key or value types.  Values used in these comparisons need not be contained in the collection, and neither function will have any effect on the container.</P>
<PRE>if (map_two.key_comp (i, j)) 
   cout &#60;&#60; "element i is less than j" &#60;&#60; endl;
</PRE>

<A NAME="othermapoperations"><H3>Other Map Operations</H3></A>
<P>Because maps and multimaps are ordered collections, and because the iterators for maps return pairs, many of the functions described in Sections <a href="gen_9895.htm">13</a> and <a href="ord_1635.htm">14</a> are meaningless or difficult to use.  However, there are a few notable exceptions.  The functions <SAMP>for_each()</SAMP>, <SAMP>adjacent_find()</SAMP>, and <SAMP>accumulate()</SAMP> each have their own uses.  In all cases it is important to remember that the functions supplied as arguments should take a key/value pair as arguments.</P>
<HR>
<A HREF="map_9326.htm"><IMG SRC="images/prev.gif"></A> <A HREF="booktoc.htm"><IMG SRC="images/toc.gif"></A> <A HREF="exa_7078.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
