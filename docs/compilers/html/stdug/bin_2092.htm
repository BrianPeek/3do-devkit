<HTML><HEAD><TITLE>Binary Search</TITLE></HEAD>
<BODY>
<A HREF="ug.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the user guide home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>Binary Search</H2>
<P>The standard library provides a number of different variations on binary search algorithms.   All will perform only approximately <SAMP>log n</SAMP> comparisons, where <SAMP>n</SAMP> is the number of elements in the range described by the arguments.  The algorithms work best with random access iterators, such as those generated by vectors or deques, when they will also perform approximately <SAMP>log n</SAMP> operations in total.  However, they will also work with non-random access iterators, such as those generated by lists, in which case they will perform a linear number of steps.  Although legal, it is not necessary to perform a binary search on a <A HREF="../stdref/set_1649.htm"><B><I>set</I></B></A> or <A HREF="../stdref/mul_0958.htm"><B><I>multiset</I></B></A> data structure, since those container classes provide their own search methods, which are more efficient.</P>
<P>The generic algorithm <SAMP>binary_search()</SAMP> returns<SAMP> true</SAMP> if the sequence contains a value that is equivalent to the argument.  Recall that to be equivalent means that both <SAMP>Compare(value, arg)</SAMP> and <SAMP>Compare(arg, value)</SAMP> are false.  The algorithm is declared as follows:</P>
<PRE>bool binary_search (ForwardIterator first, ForwardIterator last, 
      const T &#38; value [, Compare ] );
</PRE>
<P>In other situations it is important to know the position of the matching value.  This information is returned by a collection of algorithms, defined as follows:</P>
<PRE>   ForwardIterator lower_bound (ForwardIterator first, 
      ForwardIterator last, const T&#38; value [ , Compare ] );

   ForwardIterator upper_bound (ForwardIterator first, 
      ForwardIterator last, const T&#38; value [, Compare ] );

   pair&#60;ForwardIterator, ForwardIterator> equal_range
      (ForwardIterator first, ForwardIterator last,
         const T&#38; value [, Compare ] );
</PRE>
<P>The algorithm <SAMP>lower_bound()</SAMP> returns, as an iterator, the first position into which the argument could be inserted without violating the ordering, whereas the algorithm <SAMP>upper_bound()</SAMP> finds the last such position.  These will match only when the element is not currently found in the sequence. Both can be executed together in the algorithm <SAMP>equal_range(),</SAMP> which returns a pair of iterators.</P>
<P>Our example program shows these functions being used with a vector of random integers.</P>
<PRE>void binary_search_example ()
   // illustrate the use of the binary search algorithm
{
      // make an ordered vector of 15 random integers
   vector&#60;int> aVec(15);
   generate (aVec.begin(), aVec.end(), randomValue);
   sort (aVec.begin(), aVec.end());

      // see if it contains an eleven
   if (binary_search (aVec.begin(), aVec.end(), 11))
      cout &#60;&#60; "contains an 11" &#60;&#60; endl;
   else
      cout &#60;&#60; "does not contain an 11" &#60;&#60; endl;

      // insert an 11 and a 14
   vector&#60;int>::iterator where;
   where = lower_bound (aVec.begin(), aVec.end(), 11);
   aVec.insert (where, 11);

   where = upper_bound (aVec.begin(), aVec.end(), 14);
   aVec.insert (where, 14);

}
</PRE>

<HR>
<A HREF="nth_1433.htm"><IMG SRC="images/prev.gif"></A> <A HREF="booktoc.htm"><IMG SRC="images/toc.gif"></A> <A HREF="mer_3553.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
