<HTML><TITLE>find_first_of</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>find_first_of</H2>
<HR><PRE>     Algorithm</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>Finds the first occurrence of any value from one sequence in another sequence.</P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Complexity"><LI>Complexity</LI></A>
<A HREF="#Example"><LI>Example</LI></A>
<A HREF="#Warnings"><LI>Warnings</LI></A>
<A HREF="#See Also"><LI>See Also</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;algorithm></PRE>
<PRE>
template &#60;class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 <B>find_first_of </B>(ForwardIterator1 first1,
                                ForwardIterator1 last1,
                                ForwardIterator2 first2,
                                ForwardIterator2 last2);
template &#60;class ForwardIterator1, class ForwardIterator2,
          class BinaryPredicate>
ForwardIterator1 <B>find_first_of</B> (ForwardIterator1 first1,
                                ForwardIterator1 last1,
                                ForwardIterator2 first2,
                                ForwardIterator2 last2,
                                BinaryPredicate pred);
</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P>The <B><I>find_first_of</B></I> algorithm finds a the first occurrence of a value from a  sequence, specified by <SAMP>first2, last2</SAMP>, in a sequence specified by <SAMP>first1, last1</SAMP>. The algorithm returns an iterator in the range <SAMP>[first1, last1) </SAMP>that points to the first matching element<SAMP>.</SAMP>  If the first sequence <SAMP>[first1, last1)</SAMP> does not contain any of the values in the second sequence, <B><I>find_first_of</B></I> returns <SAMP>last1</SAMP>.  </P>
<P>In other words, <B><I>find_first_of</B></I>  returns the first iterator <SAMP>i</SAMP> in the <SAMP>[first1, last1)</SAMP>such that for some integer <SAMP>j</SAMP> in  the  range  <SAMP>[first2, last2)</SAMP>:the following conditions hold: </P>
<PRE>*i == *j, pred(*i,*j) == true.  </PRE>
<PRE></PRE><P>Or <B><I>find_first_of</B></I>  returns <SAMP>last1</SAMP> if no such iterator is found.</P>
<P>Two versions of the algorithm exist.  The first uses the equality operator as the default binary predicate, and the second allows you to specify a binary predicate.</P>
<PRE></PRE>
<A NAME="Complexity"><H3>Complexity</H3></A>
<P>At most <SAMP>(last1 - first1)*(last2 - first2)</SAMP> applications of the corresponding predicate are done.</P>
<A NAME="Example"><H3>Example</H3></A>
<PRE>//
// find_f_o.cpp
//
 #include &#60;vector>
 #include &#60;iterator>
 #include &#60;algorithm>
 #include &#60;iostream.h>
 int main()
 {
   typedef vector&#60;int>::iterator iterator;
   int d1[10] = {0,1,2,2,3,4,2,2,6,7};
   int d2[2] = {6,4};
   //
   // Set up two vectors
   //
   vector&#60;int> v1(d1,d1 + 10), v2(d2,d2 + 2);
   //
   // Try both find_first_of variants 
   //
   iterator it1 =   
     <B>find_first_of</B>(v1.begin(),v1.end(),v2.begin(),v2.end()); 
   <B>find_first_of</B>(v1.begin(),v1.end(),v2.begin(),v2.end(),
                 equal_to&#60;int>());
   //
   // Output results
   //
   cout &#60;&#60; "For the vectors: ";
   copy(v1.begin(),v1.end(),
        ostream_iterator&#60;int>(cout," " ));
   cout &#60;&#60; " and ";
   copy(v2.begin(),v2.end(),
        ostream_iterator&#60;int>(cout," " ));
   cout &#60;&#60; endl &#60;&#60; endl
       &#60;&#60; "both versions of find_first_of point to: "
       &#60;&#60; *it1;
   
   return 0;
 }
Output :
For the vectors: 0 1 2 2 3 4 2 2 6 7  and 6 4
both versions of find_first_of point to: 4
</PRE>
<A NAME="Warnings"><H3>Warnings</H3></A>
<P>If your compiler does not support default template parameters then you need to always supply the <SAMP>Allocator</SAMP> template argument.  For instance you'll have to write:</P>
<PRE>vector&#60;int, allocator></PRE>
<PRE></PRE><P>instead of:</P>
<PRE>vector&#60;int></PRE>
<A NAME="See Also"><H3>See Also</H3></A>
<P><A HREF="Alg_5157.htm"><B><I>Algorithms</B></I></A>, <A HREF="adj_8817.htm"><B><I>adjacent_find</B></I></A>, <A HREF="fin_7988.htm"><B><I>find</B></I></A>, <A HREF="fin_2105.htm"><B><I>find_if</B></I></A>, <B><I>find_next</B></I>, <A HREF="fin_7707.htm"><B><I>find_end</B></I></A></P>
<HR>
<A HREF="fin_7707.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="fin_2105.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
