<HTML><TITLE>find</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>find</H2>
<HR><PRE>     Algorithm</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>Find an occurence of value in a sequence</P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Complexity"><LI>Complexity</LI></A>
<A HREF="#Example"><LI>Example</LI></A>
<A HREF="#Warning"><LI>Warning</LI></A>
<A HREF="#See Also"><LI>See Also</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;algorithm></PRE>
<PRE>
template &#60;class InputIterator, class T>
  InputIterator <B>find</B>(InputIterator first, InputIterator last,
                     const T&#38; value);
</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P>The <B><I>find</B></I> algorithm lets you search for the first occurence of a particular value in a sequence.  <B><I>find </B></I>returns the first iterator <SAMP>i</SAMP> in the range <SAMP>[first, last)</SAMP> for which the following condition holds: </P>
<PRE>*i == value.  </PRE>
<PRE></PRE><P>If <B><I>find</B></I> does not find a match for <SAMP>value</SAMP>, it returns the iterator <SAMP>last</SAMP>.</P>
<A NAME="Complexity"><H3>Complexity</H3></A>
<P><B><I>find</B></I> peforms at most <SAMP>last-first</SAMP> comparisons.</P>
<A NAME="Example"><H3>Example</H3></A>
<PRE>//
// find.cpp
//
 #include &#60;vector>
 #include &#60;algorithm>
 int main()
 {
   typedef vector&#60;int>::iterator iterator;
   int d1[10] = {0,1,2,2,3,4,2,2,6,7}; 
   // Set up a vector
   vector&#60;int> v1(d1,d1 + 10);
  <B> </B>// Try find<B>  </B>
<B>   </B>iterator it1 = <B>find</B>(v1.begin(),v1.end(),3);
   // it1 = v1.begin() + 4;
   // Try find_if
   iterator it2 = 
      find_if(v1.begin(),v1.end(),bind1st(equal_to&#60;int>(),3));
   // it2 = v1.begin() + 4
   // Try both adjacent_find variants
   iterator it3 = adjacent_find(v1.begin(),v1.end());
   // it3 = v1.begin() +2
   iterator it4 = 
      adjacent_find(v1.begin(),v1.end(),equal_to&#60;int>());
   // v4 = v1.begin() + 2
   // Output results
   cout &#60;&#60; *it1 &#60;&#60; " " &#60;&#60; *it2 &#60;&#60; " " &#60;&#60; *it3 &#60;&#60; " " 
        &#60;&#60; *it4 &#60;&#60; endl;
   return 0;
 }
Output : 3 3 2 2
</PRE>
<A NAME="Warning"><H3>Warning</H3></A>
<P>If your compiler does not support default template parameters then you need to always supply the <SAMP>Allocator</SAMP> template argument.  For instance you'll have to write:</P>
<PRE>vector&#60;int,allocator></PRE>
<PRE></PRE><P>instead of:</P>
<PRE>vector&#60;int></PRE>
<A NAME="See Also"><H3>See Also</H3></A>
<P><A HREF="adj_8817.htm"><B><I>adjacent_find</B></I></A>, <A HREF="fin_8583.htm"><B><I>find_first_of</B></I></A>, <A HREF="fin_2105.htm"><B><I>find_if</B></I></A></P>
<HR>
<A HREF="fil_4628.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="fin_7707.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
