<HTML><TITLE>deque </TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>deque </H2>
<HR><PRE>     Container</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A sequence that supports random access iterators and efficient insertion/deletion at both beginning and end.</P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Interface"><LI>Interface</LI></A>
<A HREF="#Constructors and Destructor"><LI>Constructors and Destructor</LI></A>
<A HREF="#Allocator"><LI>Allocator</LI></A>
<A HREF="#Iterators"><LI>Iterators</LI></A>
<A HREF="#Assignment Operator"><LI>Assignment Operator</LI></A>
<A HREF="#Reference Operators"><LI>Reference Operators</LI></A>
<A HREF="#Member Functions"><LI>Member Functions</LI></A>
<A HREF="#Non-member Functions"><LI>Non-member Functions</LI></A>
<A HREF="#Example"><LI>Example</LI></A>
<A HREF="#Warnings"><LI>Warnings</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;deque></PRE>
<PRE>
template &#60;class T, class Allocator = allocator>
 class deque;</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P><B><I>deque&#60;T, Allocator></B></I> is a type of sequence that supports random access iterators.  It supports constant time insert and erase operations at the beginning or the end of the container. Insertion and erase in the middle take linear time.  Storage management is handled by the <SAMP>Allocator</SAMP> template parameter. </P>
<P>Any type used for the template parameter <SAMP>T</SAMP> must provide the following (where <SAMP>T</SAMP> is the <SAMP>type</SAMP>, <SAMP>t</SAMP> is a <SAMP>value</SAMP> of <SAMP>T</SAMP> and<SAMP> u</SAMP> is a <SAMP>const</SAMP> <SAMP>value</SAMP> of <SAMP>T</SAMP>): </P>
<CENTER><TABLE CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD>Default constructor</TD>
<TD><SAMP>T()</SAMP></TD></TR>
<TR VALIGN=top>
<TD>Copy constructors </TD>
<TD><SAMP>T(t)</SAMP> and <SAMP>T(u)</SAMP></TD></TR>
<TR VALIGN=top>
<TD>Destructor</TD>
<TD><SAMP>t.~T()</SAMP></TD></TR>
<TR VALIGN=top>
<TD>Address of</TD>
<TD><SAMP>&#38;t</SAMP> and <SAMP>&#38;u</SAMP> yielding <SAMP>T*</SAMP> and <SAMP>const T*</SAMP> respectively</TD></TR>
<TR VALIGN=top>
<TD>Assignment</TD>
<TD><SAMP>t = a</SAMP> where <SAMP>a</SAMP> is a (possibly <SAMP>const</SAMP>) value of <SAMP>T</SAMP></TD></TR>
</TABLE></CENTER>
<A NAME="Interface"><H3>Interface</H3></A>
<PRE>template &#60;class T, class Allocator = allocator></PRE>
<PRE> class deque {
public:
 // Types
   class iterator; 
   class const_iterator;
   typedef T value_type;
   typedef Allocator allocator_type;
   typename  reference;
   typename  const_reference;
   typename  size_type;
   typename  difference_type;
   typename reverse_iterator;
   typename  const_reverse_iterator;
 // Construct/Copy/Destroy
   explicit deque (const Allocator&#38; = Allocator());
   explicit deque (size_type, const Allocator&#38; = Allocator ());
   deque (size_type, const T&#38; value, 
          const Allocator&#38; = Allocator ());
   deque (const deque&#60;T,Allocator>&#38;);
   template &#60;class InputIterator>
    deque (InputIterator, InputIterator, 
           const Allocator&#38; = Allocator ());
   ~deque ();
   deque&#60;T,Allocator>&#38; operator= (const deque&#60;T,Allocator>&#38;);
   template &#60;class InputIterator>
    void assign (InputIterator, InputIterator);
   template &#60;class Size, class T>
    void assign (Size);
   template &#60;class Size, class T>
    void assign (Size, const T&#38;);
   allocator_type get allocator () const;
 // Iterators
   iterator begin ();
   const_iterator begin () const;
   iterator end ();
   const_iterator end () const;
   reverse_iterator rbegin ();
   const_reverse_iterator rbegin () const;
   reverse_iterator rend ();
   const_reverse_iterator rend () const;
// Capacity
   size_type size () const;
   size_type max_size () const;
   void resize (size_type);
   void resize (size_type, T);
   bool empty () const;
// Element access
   reference operator[] (size_type);
   const_reference operator[] (size_type) const;
   reference at (size_type);
   const_reference at (size_type) const;
   reference front ();
   const_reference front () const;
   reference back ();
   const_reference back () const;
 // Modifiers
   void push_front (const T&#38;);
   void push_back (const T&#38;);
   iterator insert (iterator);
   iterator insert (iterator, const T&#38;);
   void insert (iterator, size_type, const T&#38;);
   template &#60;class InputIterator>
    void insert (iterator, InputIterator, InputIterator);
   void pop_front ();
   void pop_back ();
   iterator erase (iterator);
   iterator erase (iterator, iterator);
   void swap (deque&#60;T, Allocator>&#38;);
   void clear();
};
 // Non-member Operators
template &#60;class T, class Allocator>
 bool operator== (const deque&#60;T, Allocator>&#38;, 
                  const deque&#60;T, Allocator>&#38;);
template &#60;class T, class Allocator>
 bool operator&#60;<B> </B>(const deque&#60;T, Allocator>&#38;, 
                 const deque&#60;T, Allocator>&#38;);
// Specialized Algorithms
template &#60;class T, class Allocator>
 voice swap (deque&#60;T, Allocator>&#38;, deque&#60;T, Allocator>&#38;);</PRE>
<A NAME="Constructors and Destructor"><H3>Constructors and Destructor</H3></A>
<PRE>explicit 
<B>deque</B> (const Allocator&#38; alloc = Allocator());</PRE>
<UL><P>The default constructor.  Creates a deque of zero elements. The deque will use the allocator <SAMP>alloc</SAMP> for all storage management.</P>
</UL>
<PRE>explicit 
<B>deque</B> (size_type n, const Allocator&#38; alloc = Allocator());</PRE>
<UL><P>Creates a list of length <SAMP>n</SAMP>, containing <SAMP>n</SAMP> copies of the default value for type <SAMP>T</SAMP>. Requires that <SAMP>T</SAMP> have a default constructor. The deque will use the allocator <SAMP>alloc</SAMP> for all storage management. </P>
</UL>
<PRE><B>deque</B> (size_type n, const T&#38; value, 
       const Allocator&#38; alloc = Allocator());</PRE>
<UL><P>Creates a list of length <SAMP>n</SAMP>,  containing <SAMP>n</SAMP> copies of <SAMP>value</SAMP>. The deque will use the allocator <SAMP>alloc</SAMP> for all storage management. </P>
</UL>
<PRE><B>deque</B> (const deque&#60;T, Allocator>&#38; x);</PRE>
<UL><P>Copy constructor. Creates a copy of <SAMP>x</SAMP>.</P>
</UL>
<PRE>template &#60;class InputIterator>
<B>deque</B> (InputIterator first, InputIterator last, 
       const Allocator&#38; alloc = Allocator());</PRE>
<UL><P>Creates a deque of length <SAMP>last - first</SAMP>, filled with all values obtained  by dereferencing the <SAMP>InputIterators</SAMP> on the range <SAMP>[first, last)</SAMP>. The deque will use the allocator <SAMP>alloc</SAMP> for all storage management. </P>
</UL>
<PRE><B>~deque</B> ();</PRE>
<UL><P>The destructor.  Releases any allocated memory for self.</P>
</UL>
<A NAME="Allocator"><H3>Allocator</H3></A>
<PRE><B>allocator</B>
allocator_type <B>get_allocator</B> () const;</PRE>
<UL><P>Returns a copy of the allocator used by self for storage management.</P>
</UL>
<A NAME="Iterators"><H3>Iterators</H3></A>
<PRE>iterator <B>begin</B> ();</PRE>
<UL><P>Returns a random access <SAMP>iterator</SAMP> that points to the first element.</P>
</UL>
<PRE>const_iterator <B>begin</B> () const;</PRE>
<UL><P>Returns a constant random access iterator that points to the first element.</P>
</UL>
<PRE>iterator <B>end</B> ();</PRE>
<UL><P>Returns a random access <SAMP>iterator</SAMP> that points to the past-the-end value.</P>
</UL>
<PRE>const_iterator <B>end</B> () const;</PRE>
<UL><P>Returns a constant random access iterator that points to the past-the-end value.</P>
</UL>
<PRE>reverse_iterator <B>rbegin</B> ();</PRE>
<UL><P>Returns a random access <SAMP>reverse_iterator</SAMP> that points to the past-the-end value.</P>
</UL>
<PRE>const_reverse_iterator <B>rbegin</B> () const;</PRE>
<UL><P>Returns a constant random access reverse iterator that points to the past-the-end value.</P>
</UL>
<PRE>reverse_iterator <B>rend</B> ();</PRE>
<UL><P>Returns a random access <SAMP>reverse_iterator</SAMP> that points to the first element.</P>
</UL>
<PRE>const_reverse_iterator <B>rend</B> () const;</PRE>
<UL><P>Returns a constant random access reverse iterator that points to the first element.</P>
</UL>
<A NAME="Assignment Operator"><H3>Assignment Operator</H3></A>
<PRE>deque&#60;T, Allocator>&#38; 
<B>operator=</B> (const deque&#60;T, Allocator>&#38; x);</PRE>
<UL><P>Erases all elements in self then inserts into self a copy of each element in <SAMP>x</SAMP>. Returns a reference to self.</P>
</UL>
<A NAME="Reference Operators"><H3>Reference Operators</H3></A>
<PRE>reference <B>operator</B>[] (size_type n);</PRE>
<UL><P>Returns a <SAMP>reference</SAMP> to element <SAMP>n</SAMP> of self.   The  result can be used as an lvalue.  The index <SAMP>n</SAMP> must be between 0 and the size less one.</P>
</UL>
<PRE>const_reference <B>operator</B>[] (size_type n) const;</PRE>
<UL><P>Returns a constant reference to element <SAMP>n</SAMP> of self.  The index <SAMP>n</SAMP> must be between 0 and the <SAMP>size() - 1</SAMP>.</P>
</UL>
<A NAME="Member Functions"><H3>Member Functions</H3></A>
<PRE>template &#60;class InputIterator>
void
<B>assign</B> (InputIterator first, InputIterator last);</PRE>
<UL><P>Erases all elements contained in self, then inserts new elements from the range <SAMP>[first, last)</SAMP>.</P>
</UL>
<PRE>template &#60;class Size, class T>
void 
<B>assign</B> (Size n);</PRE>
<UL><P>Erases all elements contained in self, then inserts <SAMP>n</SAMP> instances of the default value of type <SAMP>T</SAMP>.</P>
</UL>
<PRE>template &#60;class Size, class T>
void 
<B>assign</B> (Size n, const T&#38; t);</PRE>
<UL><P>Erases all elements contained in self, then inserts <SAMP>n</SAMP> instances of the value of <SAMP>t.</SAMP></P>
</UL>
<PRE>reference 
<B>at</B> (size_type n);</PRE>
<UL><P>Returns a <SAMP>reference</SAMP> to element <SAMP>n</SAMP> of self.  The  result can be used as an lvalue.  The index <SAMP>n</SAMP> must be between 0 and the<SAMP> size() - 1</SAMP>.</P>
</UL>
<PRE>const_reference 
<B>at </B>(size_type) const;</PRE>
<UL><P>Returns a constant reference to element <SAMP>n</SAMP> of self.  The index <SAMP>n</SAMP> must be between 0 and the <SAMP>size() - 1</SAMP>.</P>
</UL>
<PRE>reference 
<B>back</B> ();</PRE>
<UL><P>Returns a <SAMP>reference</SAMP> to the last element.</P>
</UL>
<PRE>const_reference 
<B>back</B> () const;</PRE>
<UL><P>Returns a constant reference to the last element.</P>
</UL>
<PRE>void
<B>clear</B> ();</PRE>
<UL><P>Erases all elements from the self.</P>
</UL>
<PRE>bool 
<B>empty</B> () const;</PRE>
<UL><P>Returns <SAMP>true</SAMP> if the size of self is zero.</P>
</UL>
<PRE>reference 
<B>front</B> ();</PRE>
<UL><P>Returns a <SAMP>reference</SAMP> to the first element.</P>
</UL>
<PRE>const_reference 
<B>front</B> () const;</PRE>
<UL><P>Returns a constant reference to the first element.</P>
</UL>
<PRE>iterator
<B>erase</B> (iterator first, iterator last);</PRE>
<UL><P>Deletes the elements in the range (<SAMP>first, last</SAMP>). Returns an <SAMP>iterator</SAMP> pointing to the element following the last deleted element, or <SAMP>end()</SAMP> if there were no elements after the deleted range.</P>
</UL>
<PRE>iterator
<B>erase</B> (iterator position);</PRE>
<UL><P>Removes the element pointed to by <SAMP>position</SAMP>. Returns an <SAMP>iterator</SAMP> pointing to the element following the deleted element, or <SAMP>end()</SAMP> if there were no elements after the deleted range.</P>
</UL>
<PRE>iterator 
<B>insert</B> (iterator position);</PRE>
<UL><P>Inserts a copy of the default value of type <SAMP>T</SAMP> before <SAMP>position</SAMP>.  The return value points to the inserted element.  Requires that type <SAMP>T</SAMP> have a default constructor.</P>
</UL>
<PRE>iterator 
<B>insert</B> (iterator position, const T&#38; x);</PRE>
<UL><P>Inserts <SAMP>x</SAMP> before <SAMP>position</SAMP>.  The return value points to the inserted <SAMP>x</SAMP>.</P>
</UL>
<PRE>void 
<B>insert</B> (iterator position, size_type n, const T&#38; x);</PRE>
<UL><P>Inserts <SAMP>n</SAMP> copies of <SAMP>x </SAMP>before <SAMP>position</SAMP>.</P>
</UL>
<PRE>template &#60;class InputIterator>
void 
<B>insert</B> (iterator position, InputIterator first,
        InputIterator last);</PRE>
<UL><P>Inserts copies of the elements in the range <SAMP>(first, last]</SAMP> before <SAMP>position</SAMP>.</P>
</UL>
<PRE>size_type 
<B>max_size </B>() const;</PRE>
<UL><P>    Returns <SAMP>size()</SAMP> of the largest possible deque.</P>
</UL>
<PRE>void 
<B>pop_back</B> ();</PRE>
<UL><P>Removes the last element.  Note that this function does not return the element.</P>
</UL>
<PRE>void 
<B>pop_front </B>();</PRE>
<UL><P>Removes the first element.  Note that this function does not return the element</P>
</UL>
<PRE>void
<B>push_back </B>(const T&#38; x);</PRE>
<UL><P>Appends a copy of <SAMP>x</SAMP> to the end.</P>
</UL>
<PRE>void 
<B>push_front </B>(const T&#38; x);</PRE>
<UL><P>Inserts a copy of <SAMP>x</SAMP> at the front.</P>
</UL>
<PRE>void 
<B>resize</B> (size_type sz);</PRE>
<UL><P>Alters the size of self.  If the new size (<SAMP>sz</SAMP>) is greater than the current size then <SAMP>sz-size()</SAMP> copies of the default value of type <SAMP>T</SAMP> are inserted at the end of the deque. If the new size is smaller than the current capacity, then the deque is truncated by erasing <SAMP>size()-sz</SAMP> elements off the end. Otherwise, no action is taken. Requires that type <SAMP>T</SAMP> have a default constructor.</P>
</UL>
<PRE>void 
<B>resize</B> (size_type sz, T c);</PRE>
<UL><P>Alters the size of self.  If the new size (<SAMP>sz</SAMP>) is greater than the current size then <SAMP>sz-size()</SAMP> <SAMP>c</SAMP>'s are  inserted at the end of the deque. If the new size is smaller than the current capacity, then the deque is truncated by erasing <SAMP>size()-sz</SAMP> elements off the end. Otherwise, no action is taken.</P>
</UL>
<PRE>size_type 
<B>size</B> () const;</PRE>
<UL><P>Returns the number of elements.</P>
</UL>
<PRE>void 
<B>swap</B> (deque&#60;T,Allocator>&#38; x);</PRE>
<UL><P>Exchanges self with <SAMP>x</SAMP>.</P>
</UL>
<A NAME="Non-member Functions"><H3>Non-member Functions</H3></A>
<PRE>template &#60;class T, class Allocator>
bool <B>operator== </B>(const deque&#60;T, Allocator>&#38; x,
                 const deque&#60;T, Allocator>&#38; y);</PRE>
<UL><P>Equality operator. Returns <SAMP>true</SAMP> if <SAMP>x</SAMP> is the same as <SAMP>y</SAMP>.</P>
</UL>
<PRE>template &#60;class T, class Allocator>
bool <B>operator&#60; </B>(const deque&#60;T, Allocator>&#38; x,
                const deque&#60;T, Allocator>&#38; y);</PRE>
<UL><P>Returns <SAMP>true</SAMP> if the elements contained in <SAMP>x</SAMP> are lexicographically less than the elements contained in <SAMP>y</SAMP>.</P>
</UL>
<PRE>template &#60;class T, class Allocator>
void <B>swap </B>(deque&#60;T, Allocator>&#38; a, deque&#60;T, Allocator>&#38; b);</PRE>
<UL><P>Efficiently swaps the contents of <SAMP>a</SAMP> and <SAMP>b</SAMP>.</P>
</UL>
<A NAME="Example"><H3>Example</H3></A>
<PRE>//
// deque.cpp
//
 #include &#60;deque>
 #include &#60;string>
 deque&#60;string, allocator> deck_of_cards; 
 deque&#60;string, allocator> current_hand;
 void initialize_cards(deque&#60;string, allocator>&#38; cards) {
   cards.push_front("aceofspades");
   cards.push_front("kingofspades");
   cards.push_front("queenofspades");
   cards.push_front("jackofspades");
   cards.push_front("tenofspades");
   // etc.
 }
 template &#60;class It, class It2> 
 void print_current_hand(It start, It2 end) 
 {
   while (start &#60; end) 
   cout &#60;&#60; *start++ &#60;&#60; endl;
 }
 template &#60;class It, class It2>
 void deal_cards(It, It2 end) {
   for (int i=0;i&#60;5;i++) {
     current_hand.insert(current_hand.begin(),*end);
     deck_of_cards.erase(end++);
   }
 }
 void play_poker() {
   initialize_cards(deck_of_cards);
   deal_cards(current_hand.begin(),deck_of_cards.begin()); 
 }
 int main() 
 {
   play_poker();
   print_current_hand(current_hand.begin(),current_hand.end());
   return 0;
 }
Output :
aceofspades
kingofspades
queenofspades
jackofspades
tenofspades</PRE>
<A NAME="Warnings"><H3>Warnings</H3></A>
<P>Member function templates are used in all containers provided by the Standard Template Library.  An example of this is the constructor for <B><I>deque&#60;T, Allocator></B></I> that takes two templated iterators: </P>
<PRE>template &#60;class InputIterator>
 deque (InputIterator, InputIterator);</PRE>

<P><B><I>deque</B></I> also has an insert function of this type. These functions, when not restricted by compiler limitations, allow you to use any type of input iterator as arguments.  For compilers that do not support this feature we provide substitute functions that allow you to use an iterator obtained from the same type of container as the one you are constructing (or calling a member function on), or you can use a pointer to the type of element you have in the container. </P>
<P>For example, if your compiler does not support member function templates you can construct a <B><I>deque</B></I> in the following two ways: </P>
<PRE>int intarray[10];
deque&#60;int, allocator> first_deque(intarray, intarray + 10);
deque&#60;int, allocator> second_deque(first_deque.begin(),  
                                   first_deque.end());</PRE>

<P>But not this way:</P>
<PRE>deque&#60;long, allocator> long_deque(first_deque.begin(),
                                  first_deque.end());
</PRE>
<P>since the<SAMP> long_deque</SAMP> and <SAMP>first_deque</SAMP> are not the same type.</P>
<P>Additionally, many compilers do not support default template arguments.  If your compiler is one of these, you need to always supply the <SAMP>Allocator</SAMP> template argument.  For instance, you'll have to write:</P>
<PRE>
deque&#60;int, allocator>
</PRE>
<UL><P>instead of:</P>
</UL>
<PRE>deque&#60;int>
</PRE>
<UL>
</UL>
<HR>
<A HREF="cou_2233.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="dis_0186.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
