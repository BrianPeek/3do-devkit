<HTML><TITLE>basic_string</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>basic_string</H2>
<HR><PRE>     Strings Library</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A templated class for handling sequences of character-like entities. <B><I>string</B></I> and <B><I>wstring</B></I> are specialized versions of <B><I>basic_string</B></I> for <SAMP>char</SAMP>s and <SAMP>wchar_t</SAMP>s, respectively.</P>
<PRE>typedef basic_string &#60;char> string;</PRE>
<PRE>typedef basic_string &#60;wchar_t> wstring;</PRE>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Interface"><LI>Interface</LI></A>
<A HREF="#Constructors and Destructors"><LI>Constructors and Destructors</LI></A>
<A HREF="#Operators"><LI>Operators</LI></A>
<A HREF="#Iterators"><LI>Iterators</LI></A>
<A HREF="#Allocator"><LI>Allocator</LI></A>
<A HREF="#Member Functions"><LI>Member Functions</LI></A>
<A HREF="#Non-member Operators"><LI>Non-member Operators</LI></A>
<A HREF="#Non-member Function"><LI>Non-member Function</LI></A>
<A HREF="#Example"><LI>Example</LI></A>
<A HREF="#See Also"><LI>See Also</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;string></PRE>
<PRE>
template &#60;class charT,
          class traits = string_char_traits&#60;charT>,
          class Allocator = allocator>
class basic_string;</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P><B><I>basic_string&#60;charT, traits, Allocator></B></I> is a homogeneous collection of character-like entities.  It provides general string functionality such as compare, append, assign, insert, remove, and replace , along with various searches.  <B><I>basic_string</B></I> also functions as an STL sequence container, providing random access iterators.  This allows some of the generic algorithms to apply to strings.</P>
<P>Any underlying character-like type may be used as long as an appropriate <SAMP>string_char_traits</SAMP> class is provided or the default traits class is applicable. </P>
<A NAME="Interface"><H3>Interface</H3></A>
<PRE>template &#60;class charT,
          class traits = string_char_traits&#60;charT>,
          class Allocator = allocator>
class basic_string {
public:
// Types
typedef traits                               traits_type;
typedef typename traits::char_type           value_type;
typedef Allocator                            allocator_type;
typename size_type;
typename difference_type;
typename reference;
typename const_reference;
typename pointer;
typename const_pointer;
typename iterator;
typename const_iterator;
typename const_reverse_iterator;
typename reverse_iterator;
static const size_type npos = -1;
// Constructors/Destructors
explicit basic_string(const Allocator&#38; = Allocator());
basic_string(const basic_string&#38;, size_type, size_type = npos);
basic_string(const charT*, size_type,
             const Allocator&#38; = Allocator());
basic_string(const charT*, Allocator&#38; = Allocator());
basic_string(size_type, charT,
             const Allocator&#38; = Allocator());
template &#60;class InputIterator>
basic_string(InputIterator, InputIterator,
             const Allocator&#38; = Allocator());
~basic_string();
// Assignment operators
 basic_string&#38; operator=(const basic_string&#38;);
 basic_string&#38; operator=(const charT*);
 basic_string&#38; operator=(charT);
// Iterators
 iterator       begin();
 const_iterator begin() const;
 iterator       end();
 const_iterator end() const;
 reverse_iterator       rbegin();
 const_reverse_iterator rbegin() const;
 reverse_iterator       rend();
 const_reverse_iterator rend() const;
// Capacity
   size_type       size() const;
   size_type       length() const;
   size_type       max_size() const;
   void            resize(size_type, charT);
   void            resize(size_type);
   size_type       capacity() const;
   void            reserve(size_type);
   bool            empty() const;
// Element access
   charT           operator[](size_type) const;
   reference       operator[](size_type);
   const_reference at(size_type) const;
   reference       at(size_type);
// Modifiers
   basic_string&#38; operator+=(const basic_string&#38;);
   basic_string&#38; operator+=(const charT*);
   basic_string&#38; operator+=(charT);
   
   basic_string&#38; append(const basic_string&#38;);
   basic_string&#38; append(const basic_string&#38;,
                        size_type, size_type);
   basic_string&#38; append(const charT*, size_type);
   basic_string&#38; append(const charT*);
   basic_string&#38; append(size_type, charT);
   template&#60;class InputIterator>
    basic_string&#38; append(InputIterator, InputIterator);
   
   basic_string&#38; assign(const basic_string&#38;);
   basic_string&#38; assign(const basic_string&#38;,
                        size_type, size_type);
   basic_string&#38; assign(const charT*, size_type);
   basic_string&#38; assign(const charT*);
   basic_string&#38; assign(size_type, charT);
   template&#60;class InputIterator>
    basic_string&#38; assign(InputIterator, InputIterator);
   
   basic_string&#38; insert(size_type, const basic_string&#38;);
   basic_string&#38; insert(size_type, const basic_string&#38;,
                        size_type, size_type);
   basic_string&#38; insert(size_type, const charT*, size_type);
   basic_string&#38; insert(size_type, const charT*);
   basic_string&#38; insert(size_type, size_type, charT);
   iterator insert(iterator, charT = charT());
   void insert(iterator, size_type, charT);
   template&#60;class InputIterator>
    void insert(iterator, InputIterator,
               InputIterator);
   basic_string&#38; erase(size_type = 0, size_type= npos);
   iterator erase(iterator);
   iterator erase(iterator, iterator);
   basic_string&#38; replace(size_type, size_type,
                         const basic_string&#38;);
   basic_string&#38; replace(size_type, size_type,
                         const basic_string&#38;,
                         size_type, size_type);
   basic_string&#38; replace(size_type, size_type,
                         const charT*, size_type);
   basic_string&#38; replace(size_type, size_type,
                         const charT*);
   basic_string&#38; replace(size_type, size_type,
                         size_type, charT);
   basic_string&#38; replace(iterator, iterator,
                         const basic_string&#38;);
   basic_string&#38; replace(iterator, iterator,
                         const charT*, size_type);
   basic_string&#38; replace(iterator, iterator,
                         const charT*);
   basic_string&#38; replace(iterator, iterator,
                         size_type, charT);
   template&#60;class InputIterator>
    basic_string&#38; replace(iterator, iterator,
                         InputIterator, InputIterator);
   size_type copy(charT*, size_type, size_type = 0);
   void swap(basic_string&#60;charT, traits, Allocator>&#38;);
// String operations
   const charT* c_str() const;
   const charT* data() const;
   const allocator_type&#38; get_allocator() const;
   
   size_type find(const basic_string&#38;,
                  size_type = 0) const;
   size_type find(const charT*,
                  size_type, size_type) const;
   size_type find(const charT*, size_type = 0) const;
   size_type find(charT, size_type = 0) const;
   size_type rfind(const basic_string&#38;,
                   size_type = npos) const;
   size_type rfind(const charT*,
                   size_type, size_type) const;
   size_type rfind(const charT*,
                   size_type = npos) const;
   size_type rfind(charT, size_type = npos) const;
   size_type find_first_of(const basic_string&#38;,
                           size_type = 0) const;
   size_type find_first_of(const charT*,
                           size_type, size_type) const;
   size_type find_first_of(const charT*,
                           size_type = 0) const;
   size_type find_first_of(charT, size_type = 0) const;
   size_type find_last_of(const basic_string&#38;,
                          size_type = npos) const;
   size_type find_last_of(const charT*,
                          size_type, size_type) const;
   size_type find_last_of(const charT*, size_type = npos) const;
   size_type find_last_of(charT, size_type = npos) const;
   size_type find_first_not_of(const basic_string&#38;,
                               size_type = 0) const;
   size_type find_first_not_of(const charT*,
                               size_type, size_type) const;
   size_type find_first_not_of(const charT*, size_type = 0) const;
   size_type find_first_not_of(charT, size_type = 0) const;
   size_type find_last_not_of(const basic_string&#38;,
                              size_type = npos) const;
   size_type find_last_not_of(const charT*,
                              size_type, size_type) const;
   size_type find_last_not_of(const charT*, 
                              size_type = npos) const;
   size_type find_last_not_of(charT, size_type = npos) const;
   basic_string substr(size_type = 0, size_type = npos) const;
   int compare(const basic_string&#38;) const;
   int compare(size_type, size_type, const basic_string&#38;) const;
   int compare(size_type, size_type, const basic_string&#38;,
               size_type, size_type) const;
   int compare(size_type, size_type, charT*) const;
   int compare(charT*) const;
   int compare(size_type, size_type, const charT*, size_type) const;
};
// Non-member Operators
template &#60;class charT, class traits, class Allocator>
 basic_string operator+ (const basic_string&#38;,
                         const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 basic_string operator+ (const charT*, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 basic_string operator+ (charT, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 basic_string operator+ (const basic_string&#38;, const charT*);
template &#60;class charT, class traits, class Allocator>
 basic_string operator+ (const basic_string&#38;, charT);
template &#60;class charT, class traits, class Allocator>
 bool operator== (const basic_string&#38;, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator== (const charT*, const basic_string&#38;);
template &#60;class charT, class traits , class Allocator>
 bool operator== (const basic_string&#38;, const charT*);
template &#60;class charT, class traits, class Allocator>
 bool operator&#60; (const basic_string&#38;, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator&#60; (const charT*, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator&#60; (const basic_string&#38;, const charT*);
template &#60;class charT, class traits, class Allocator>
 bool operator!= (const basic_string&#38;, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator!= (const charT*, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator!= (const basic_string&#38;, const charT*);
template &#60;class charT, class traits, class Allocator>
 bool operator> (const basic_&#38;, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator> (const charT*, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator> (const basic_string&#38;, const charT*);
template &#60;class charT, class traits, class Allocator>
 bool operator&#60;= (const basic_string&#38;, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator&#60;= (const charT*, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator&#60;= (const basic_string&#38;, const charT*);
template &#60;class charT, class traits, class Allocator>
 bool operator>= (const basic_string&#38;, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator>= (const charT*, const basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 bool operator>= (const basic_string&#38;, const charT*);
template&#60;class charT, class traits, class Allocator>
 istream&#38; operator>> (istream&#38;, basic_string&#38;);
template &#60;class charT, class traits, class Allocator>
 ostream&#38; operator&#60;&#60; (ostream&#38;, const basic_string&#38;);
template &#60;class Stream, class charT, 
          class traits, class Allocator>
 Stream&#38; getline (Stream&#38;, basic_string&#38;, charT);
</PRE>
<A NAME="Constructors and Destructors"><H3>Constructors and Destructors</H3></A>
<P>In all cases, the <SAMP>Allocator</SAMP> parameter will be used for storage management.</P>
<PRE>explicit 
<B>basic_string</B> (const Allocator&#38; a = Allocator());</PRE>
<UL><P>The default constructor.  Creates a <B><I>basic_string</B></I> with the following effects:</P></UL>
<TABLE BORDER CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD><SAMP>data()</SAMP></TD>
<TD>a non-null pointer that is copyable and can have 0 added to it</TD></TR>
<TR VALIGN=top>
<TD><SAMP>size()</SAMP></TD>
<TD>0</TD></TR>
<TR VALIGN=top>
<TD><SAMP>capacity()</SAMP></TD>
<TD>an unspecified value</TD></TR>
</TABLE>
<PRE><B>basic_string</B> (const basic_string&#60;T, traits, Allocator>&#38; str);</PRE>
<UL><P>Copy constructor. Creates a string that is a copy of <SAMP>str</SAMP>.</P>
</UL>
<PRE><B>basic_string</B> (const basic_string &#38;str, size_type pos,
              size_type n= npos);</PRE>
<UL><P>Creates a string if <SAMP>pos&#60;=size() </SAMP>and determines length <SAMP>rlen</SAMP> of initial string value as the smaller of <SAMP>n</SAMP> and <SAMP>str.size() - pos</SAMP>. This has the following effects:</P>
</UL>
<CENTER><TABLE BORDER CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD><SAMP>data()</SAMP></TD>
<TD>points at the first element of an allocated copy of <SAMP>rlen</SAMP> elements of the string controlled by <SAMP>str</SAMP> beginning at position <SAMP>pos</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>size()</SAMP></TD>
<TD><SAMP>rlen</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>capacity()</SAMP></TD>
<TD>a value at least as large as <SAMP>size()</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>get_allocator()</SAMP></TD>
<TD><SAMP>str.get_allocator()</SAMP></TD></TR>
</TABLE></CENTER>
<PRE></PRE>
<UL><P>An <SAMP>out_of_range</SAMP> exception will be thrown if <SAMP>pos>str.size()</SAMP>.</P>
</UL>
<PRE><B>basic_string</B> (const charT* s, size_type n,
              const Allocator&#38; a = Allocator());</PRE>
<UL><P>Creates a string that contains the first <SAMP>n</SAMP> characters of <SAMP>s</SAMP>. <SAMP>s</SAMP> must not be a <SAMP>NULL</SAMP> pointer.  The effects of this constructor are:</P>
</UL>
<CENTER><TABLE BORDER CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD><SAMP>data()</SAMP></TD>
<TD>points at the first element of an allocated copy of the array whose first element is pointed at by <SAMP>s</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>size()</SAMP></TD>
<TD><SAMP>n</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>capacity()</SAMP></TD>
<TD>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></CENTER>
<PRE></PRE>
<UL><P>An <SAMP>out_of_range</SAMP> exception will be thrown if <SAMP>n == npos.</SAMP></P>
</UL>
<PRE><B>basic_string</B> (const charT * s, 
              const Allocator&#38; a = Allocator());</PRE>
<UL><P>Constructs a string containing all characters in <SAMP>s</SAMP> up to, but not including, a <SAMP>traits::eos()</SAMP> character. <SAMP>s</SAMP> must not be a null pointer. The effects of this constructor are:</P>
</UL>
<CENTER><TABLE BORDER CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD><SAMP>data()</SAMP></TD>
<TD>points at the first element of an allocated copy of the array whose first element is pointed at by <SAMP>s</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>size()</SAMP></TD>
<TD><SAMP>traits::length(s)</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>capacity()</SAMP></TD>
<TD>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></CENTER>
<PRE><B>basic_string </B>(size_type n, charT c, 
              const Allocator&#38; a  = Allocator());</PRE>
<UL><P>Constructs a string containing <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>.  A <SAMP>length_error</SAMP> exception is thrown if <SAMP>n == npos</SAMP>.  The effects of this constructor are:</P>
</UL>
<CENTER><TABLE BORDER CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD><SAMP>data()</SAMP></TD>
<TD>points at the first element of an allocated array of <SAMP>n</SAMP> elements, each storing the initial value <SAMP>c</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>size()</SAMP></TD>
<TD><SAMP>n</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>capacity()</SAMP></TD>
<TD>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></CENTER>
<PRE>template &#60;class InputIterator>
<B>basic_string </B> (InputIterator first, InputIterator last,
               const Allocator&#38; a = Allocator());</PRE>
<UL><P>Creates a <B><I>basic_string</B></I> of length <SAMP>last - first</SAMP>, filled with all values obtained by dereferencing the <SAMP>InputIterators</SAMP> on the range <SAMP>[first, last)</SAMP>. The effects of this constructor are:</P>
</UL>
<CENTER><TABLE BORDER CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD><SAMP>data()</SAMP></TD>
<TD>points at the first element of an allocated copy of the elements in the range <SAMP>[first,last)</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>size()</SAMP></TD>
<TD>distance between <SAMP>first</SAMP> and <SAMP>last</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>capacity()</SAMP></TD>
<TD>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></CENTER>
<PRE>~<B>basic_string </B>();</PRE>
<UL><P>Releases any allocated memory for this <B><I>basic_string</B></I>.</P>
</UL>
<A NAME="Operators"><H3>Operators</H3></A>
<PRE>basic_string&#38;
<B>operator=</B> (const basic_string&#38; str);</PRE>
<UL><P>Assignment operator. Sets the contents of this string to be the same as <SAMP>str</SAMP>.  The effects of <SAMP>operator=</SAMP> are:</P>
</UL>
<CENTER><TABLE BORDER CELLSPACING=3 CELLPADDING=3>
<TR VALIGN=top>
<TD><SAMP>data()</SAMP></TD>
<TD>points at the first element of an allocated copy of the array whose first element is pointed at by <SAMP>str.size()</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>size()</SAMP></TD>
<TD><SAMP>str.size()</SAMP></TD></TR>
<TR VALIGN=top>
<TD><SAMP>capacity()</SAMP></TD>
<TD>a value at least as large as <SAMP>size()</SAMP></TD></TR>
</TABLE></CENTER>
<PRE>basic_string&#38; 
<B>operator=</B> (const charT * s);</PRE>
<UL><P>Assignment operator. Sets the contents of this string to be the same as <SAMP>s</SAMP> up to, but not including, the <SAMP>traits::eos()</SAMP> character.</P>
</UL>
<PRE>basic_string&#38; 
<B>operator=</B> (charT c);</PRE>
<UL><P>Assignment operator. Sets the contents of this string to be equal to the single <SAMP>charT</SAMP> <SAMP>c</SAMP>.</P>
</UL>
<PRE>charT 
<B>operator[]</B> (size_type pos) const;
reference 
<B>operator[]</B> (size_type pos);</PRE>
<UL><P>If <SAMP>pos &#60; size()</SAMP>, returns the element at position <SAMP>pos</SAMP> in this  string.  If <SAMP>pos == size()</SAMP>,  the <SAMP>const</SAMP> version returns t<SAMP>raits::eos()</SAMP>, the behavior of the non-<SAMP>const</SAMP> version is undefined.  The reference returned by the non-<SAMP>const</SAMP> version is invalidated by any call to <SAMP>c_str()</SAMP>, <SAMP>data()</SAMP>, or any non-<SAMP>const</SAMP> member function for the object.</P>
</UL>
<PRE>basic_string&#38; 
<B>operator+=</B> (const basic_string&#38; s);
basic_string&#38; 
<B>operator+=</B> (const charT* s);
basic_string&#38; 
<B>operator+=</B> (charT c);</PRE>
<UL><P>Concatenates a string onto the current contents of this string.  The second member operator uses <SAMP>traits::length()</SAMP> to determine the number of elements from <SAMP>s</SAMP> to add.  The third member operator adds the single character <SAMP>c</SAMP>.  All return a reference to this string after completion.</P>
</UL>
<A NAME="Iterators"><H3>Iterators</H3></A>
<PRE>iterator <B>begin</B> ();
const_iterator <B>begin</B> () const;</PRE>
<UL><P>Return an iterator initialized to the first element of the string.</P>
</UL>
<PRE>iterator <B>end</B> ();
const_iterator <B>end</B> () const;</PRE>
<UL><P>Return an iterator initialized to the position after the last element of the string.</P>
</UL>
<PRE>reverse_iterator <B>rbegin</B> ();
const_reverse_iterator <B>rbegin</B> () const;</PRE>
<UL><P>Returns an iterator equivalent to <SAMP>reverse_iterator(end())</SAMP>.</P>
</UL>
<PRE>reverse_iterator <B>rend</B> ();
const_reverse_iterator <B>rend</B> () const;</PRE>
<UL><P>Returns an iterator equivalent to <SAMP>reverse_iterator(begin())</SAMP>.</P>
</UL>
<A NAME="Allocator"><H3>Allocator</H3></A>
<PRE>const allocator_type <B>get_allocator</B> () const;</PRE>
<UL><P>Returns a copy of the allocator used by self for storage management.</P>
</UL>
<A NAME="Member Functions"><H3>Member Functions</H3></A>
<PRE>basic_string&#38; 
<B>append</B> (const basic_string&#38; s, size_type pos, size_type npos);
basic_string&#38;
<B>append</B> (const basic_string&#38; s);
basic_string&#38; 
<B>append</B> (const charT* s, size_type n);
basic_string&#38; 
<B>append</B> (const charT* s);
basic_string&#38; 
<B>append</B> (size_type n, charT c );
template&#60;class InputIterator>
basic_string&#38;  
<B>append</B> (InputIterator first, InputIterator last);</PRE>
<UL><P>Append another string to the end of this string.  The first two functions append the lesser of <SAMP>n</SAMP> and <SAMP>s.size() - pos</SAMP> characters of <SAMP>s</SAMP>, beginning at position <SAMP>pos</SAMP> to this string.   The second member will throw an <SAMP>out_of_range</SAMP> exception if <SAMP>pos > str.size()</SAMP>.  The third member appends <SAMP>n</SAMP> characters of the array pointed to by <SAMP>s</SAMP>.  The fourth variation appends elements from the array pointed to by <SAMP>s</SAMP> up to, but not including, a <SAMP>traits::eos()</SAMP> character.  The fifth variation appends <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>.  The final <SAMP>append</SAMP> function appends the elements specified in the range <SAMP>[first, last)</SAMP>.  </P>
<P>All functions will throw a <SAMP>length_error</SAMP> exception if the resulting length will exceed <SAMP>max_size()</SAMP>.  All return a reference to this string after completion.</P>
</UL>
<PRE>basic_string&#38;
<B>assign </B>(const basic_string&#38; s);
basic_string&#38; 
<B>assign</B> (const  basic_string&#38; s,
       size_type pos, size_type n);
basic_string&#38; 
<B>assign</B> (const charT* s, size_type n);
basic_string&#38;
<B>assign</B> (const charT* s);
basic_string&#38;
<B>assign</B> (size_type n, charT c );
template&#60;class InputIterator>
basic_string&#38;  
<B>assign</B> (InputIterator first, InputIterator last);
</PRE>
<UL><P>Replace the value of this string with the value of another.   </P>
<P>All versions of the function assign values to this string.  The first two variations assign the lesser of <SAMP>n</SAMP> and <SAMP>s.size() - pos </SAMP>characters of <SAMP>s</SAMP>, beginning at position <SAMP>pos</SAMP>.  The second variation throws an <SAMP>out_of_range</SAMP> exception if <SAMP>pos > str.size()</SAMP>.  The third version of the function assigns <SAMP>n</SAMP> characters of the array pointed to by <SAMP>s</SAMP>.  The fourth version assigns elements from the array pointed to by <SAMP>s</SAMP> up to, but not including, a <SAMP>traits::eos()</SAMP> character.  The fifth assigns one or <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>.  The last variation assigns the members specified by the range <SAMP>[first, last)</SAMP>. </P>
<P>All functions will throw a <SAMP>length_error</SAMP>  exception if the resulting length will exceed <SAMP>max_size()</SAMP>. All return a reference to this string after completion.</P>
</UL>
<PRE>const_reference 
<B>at</B> (size_type pos) const;
reference 
<B>at</B> (size_type pos);</PRE>
<UL><P>If <SAMP>pos &#60; size()</SAMP>, returns the element at position <SAMP>pos</SAMP> in this string.  Otherwise, an <SAMP>out_of_range</SAMP> exception is thrown.</P>
</UL>
<PRE>size_type 
<B>capacity</B> () const;</PRE>
<UL><P>Returns the current storage capacity of the string. This is guaranteed to be at least as large as <SAMP>size()</SAMP>.</P>
</UL>
<PRE>int 
<B>compare</B> (const basic_string&#38; str);</PRE>
<UL><P>Returns the result of a lexographical comparison between elements of this string and elements of <SAMP>str</SAMP>.  The return value is:  </P>
<PRE>&#60;0     if size() &#60; str.size()</PRE>
<PRE>0     if size() == str.size()
>0     if size() > str.size()
</PRE></UL>
<PRE>int
<B>compare</B> (size_type pos1, size_type n1, 
         const basic_string&#38; str) const;
int
<B>compare</B> (size_type pos1, size_type n1, const basic_string&#38; str,
         size_type pos2, size_type n2) const;
int 
<B>compare</B> (charT* s) const;
int
<B>compare</B> (size_type pos, size_type n1, charT* s) const;
int
<B>compare</B> (size_type pos, size_type n1, charT* s, 
         size_type n2) const;</PRE>
<UL><P>Return the result of a lexographical comparison between elements of this string and a given comparison string. The members return, respectively:</P>
<PRE>compare (str)</PRE>
<PRE>compare (basic_string (str, pos2, n2))
compare (basic_string(s))
compare (basic_string(s, npos))
compare (basic_string (s,n2))
</PRE></UL>
<PRE>size_type 
<B>copy</B> (charT* s, size_type n,  size_type pos = 0) const;</PRE>
<UL><P>Replaces elements in memory with copies of elements from this string.  An <SAMP>out_of_range</SAMP> exception will be thrown if <SAMP>pos > size()</SAMP>.  The lesser of <SAMP>n</SAMP> and <SAMP>size() - pos</SAMP>  elements of this string, starting at position <SAMP>pos</SAMP> are copied into the array pointed to by <SAMP>s</SAMP>.  No terminating null is appended to <SAMP>s</SAMP>.</P>
</UL>
<PRE>const charT* 
<B>c_str</B> () const;
const charT* 
<B>data</B> () const;</PRE>
<UL><P>Return a pointer to the initial element of an array whose first <SAMP>size()</SAMP> elements are copies of the elements in this string.  A <SAMP>traits::eos()</SAMP> element is appended to the end.  The elements of the array may not be altered, and the returned pointer is only valid until a non-<SAMP>const</SAMP> member function of this string is called. If <SAMP>size()</SAMP> is zero, the <SAMP>data()</SAMP> function returns a <SAMP>NULL</SAMP> pointer.</P>
</UL>
<PRE>bool <B>empty</B> () const;</PRE>
<UL><P>Returns <SAMP>size() == 0</SAMP>.</P>
</UL>
<PRE>basic_string&#38; 
<B>erase</B> (size_type pos = 0, size_type n = npos);
iterator 
<B>erase</B> (iterator p);
iterator 
<B>erase</B> (iterator first, iterator last);</PRE>
<UL><P>This function removes elements from the string, collapsing the remaining elements, as necessary, to remove any space left empty.  The first version of the function removes the smaller of <SAMP>n</SAMP> and<SAMP> size() - pos </SAMP> starting  at position <SAMP>pos</SAMP>.  An <SAMP>out_of_range </SAMP>exception will be thrown if <SAMP> pos >  size()</SAMP>.  The  second version requires  that <SAMP>p</SAMP> is a valid iterator on this string, and removes the character referred to by <SAMP>p</SAMP>. The last version of <SAMP>erase</SAMP> requires that both <SAMP>first</SAMP> and <SAMP>last</SAMP> are valid iterators on this string, and removes the characters defined by the range <SAMP>[first, last)</SAMP>.  The destructors for all removed characters are called.   All versions of <SAMP>erase</SAMP> return a reference to this string after completion.</P>
</UL>
<PRE>size_type 
<B>find</B> (const basic_string&#38; str, size_type pos = 0) const;</PRE>
<UL><P>Searches for the first occurance of the substring specified by <SAMP>str</SAMP> in this string, starting at position <SAMP>pos</SAMP>.  If found, it returns the index of the first character of the matching substring.  If not found, returns <SAMP>npos</SAMP>. Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>
<PRE>size_type
<B>find</B> (const charT* s, size_type pos, size_type n) const;
size_type 
<B>find</B> (const charT* s, size_type pos = 0) const;
size_type 
<B>find</B> (charT c, size_type pos = 0) const;</PRE>
<UL><P>Search for the first sequence of characters in this string that match a specified string.  The variations of this function return, respectively:</P>
<PRE>find(basic_string(s,n), pos)</PRE>
<PRE>find(basic_string(s), pos)
find(basic_string(1, c), pos)</PRE></UL>
<PRE>size_type
<B>find_first_not_of</B> (const basic_string&#38; str,
                   size_type pos = 0) const;</PRE>
<UL><P>Searches for the first element of this string at or after position <SAMP>pos</SAMP> that is not equal to any element of <SAMP>str</SAMP>.  If found, <SAMP>find_first_not_of</SAMP> returns the index of the non-matching character. If all of the characters match, the function returns <SAMP>npos</SAMP>.  Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>
<PRE>size_type 
<B>find_first_not_of </B> (const charT* s, 
                    size_type pos, size_type n) const;
size_type 
<B>find_first_not_of </B>(const charT* s, 
                   size_type pos = 0) const;
size_type 
<B>find_first_not_of</B> (charT c, size_type pos = 0) const;</PRE>
<UL><P>Search for the first element in this string at or after position <SAMP>pos</SAMP> that is not equal to any element of a given set of characters.  The members return, respectively:</P>
<PRE>find_first_not_of(basic_string(s,n), pos)</PRE>
<PRE>find_first_not_of(basic_string(s), pos)
find_first_not_of(basic_string(1, c), pos)</PRE></UL>
<PRE>size_type
<B>find_first_of</B> (const basic_string&#38; str,
               size_type pos = 0) const;</PRE>
<UL><P>Searches for the first occurence at or after position <SAMP>pos</SAMP> of any element of <SAMP>str</SAMP> in this string.  If found, the index of this matching character is  returned.  If not found, <SAMP>npos</SAMP> is returned.  Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>
<PRE>size_type 
<B>find_first_of </B>(const charT*  s,  size_type  pos,
               size_type n) const;
size_type 
<B>find_first_of </B>(const charT* s, size_type pos = 0) const;
size_type
<B>find_first_of </B> (charT c, size_type pos = 0) const;</PRE>
<UL><P>Search for the first occurence in this  string of any element in a specified string.  The <SAMP>find_first_of</SAMP> variations return, respectively:</P>
<PRE>find_first_of(basic_string(s,n), pos)</PRE>
<PRE>find_first_of(basic_string(s), pos)
find_first_of(basic_string(1, c), pos)</PRE></UL>
<PRE>size_type 
<B>find_last_not_of</B> (const basic_string&#38; str,
                  size_type pos = npos) const;</PRE>
<UL><P>Searches for the last element of this string at or before position <SAMP>pos</SAMP> that is not equal to any element of <SAMP>str</SAMP>.  If <SAMP>find_last_not_of</SAMP> finds a non-matching element, it returns the index of the character.  If all the elements match, the function returns <SAMP>npos</SAMP>.  Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>
<PRE>size_type 
<B>find_last_not_of </B>(const charT* s,
                  size_type pos, size_type n) const;
size_type 
<B>find_last_not_of</B> (const charT* s, size_type pos = npos) const;
size_type 
<B>find_last_not_of </B>(charT c, size_type pos = npos) const;</PRE>
<UL><P>Search for the last element in this string at or  before position <SAMP>pos</SAMP> that is not equal to any element of a given set of characters.  The members return, respectively:</P>
<PRE>find_last_not_of(basic_string(s,n), pos)</PRE>
<PRE>find_last_not_of(basic_string(s), pos)
find_last_not_of(basic_string(1, c), pos)</PRE></UL>
<PRE>size_type 
<B>find_last_of </B>(const basic_string&#38; str,
              size_type pos = npos) const; </PRE>
<UL><P>Searches for the last occurence of any element of <SAMP>str</SAMP> at or before position <SAMP>pos</SAMP> in this string.  If found, <SAMP>find_last_of</SAMP> returns the index of the matching character.  If not found <SAMP>find_last_of</SAMP> returns <SAMP>npos</SAMP>.  Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>
<PRE>size_type
<B>find_last_of</B> (const charT* s, size_type pos,
              size_type n) const;
size_type 
<B>find_last_of</B> (const charT* s, size_type pos = npos) const;
size_type 
<B>find_last_of</B> (charT c, size_type pos = npos) const;</PRE>
<UL><P>Search for the last occurence in this string of any element in a specified string.  The members return, respectively:</P>
<PRE>find_last_of(basic_string(s,n), pos)</PRE>
<PRE>find_last_of(basic_string(s), pos)
find_last_of(basic_string(1, c), pos)</PRE></UL>
<PRE>basic_string&#38;
<B>insert</B> (size_type pos1, const basic_string&#38; s);
basic_string&#38; 
<B>insert</B> (size_type pos, const  basic_string&#38; s,
        size_type pos2 = 0, size_type n = npos);
basic_string&#38;
<B>insert</B> (size_type pos, const charT* s, size_type n);
basic_string&#38;
<B>insert</B> (size_type pos, const charT* s);
basic_string&#38; 
<B>insert</B> (size_type pos, size_type n, charT c);</PRE>
<UL><P>Insert additional elements at position <SAMP>pos</SAMP> in this string.  All of the variants of this function will throw an <SAMP>out_of_range</SAMP> exception if <SAMP>pos > size()</SAMP>.  All variants will also throw a <SAMP>length_error</SAMP> if the resulting string will exceed <SAMP>max_size()</SAMP>.  Elements of this string will be moved apart as necessary to accommodate the inserted elements.  All return a reference to this string after completion.</P>
<P>The second variation of this function inserts the lesser of <SAMP>n</SAMP> and <SAMP>s.size() - pos2</SAMP> characters of <SAMP>s</SAMP>, beginning at position <SAMP>pos2</SAMP> in this string.  This version will throw an <SAMP>out_of_range</SAMP> exception if  <SAMP>pos2  >  s.size()</SAMP>.  The third version inserts <SAMP>n</SAMP> characters of the array pointed to by <SAMP>s</SAMP>.  The fourth inserts elements from the array pointed to by <SAMP>s</SAMP> up to, but not including, a <SAMP>traits::eos()</SAMP>  character.  Finally, the fifth variation inserts <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>.</P>
</UL>
<PRE>iterator 
<B>insert</B> (iterator p, charT c = charT());
void 
<B>insert</B> (iterator p, size_type n, charT c);
template&#60;class InputIterator>
void
<B>insert</B> (iterator p, InputIterator first, InputIterator last);</PRE>
<UL><P>Insert additional elements in this  string  immediately before the character referred to by <SAMP>p</SAMP>.  All of these versions of <SAMP>insert</SAMP> require that <SAMP>p</SAMP> is a valid  iterator on this string.   The first version inserts a copy of <SAMP>c</SAMP>.  The second version inserts <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>.   The third version inserts characters in the range <SAMP>[first, last).</SAMP>  The first version returns <SAMP>p</SAMP>.</P>
</UL>
<PRE>size_type 
<B>length</B> () const;</PRE>
<UL><P>Return the number of elements contained in this string.</P>
</UL>
<PRE>size_type 
<B>max_size</B> () const;</PRE>
<UL><P>Returns the maximum possible size of the string.</P>
</UL>
<PRE>size_type 
<B>rfind</B> (const basic_string&#38; str, size_type pos  = npos) const;</PRE>
<UL><P>Searches for the last occurrence of the substring  specified by <SAMP>str</SAMP> in this string, starting at position <SAMP>pos</SAMP>. Note that only the first character of the substring must be <SAMP>&#60;= pos;</SAMP> the remaining characters may extend beyond <SAMP>pos</SAMP>. If found, the index of the first character of that matches substring is returned.  If not found, <SAMP>npos</SAMP> is returned.  Equality is defined by <SAMP>traits::eq()</SAMP>.</P>
</UL>
<PRE>size_type 
<B>rfind</B> (const charT* s, size_type pos,  size_type n) const;
size_type 
<B>rfind</B> (const charT* s, size_type pos = npos) const;
size_type 
<B>rfind</B> (charT c, size_type pos = npos) const;</PRE>
<UL><P>Searches for the last sequence of characters in this string matching a specified string.  The <SAMP>rfind</SAMP> variations return, respectively:</P>
<PRE>rfind(basic_string(s,n), pos)</PRE>
<PRE>rfind(basic_string(s), pos)
rfind(basic_string(1, c), pos)</PRE></UL>
<PRE>basic_string&#38;
<B>replace</B> (size_type pos, size_type n1, const basic_string&#38; s);
basic_string&#38; 
<B>replace</B> (size_type pos1, size_type n1, const basic_string&#38; str,
         size_type pos2, size_type n2);
basic_string&#38; 
<B>replace</B> (size_type pos, size_type n1, const charT* s,
         size_type n2);
basic_string&#38; 
<B>replace</B> (size_type pos, size_type n1, const charT* s);
basic_string&#38; 
<B>replace</B> (size_type pos, size_type n1, size_type n2, charT c);</PRE>
<UL><P>The <SAMP>replace</SAMP> function replaces selected elements of this string with an alternate set of elements.  All of these versions insert the new elements in place of <SAMP>n1</SAMP> elements in this string, starting at position <SAMP>pos</SAMP>.  They each throw an <SAMP>out_of_range</SAMP> exception if <SAMP>pos1 > size()</SAMP>and a <SAMP>length_error</SAMP> exception if the resulting string size exceeds <SAMP>max_size()</SAMP>.</P>
<P>The second version replaces elements of the original string with <SAMP>n2</SAMP> characters from string <SAMP>s</SAMP> starting at position <SAMP>pos2</SAMP>.  It will throw the <SAMP>out_of_range</SAMP> exception if <SAMP>pos2 > s.size().</SAMP>  The third variation of the function replaces elements in the original string with <SAMP>n2</SAMP> elements from the array pointed to by <SAMP>s</SAMP>.  The fourth version replaces elements in the string with elements from the array pointed to by <SAMP>s</SAMP>, up to, but not including, a <SAMP>traits::eos()</SAMP> character.  The fifth replaces <SAMP>n</SAMP> elements with <SAMP>n2</SAMP> repetitions of character <SAMP>c</SAMP>.</P>
</UL>
<PRE>basic_string&#38; 
<B>replace</B> (iterator i1, iterator i2, 
         const basic_string&#38; str);
basic_string&#38; 
<B>replace</B> (iterator i1, iterator i2, const charT* s,
         size_type n);
basic_string&#38; 
<B>replace</B> (iterator i1, iterator i2, const charT* s);
basic_string&#38;  
<B>replace</B> (iterator i1, iterator i2, size_type n,
         charT c);
template&#60;class InputIterator>
basic_string&#38;  
<B>replace</B> (iterator  i1,  iterator  i2,
         InputIterator j1, InputIterator j2);</PRE>
<UL><P>Replace selected elements of this string with an alternative set of elements.  All of these versions of <SAMP>replace</SAMP> require iterators <SAMP>i1</SAMP> and <SAMP>i2</SAMP> to be valid iterators on this string.  The elements specified by the range <SAMP>[i1, i2)</SAMP> are replaced by the new elements.</P>
<P>The first version shown here replaces with all members in <SAMP>str</SAMP>.  The second version starts at position <SAMP>i1</SAMP>, and replaces the next  <SAMP>n</SAMP> characters with <SAMP>n</SAMP> characters of the array pointed to by <SAMP>s</SAMP>.  The third variation replaces string elements with elements from the array pointed to by <SAMP>s</SAMP> up to, but not including, a<SAMP> traits::eos()</SAMP> character.  The fourth version replaces string elements with <SAMP>n</SAMP> repetitions of <SAMP>c</SAMP>.  The last variation shown here replaces string elements with the members specified in the range <SAMP>[j1, j2)</SAMP>.</P>
</UL>
<PRE>void <B>reserve</B> (size_type res_arg);</PRE>
<UL><P>Assures that the storage capacity is at least <SAMP>res_arg</SAMP>.</P>
</UL>
<PRE>void
<B>resize</B> (size_type n, charT c);
void
<B>resize</B> (size_type n);</PRE>
<UL><P>Changes the capacity of this string to <SAMP>n</SAMP>.  If the new capacity is smaller than the current size of the string, then it is truncated.  If the capacity is larger, then the string is padded with <SAMP>c </SAMP>characters.  The latter <SAMP>resize</SAMP> member pads the string with default characters specified by  <SAMP>traits::eos()</SAMP>.</P>
</UL>
<PRE>size type
<B>size</B> () const;</PRE>
<UL><P>Return the number of elements contained in this string.</P>
</UL>
<PRE>basic_string 
<B>substr</B> (size_type pos = 0, size_type n = npos) const;</PRE>
<UL><P>Returns a string composed of copies of the lesser of <SAMP>n</SAMP> and <SAMP>size()</SAMP> characters in this string starting at index <SAMP>pos</SAMP>.  Throws an out_of_range exception if <SAMP>pos &#60;= size().</SAMP></P>
</UL>
<PRE>void 
<B>swap</B> (basic_string&#38; s);</PRE>
<UL><P>Swaps the contents of this string with the contents of <SAMP>s</SAMP>.</P>
</UL>
<A NAME="Non-member Operators"><H3>Non-member Operators</H3></A>
<PRE>template&#60;class charT, class traits, class Allocator>
basic_string  
<B>operator+ </B>(const basic_string&#38;  lhs, const basic_string&#38; rhs);</PRE>
<UL><P>Returns a string of length <SAMP>lhs.size()  +  rhs.size()</SAMP>, where the first <SAMP>lhs.size()</SAMP> elements are copies of the  elements of <SAMP>lhs</SAMP>, and the next <SAMP>rhs.size()</SAMP> elements are copies of the elements of <SAMP>rhs</SAMP>.</P>
</UL>
<PRE>template&#60;class charT, class traits, class Allocator>
basic_string
<B>operator+</B> (const charT* lhs, const basic_string&#38; rhs);
template&#60;class charT, class traits, class Allocator>
basic_string
<B>operator+</B> (charT lhs, const basic_string&#38; rhs);
template&#60;class charT, class traits, class Allocator>
basic_string  
<B>operator+ </B>(const basic_string&#38;  lhs, const charT* rhs);
template&#60;class charT, class traits, class Allocator>
basic_string 
<B>operator+ </B>(const basic_string&#38; lhs, charT rhs);</PRE>
<UL><P>Returns a string that represents the concatenation of two string-like entities.  These functions return, respectively:</P>
<PRE>basic_string(lhs) + rhs</PRE>
<PRE>basic_string(1, lhs) + rhs
lhs + basic_string(rhs)
lhs + basic_string(1, rhs)
</PRE></UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool  
<B>operator==</B> (const basic_string&#38; lhs, const basic_string&#38; rhs);</PRE>
<UL><P>Returns a boolean value of <SAMP>true</SAMP> if <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP> are equal, and <SAMP>false</SAMP> if they are not. Equality  is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool   
<B>operator==</B> (const charT* lhs, const basic_string&#38; rhs);
template&#60;class charT, class traits, class Allocator>
bool  
<B>operator==</B> (const basic_string&#38; lhs, const charT* rhs);</PRE>
<UL><P>Returns a boolean value indicating whether <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP> are equal.  Equality is defined by the <SAMP>compare()</SAMP>  member function.  These functions return, respectively:</P>
<PRE>basic_string(lhs) == rhs</PRE>
<PRE>lhs == basic_string(rhs)</PRE></UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool  
<B>operator!=</B>  (const basic_string&#38; lhs,
             const basic_string&#38; rhs);</PRE>
<UL><P>Returns a boolean value representing the inequality of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Inequality is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool 
<B>operator!=</B> (const charT* lhs, const basic_string&#38; rhs);
template&#60;class charT, class traits, class Allocator>
bool  
<B>operator!=</B> (const basic_string&#38; lhs, const charT* rhs);</PRE>
<UL><P>Returns a boolean value representing the inequality of  <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Inequality is defined by the <SAMP>compare()</SAMP>  member function.  The functions return, respectively:</P>
<PRE>basic_string(lhs) != rhs</PRE>
<PRE>lhs != basic_string(rhs)</PRE></UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool  
<B>operator&#60; </B>(const basic_string&#38; lhs, const basic_string&#38; rhs);</PRE>
<UL><P>Returns a boolean value representing the lexigraphical less-than relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Less-than is defined by the <SAMP>compare() </SAMP>member.</P>
</UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool 
<B>operator&#60;</B> (const charT* lhs, const basic_string&#38; rhs);
template&#60;class charT, class traits, class Allocator>
bool  
<B>operator&#60;</B> (const basic_string&#38; lhs, const charT* rhs);</PRE>
<UL><P>Returns a boolean value representing the lexigraphical less-than relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Less-than is defined by the<SAMP> compare() </SAMP>member function.  These functions return, respectively:</P>
<PRE>basic_string(lhs) &#60; rhs</PRE>
<PRE>lhs &#60; basic_string(rhs)</PRE></UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool  
<B>operator></B> (const basic_string&#38; lhs, const basic_string&#38; rhs);</PRE>
<UL><P>Returns a boolean value representing the lexigraphical greater-than relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Greater-than is defined by the<SAMP> compare()</SAMP> member function.</P>
</UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool 
<B>operator></B> (const charT* lhs, const basic_string&#38; rhs);
template&#60;class charT, class traits, class Allocator>
bool 
<B>operator></B> (const basic_string&#38; lhs, const charT* rhs);</PRE>
<UL><P>Returns a boolean value representing the lexigraphical greater-than relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Greater-than is defined by the <SAMP>compare()</SAMP> member.  The functions return, respectively:</P>
<PRE>basic_string(lhs) > rhs</PRE>
<PRE>lhs > basic_string(rhs)</PRE></UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool 
<B>operator&#60;=</B> (const basic_string&#38; lhs,
             const basic_string&#38; rhs);</PRE>
<UL><P>Returns a boolean value representing the lexigraphical less-than-or-equal relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Less-than-or-equal is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool   
<B>operator&#60;=</B> (const charT* lhs, const basic_string&#38; rhs);
template&#60;class charT, class traits, class Allocator>
bool  
<B>operator&#60;=</B> (const basic_string&#38; lhs, const charT* rhs);</PRE>
<UL><P>Returns a boolean value representing the lexigraphical less-than-or-equal relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Less-than-or-equal is defined by the <SAMP>compare()</SAMP> member function.  These functions return, respectively:</P>
<PRE>basic_string(lhs) &#60;= rhs</PRE>
<PRE>lhs &#60;= basic_string(rhs)</PRE></UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool  
<B>operator>= </B>(const basic_string&#38; lhs, const basic_string&#38; rhs);</PRE>
<UL><P>Returns a boolean value representing the lexigraphical greater-than-or-equal relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Greater-than-or-equal is defined by the <SAMP>compare()</SAMP> member function.</P>
</UL>
<PRE>template&#60;class charT, class traits, class Allocator>
bool 
<B>operator>= </B>(const charT* lhs, const basic_string&#38; rhs);
template&#60;class charT, class traits, class Allocator>
bool 
<B>operator>= </B>(const basic_string&#38; lhs, const charT* rhs);</PRE>
<UL><P>Returns a boolean value representing the lexigraphical  greater-than-or-equal  relationship of <SAMP>lhs</SAMP> and <SAMP>rhs</SAMP>.  Greater-than-or-equal is defined by the <SAMP>compare()</SAMP> member.  The functions return, respectively:</P>
<PRE>basic_string(lhs) >= rhs</PRE>
<PRE>lhs >= basic_string(rhs)</PRE></UL>
<PRE>template&#60;class charT, class traits, class Allocator>
istream&#38;
<B>operator>></B> (istream&#38; is, basic_string&#38; str);</PRE>
<UL><P>Reads<SAMP> str</SAMP>  from  <SAMP>is</SAMP> using <SAMP>traits::char_in</SAMP> until a <SAMP>traits::is_del()</SAMP> element  is read.  All elements read, except the delimiter, are placed in <SAMP>str</SAMP>.  After the read, the function returns <SAMP>is</SAMP>.</P>
</UL>
<PRE>template&#60;class charT, class traits, class Allocator>
ostream&#38;
<B>operator&#60;&#60; </B>(ostream&#38; os, const basic_string&#38; str);</PRE>
<UL><P>Writes all elements of <SAMP>str</SAMP> to <SAMP>os</SAMP> in order from first to last, using <SAMP>traits::char_out()</SAMP>.  After the write, the function returns <SAMP>os</SAMP>.</P>
</UL>
<A NAME="Non-member Function"><H3>Non-member Function</H3></A>
<PRE>template &#60;class Stream, class charT, class traits,
          class Allocator>
Stream&#38; 
<B>getline</B> (Stream&#38; is, basic_string&#38; str, charT delim);</PRE>
<UL><P>An unformatted input function that extracts characters from <SAMP>is</SAMP> into <SAMP>str</SAMP> until <SAMP>npos - 1</SAMP> characters are read, the end of the input sequence is reached, or the character read is <SAMP>delim</SAMP>.  The characters are read using <SAMP>traits::char_in()</SAMP>. </P>
</UL>
<A NAME="Example"><H3>Example</H3></A>
<PRE>//
// string.cpp
//
 #include&#60;string>
 #include &#60;iostream.h>
 int main()
 {
   string test;
   //Type in a string over five characters long
   while(test.empty() ||  test.size() &#60;= 5)
   {
     cout &#60;&#60; "Type a string between 5 and 100 characters long. "
          &#60;&#60; endl;
     cin >> test;
   }
   //Test operator[] access
   cout &#60;&#60; "Changing the third character from " &#60;&#60; test[2] &#60;&#60; 
           " to * " &#60;&#60; endl;
   test[2] = '*';
   cout &#60;&#60; "now its: " &#60;&#60; test &#60;&#60; endl &#60;&#60; endl;
   //Try the insertion member function
   cout &#60;&#60; "Identifying the middle: ";
   test.insert(test.size() / 2, "(the middle is here!)");
   cout &#60;&#60; test &#60;&#60; endl &#60;&#60; endl;
   //Try replacement
   cout &#60;&#60; "I didn't like the word 'middle',so instead,I'll say:"            &#60;&#60; endl;</PRE>
<PRE>   test.replace(test.find("middle",0), 6, "center");
   cout &#60;&#60; test &#60;&#60; endl; 
   return 0;
 }
Output :
Type a string between 5 and 100 characters long.
roguewave
Changing the third character from g to *
now its: ro*uewave
Identifying the middle: ro*u(the middle is here!)ewave
I didn't like the word 'middle', so instead, I'll say:
ro*u(the center is here!)ewave</PRE>
<A NAME="See Also"><H3>See Also</H3></A>
<P><A HREF="all_7029.htm"><B><I>allocator</B></I></A></P>
<HR>
<A HREF="bac_0189.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="Bid_7861.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
