<HTML><TITLE>pair</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>pair</H2>
<HR><PRE>     Utility Class</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A template for heterogenous pairs of values.</P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Interface"><LI>Interface</LI></A>
<A HREF="#Constructors and Destructors"><LI>Constructors and Destructors</LI></A>
<A HREF="#Non-member Operators"><LI>Non-member Operators</LI></A>
<A HREF="#Non-member Functions"><LI>Non-member Functions</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;utility>
template &#60;class T1, class T2>
struct <B>pair</B> ;</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P>The <B><I>pair</B></I> class provides a template for encapsulating pairs of values that may be of different types.</P>
<A NAME="Interface"><H3>Interface</H3></A>
<PRE>template &#60;class T1, class T2></PRE>
<PRE> struct pair {
        T1 first;
        T2 second;
        pair();
        pair (const T1&#38;, const T2&#38;);
        ~pair();
};
template &#60;class T1, class T2>
 bool operator== (const pair&#60;T1, T2>&#38;,
                  const pair T1, T2>&#38;);
template &#60;class T1, class T2>
 bool operator&#60; (const pair&#60;T1, T2>&#38;,
                 const pair T1, T2>&#38;);
template &#60;class T1, class T2>
 pair&#60;T1,T2> make_pair (const T1&#38;, const T2&#38;);
</PRE>
<A NAME="Constructors and Destructors"><H3>Constructors and Destructors</H3></A>
<PRE><B>pair </B>();</PRE>
<UL><P>Default contructor.  Initializes <SAMP>first</SAMP> and <SAMP>second</SAMP> using their default constructors.</P>
</UL>
<PRE><B>pair</B> (const T1&#38; x, const T2&#38; y);</PRE>
<UL><P>The constructor creates a pair of types <SAMP>T1</SAMP> and <SAMP>T2</SAMP>, making the necessary conversions in<SAMP> x</SAMP> and <SAMP>y</SAMP>.</P>
</UL>
<PRE><B>~pair</B> ();</PRE>
<UL><P>Destructor.</P>
</UL>
<A NAME="Non-member Operators"><H3>Non-member Operators</H3></A>
<PRE>template &#60;class T1, class T2>
bool <B>operator==</B> (const pair&#60;T1, T2>&#38; x,
                  const pair T1, T2>&#38; y);</PRE>
<UL><P>Returns <SAMP>true</SAMP> if <SAMP>(x.first == y.first &#38;&#38; x.second == y.second</SAMP>) is <SAMP>true</SAMP>. Otherwise it returns <SAMP>false</SAMP>.</P>
</UL>
<PRE>template &#60;class T1, class T2>
bool <B>operator&#60;</B> (const pair&#60;T1, T2>&#38; x,
                const pair T1, T2>&#38; y);</PRE>
<UL><P>Returns <SAMP>true</SAMP> if <SAMP>(x.first &#60; y.first || (!(y.first &#60; x.first) &#38;&#38; x.second &#60; y.second))</SAMP> is <SAMP>true</SAMP>.  Otherwise it  returns <SAMP>false</SAMP>.</P>
</UL>
<A NAME="Non-member Functions"><H3>Non-member Functions</H3></A>
<PRE>template &#60;class T1, class T2>
pair&#60;T1,T2>
<B>make_pair</B>(x,y);</PRE>
<UL><P><SAMP>make_pair(x,y)</SAMP> creates a pair by deducing and returning the types of <SAMP>x</SAMP> and <SAMP>y</SAMP>.</P>
</UL>
<HR>
<A HREF="Out_3702.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="par_4963.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
