<HTML><TITLE>unary_negate</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>unary_negate</H2>
<HR><PRE>     Function Adaptor (Negator)</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>Function object that returns the complement of the result of its unary predicate </P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Interface"><LI>Interface</LI></A>
<A HREF="#Constructor"><LI>Constructor</LI></A>
<A HREF="#Operator"><LI>Operator</LI></A>
<A HREF="#See Also"><LI>See Also</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include&#60;functional></PRE>
<PRE>
template &#60;class Predicate>
class <B>unary_negate</B> : public unary_function&#60;typename  
                                           Predicate::argument_type,
                                           bool>;
</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P><B><I>unary_negate</B></I> is a function object class that provides a return type for the function adaptor <A HREF="not_6483.htm"><B><I>not1</B></I></A>.  <B><I>not1</B></I> is a function adaptor, known as a negator, that takes a unary predicate function object as its argument and returns a unary predicate function object that is the complement of the original. </P>
<P>Note that <A HREF="not_6483.htm"><B><I>not1</B></I></A> works only with function objects that are defined as subclasses of the class <A HREF="una_4659.htm"><B><I>unary_function</B></I></A>.</P>
<A NAME="Interface"><H3>Interface</H3></A>
<PRE>template &#60;class Predicate>
class unary_negate
  : public unary_function&#60;Predicate::argument_type, bool> {
  typedef typename unary_function&#60;typename
    Predicate::argument_type,bool>::argument_type argument_type;
  typedef typename unary_function&#60;typename 
    Predicate::argument_type,bool>::result_type result_type;
public:
   explicit unary_negate (const Predicate&#38;);
   bool operator() (const argument_type&#38;) const;
};
template&#60;class Predicate>
unary_negate &#60;Predicate> not1 (const Predicate&#38;);
</PRE>
<A NAME="Constructor"><H3>Constructor</H3></A>
<PRE>explicit<B> unary_negate </B>(const Predicate&#38; pred);</PRE>
<UL><P>Construct a <SAMP>unary_negate</SAMP> object from predicate <SAMP>pred</SAMP>.</P>
</UL>
<A NAME="Operator"><H3>Operator</H3></A>
<PRE>bool <B>operator()</B> (const argument_type&#38; x) const;</PRE>
<UL><P>Return the result of <SAMP>pred(x)</SAMP></P>
</UL>
<A NAME="See Also"><H3>See Also</H3></A>
<P><A HREF="not_6483.htm"><B><I>not1</B></I></A>, <A HREF="not_2978.htm"><B><I>not2</B></I></A>, <A HREF="una_4659.htm"><B><I>unary_function</B></I></A>, <A HREF="bin_1825.htm"><B><I>binary_negate</B></I></A></P>
<HR>
<A HREF="una_4659.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="uni_4265.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
