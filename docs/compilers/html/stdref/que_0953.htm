<HTML><TITLE>queue</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>queue</H2>
<HR><PRE>     Container Adaptor</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A container adaptor that behaves like a queue (first in, first out).</P>
<PRE></PRE>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Interface"><LI>Interface</LI></A>
<A HREF="#Constructors "><LI>Constructors </LI></A>
<A HREF="#Allocator"><LI>Allocator</LI></A>
<A HREF="#Member Functions"><LI>Member Functions</LI></A>
<A HREF="#Non-member Operators"><LI>Non-member Operators</LI></A>
<A HREF="#Example"><LI>Example</LI></A>
<A HREF="#Warnings"><LI>Warnings</LI></A>
<A HREF="#See Also"><LI>See Also</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;queue></PRE>
<PRE>
template &#60;class T, class Container = deque&#60;T>, 
          class Allocator = allocator> class <B>queue</B> ;
</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P>The <B><I>queue</B></I> container adaptor lets a container function as a queue.  In a queue, items are pushed into the back of the container and removed from the front.  The first items pushed into the queue are the first items to be popped off of the queue (first in, first out, or "FIFO"). </P>
<P><B><I>queue</B></I> can adapt any container that supports the <SAMP>front()</SAMP>, <SAMP>back()</SAMP>, <SAMP>push_back()</SAMP> and <SAMP>pop_front()</SAMP> operations.  In particular, <A HREF="deq_4164.htm"><B><I>deque</B></I></A>, <A HREF="lis_3222.htm"><B><I>list</B></I></A>, and <A HREF="vec_0251.htm"><B><I>vector</B></I></A>  can be used. </P>
<A NAME="Interface"><H3>Interface</H3></A>
<PRE>template &#60;class T, class Container = deque&#60;T>,
     class Allocator = allocator>
 class queue {
public:
// typedefs
   typedef typename Container::value_type value_type;
   typedef typename Container::size_type size_type;
   typedef Allocator allocator_type;
// Construct/Copy/Destroy
   explicit queue (const Allocator&#38; = Allocator());
   allocator_type get_allocator () const;
// Accessors
   bool empty () const;
   size_type size () const;
   value_type&#38; front ();
   const value_type&#38; front () const;
   value_type&#38; back ();
   const value_type&#38; back () const;
   void push (const value_type&#38;);
   void pop ();
};
// Non-member Operators
template &#60;class T, class Container, class Allocator>
 bool operator== (const queue&#60;T, Container, Allocator>&#38;,
                  const queue&#60;T, Container, Allocator>&#38;);
template &#60;class T, class Container, class Allocator>
 bool operator&#60; (const queue&#60;T, Container, Allocator>&#38;,
                 const queue&#60;T, Container, Allocator>&#38;);
</PRE>
<A NAME="Constructors "><H3>Constructors </H3></A>
<PRE>explicit <B>queue</B> (const Allocator&#38; alloc= Allocator());</PRE>
<UL><P>Creates a queue of zero elements.  The queue will use the allocator <SAMP>alloc</SAMP> for all storage management.</P>
</UL>
<A NAME="Allocator"><H3>Allocator</H3></A>
<PRE>allocator_type <B>get_allocator</B> () const;</PRE>
<UL><P>Returns a copy of the allocator used by self for storage management.</P>
</UL>
<A NAME="Member Functions"><H3>Member Functions</H3></A>
<PRE>value_type&#38; 
<B>back</B> ();</PRE>
<UL><P>Returns a reference to the item at the back of the queue (the last item pushed into the queue).</P>
</UL>
<PRE>const value_type&#38; 
<B>back</B>() const;</PRE>
<UL><P>Returns a constant reference to the item at the back of the queue as a <SAMP>const_value_type</SAMP>.</P>
</UL>
<PRE>bool 
<B>empty</B> () const;</PRE>
<UL><P>Returns <SAMP>true</SAMP> if the queue is empty, otherwise <SAMP>false</SAMP>.</P>
</UL>
<PRE>value_type&#38; 
<B>front</B> ();</PRE>
<UL><P>Returns a reference to the item at the front of the queue.  This will be the first item pushed onto the queue unless <SAMP>pop()</SAMP> has been called since then.</P>
</UL>
<PRE>const value_type&#38; 
<B>front</B> () const;</PRE>
<UL><P>Returns a constant reference to  the item at the front of the queue as  a <SAMP>const_value_type</SAMP>.</P>
</UL>
<PRE>void 
<B>pop</B> ();</PRE>
<UL><P>Removes the item at the front of the queue.</P>
</UL>
<PRE>void 
<B>push</B> (const value_type&#38; x);</PRE>
<UL><P>Pushes <SAMP>x</SAMP> onto the back of the queue.</P>
</UL>
<PRE>size_type 
<B>size</B> () const;</PRE>
<UL><P>Returns the number of elements on the queue.</P>
</UL>
<A NAME="Non-member Operators"><H3>Non-member Operators</H3></A>
<PRE>template &#60;class T, class Container, class Allocator>
  bool <B>operator==</B> (const queue&#60;T, Container, Allocator>&#38; x,
                   const queue&#60;T, Container, Allocator>&#38; y);</PRE>
<UL><P>   Equality operator.  Returns <SAMP>true</SAMP> if <SAMP>x</SAMP> is the same as <SAMP>y</SAMP>.</P>
<PRE></PRE>
</UL>
<PRE>template &#60;class T, class Container, class Allocator>
  bool <B>operator&#60;</B> (const queue&#60;T, Container, Allocator>&#38; x,
                  const queue&#60;T, Container, Allocator>&#38; y);</PRE>
<UL><P>Returns <SAMP>true</SAMP> if the queue defined by the elements contained in <SAMP>x</SAMP> is    lexicographically less than the queue defined by the elements contained in <SAMP>y</SAMP>.</P>
</UL>
<A NAME="Example"><H3>Example</H3></A>
<PRE>//
// queue.cpp
//
 #include &#60;queue>
 #include &#60;string>
 #include &#60;deque>
 #include &#60;list>
 #include &#60;iostream.h>
 int main(void)
 {
   // Make a queue using a list container
   <B>queue</B>&#60;int, list&#60;int>, allocator> q;
   // Push a couple of values on then pop them off 
   q.push(1);
   q.push(2);
   cout &#60;&#60; q.front() &#60;&#60; endl;
   q.pop();
   cout &#60;&#60; q.front() &#60;&#60; endl;
   q.pop();
   // Make a queue of strings using a deque container
   <B>queue</B>&#60;string,deque&#60;string>, allocator> qs;
   // Push on a few strings then pop them back off
   int i;
   for (i = 0; i &#60; 10; i++)
   {
     qs.push(string(i+1,'a'));
     cout &#60;&#60; qs.front() &#60;&#60; endl;
   }
   for (i = 0; i &#60; 10; i++)
   {
     cout &#60;&#60; qs.front() &#60;&#60; endl;
     qs.pop();
   }
   return 0;
 }
Output :
1
2
a
a
a
a
a
a
a
a
a
a
a
aa
aaa
aaaa
aaaaa
aaaaaa
aaaaaaa
aaaaaaaa
aaaaaaaaa
aaaaaaaaaa
</PRE>
<A NAME="Warnings"><H3>Warnings</H3></A>
<P>If your compiler does not support default template  parameters, you must always provide a <SAMP>Container</SAMP> template parameter and an <SAMP>Allocator</SAMP>   template   parameter.  For  example you would not be able to write:</P>
<PRE>queue&#60;int> var;</PRE>
<PRE></PRE><P>rather, you would have to write,</P>
<PRE>queue&#60;int, deque&#60;int>, allocator> var;</PRE>
<PRE></PRE>
<UL>
</UL>
<A NAME="See Also"><H3>See Also</H3></A>
<P><A HREF="all_7029.htm"><B><I>allocator</B></I></A>, <A HREF="Con_2487.htm"><B><I>Containers</B></I></A>, <A HREF="pri_2327.htm"><B><I>priority_queue</B></I></A></P>
<HR>
<A HREF="pus_5295.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="Ran_7047.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
