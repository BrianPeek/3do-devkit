<HTML><TITLE>binary_negate</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>binary_negate</H2>
<HR><PRE>     Function Object</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>Function object that returns the complement of the result of its binary predicate </P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Interface"><LI>Interface</LI></A>
<A HREF="#Constructor"><LI>Constructor</LI></A>
<A HREF="#Operator"><LI>Operator</LI></A>
<A HREF="#See Also"><LI>See Also</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;functional></PRE>
<PRE>
template&#60;class Predicate>
class binary_negate ;
</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P><B><I>binary_negate</B></I> is a function object class that provides a return type for the function adaptor <A HREF="not_2978.htm"><B><I>not2</B></I></A>.  <B><I>not2</B></I> is a function adaptor, known as a negator, that takes a binary predicate function object as its argument and returns a binary predicate function object that is the complement of the original. </P>
<P>Note that <A HREF="not_2978.htm"><B><I>not2</B></I></A> works only with function objects that are defined as subclasses of the class <A HREF="bin_7851.htm"><B><I>binary_function</B></I></A>.</P>
<A NAME="Interface"><H3>Interface</H3></A>
<PRE>template&#60;class Predicate></PRE>
<PRE>class binary_negate
  : public binary_function&#60;typename 
                          predicate::first_argument_type,
                          typename 
                          Predicate::second_argument_type,
                          bool>
{
public:
  typedef typename binary_function&#60;typename   
   Predicate::first_argument_type, typename         
   Predicate::second_argument_type, bool>::second_argument_type 
                                            second_argument_type;
  typedef typename binary_function&#60;typename           
   Predicate::first_argument_type, typename   
   Predicate::second_argument_type, bool>::first_argument_type       
                                           first_argument_type;
  typedef typename binary_function&#60;typename      
   Predicate::first_argument_type, typename      
   Predicate::second_argument_type, bool>::result_type 
                                           result_type;
  explicit binary_negate (const Predicate&#38;);
  bool operator() (const first_argument_type&#38;,
                   const second_argument_type&#38;) const;
};
// Non-member Functions
template &#60;class Predicate>
binary_negate&#60;Predicate> not2 (const Predicate&#38; pred);
</PRE>
<A NAME="Constructor"><H3>Constructor</H3></A>
<PRE>explicit <B>binary_negate</B> (const Predicate&#38; pred);</PRE>
<UL><P>Construct a binary_negate object from predicate <SAMP>pred</SAMP>.</P>
</UL>
<A NAME="Operator"><H3>Operator</H3></A>
<PRE>bool 
<B>operator() </B>(const first_argument_type&#38; x,
            const second_argument_type&#38; y) const;</PRE>
<UL><P>Return the result of <SAMP>pred(x,y)</SAMP></P>
</UL>
<A NAME="See Also"><H3>See Also</H3></A>
<P><A HREF="bin_7851.htm"><B><I>binary_function</B></I></A>, <A HREF="not_2978.htm"><B><I>not2</B></I></A>, <A HREF="una_8062.htm"><B><I>unary_negate</B></I></A></P>
<HR>
<A HREF="bin_7851.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="bin_2217.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
