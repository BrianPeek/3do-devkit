<HTML><TITLE>ptr_fun</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>ptr_fun</H2>
<HR><PRE>     Function Adaptor</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>A function that is overloaded to adapt a <I>pointer to a function </I>to work where a function is called for.</P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Example"><LI>Example</LI></A>
<A HREF="#Warning"><LI>Warning</LI></A>
<A HREF="#See Also"><LI>See Also</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;functional></PRE>
<PRE>
template&#60;class Arg, class Result>
pointer_to_unary_function&#60;Arg, Result>
  <B>ptr_fun</B> (Result (*f)(Arg));
template&#60;class Arg1, class Arg2, class Result>
pointer_to_binary_function&#60;Arg1, Arg2, Result>
  <B>ptr_fun</B> (Result (*x)(Arg1, Arg2));
</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P>The <A HREF="poi_7375.htm"><B><I>pointer_to_unary_function</B></I></A> and <A HREF="poi_3537.htm"><B><I>pointer_to_binary_function</B></I></A> classes encapsulate pointers to functions and provide an <SAMP>operator()</SAMP> so that the resulting object serves as a function object for the function.</P>
<P>The <SAMP>ptr_fun</SAMP> function is overloaded to create instances of <A HREF="poi_7375.htm"><B><I>pointer_to_unary_function</B></I></A> or <A HREF="poi_3537.htm"><B><I>pointer_to_binary_function</B></I></A> when provided with the appropriate pointer to a function. </P>
<A NAME="Example"><H3>Example</H3></A>
<PRE>//
// pnt2fnct.cpp
//
 #include &#60;functional>
 #include &#60;deque>
 #include &#60;vector>
 #include &#60;algorithm>
 #include &#60;iostream.h>
 //Create a function
 int factorial(int x)
 {
   int result = 1;
   for(int i = 2; i &#60;= x; i++)
       result *= i;
   return result;
 }
 int main()
 {
   //Initialize a deque with an array of ints
   int init[7] = {1,2,3,4,5,6,7};
   deque&#60;int> d(init, init+7);
   //Create an empty vector to store the factorials
   vector&#60;int> v((size_t)7);
   //Transform the numbers in the deque to their factorials and
   //store in the vector
   transform(d.begin(), d.end(), v.begin(), <B>ptr_fun</B>(factorial));
   //Print the results
   cout &#60;&#60; "The following numbers: " &#60;&#60; endl &#60;&#60; "     ";
   copy(d.begin(),d.end(),ostream_iterator&#60;int>(cout," "));
   cout &#60;&#60; endl &#60;&#60; endl;
   cout &#60;&#60; "Have the factorials: " &#60;&#60; endl &#60;&#60; "     ";
   copy(v.begin(),v.end(),ostream_iterator&#60;int>(cout," "));
   return 0;
 }
Output :
The following numbers:
     1 2 3 4 5 6 7
Have the factorials:
     1 2 6 24 120 720 5040</PRE>
<A NAME="Warning"><H3>Warning</H3></A>
<P>If your compiler does not support default template parameters, you need to always supply the <SAMP>Allocator</SAMP> template argument.  For instance, you will need to write :</P>
<P><SAMP>vector&#60;int, allocator></SAMP></P>
<P>instead of :</P>
<P><SAMP>vector&#60;int></SAMP></P>
<A NAME="See Also"><H3>See Also</H3></A>
<P><A HREF="Fun_7437.htm"><B><I>Function Objects</B></I></A>, <A HREF="poi_3537.htm"><B><I>pointer_to_binary_function</B></I></A>, <A HREF="poi_7375.htm"><B><I>pointer_to_unary_function</B></I></A></P>
<HR>
<A HREF="pri_2327.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="pus_5295.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
