<HTML><TITLE>search, search_n</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>search, search_n</H2>
<HR><PRE>     Algorithm</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>Finds a subsequence within a sequence of values that is element-wise equal to the values in an indicated range.</P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Complexity"><LI>Complexity</LI></A>
<A HREF="#Example"><LI>Example</LI></A>
<A HREF="#Warning"><LI>Warning</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;algorithm></PRE>
<PRE>
template &#60;class ForwardIterator1, class ForwardIterator2>
 ForwardIterator1 <B>search</B> (ForwardIterator1 first1,
                          ForwardIterator1 last1,
                          ForwardIterator2 first2,
                          ForwardIterator2 last2);
template &#60;class ForwardIterator1,
          class ForwardIterator2,
          class BinaryPredicate>
 ForwardIterator1 <B>search</B> (ForwardIterator1 first1,
                          ForwardIterator1 last1,
                          ForwardIterator2 first2,
                          ForwardIterator2 last2,
                          BinaryPredicate binary_pred);
template &#60;class ForwardIterator, 
          class Size, 
          class T>
ForwardIterator <B>search_n</B> (ForwardIterator first, 
                          ForwardIterator last,
                          Size count, const T&#38; value);
template &#60;class ForwardIterator, 
          class Size, 
          class T, 
          class BinaryPredicate>
ForwardIterator <B>search_n</B> (ForwardIterator first, 
                          ForwardIterator last,
                          Size count, const T&#38; value,
                          BinaryPredicate pred)
</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P>The <B><I>search</B></I> and <B><I>search_n</B></I> are used for searching for a subsequence within a sequence. The <B><I>search</B></I> algorithm searches for a subsequence <SAMP>[first2, last2) </SAMP>within a sequence <SAMP>[first1, last1)</SAMP>, and returns the beginning location of the subsequence.   If it does not find the subsequence, <B><I>search</B></I> returns <SAMP>last1</SAMP>. The first version of <B><I>search</B></I> uses the equality (<SAMP>==</SAMP>) operator as a default, and the second version allows you to specify a binary predicate to perform the comparison.</P>
<P>The <B><I>search_n </B></I> algorithm searches for the subsequence composed of <SAMP>count</SAMP> occurrences of <SAMP>value</SAMP> within a sequence <SAMP>[first, last)</SAMP>, and returns <SAMP>first</SAMP> if this subsequence is found.  If it does not find the subsequence, <B><I>search_n </B></I>returns <SAMP>last</SAMP>. The first version of <B><I>search_n</B></I> uses the equality (<SAMP>==</SAMP>) operator as a default, and the second version allows you to specify a binary predicate to perform the comparison.</P>
<A NAME="Complexity"><H3>Complexity</H3></A>
<P><B><I>search</B></I> performs at most <SAMP>(last1 - first1)*(last2-first2) </SAMP>applications of  the corresponding predicate.</P>
<P><B><I>search_n</B></I> performs at most<SAMP> (last - first)</SAMP> applications of the corresponding predicate.</P>
<A NAME="Example"><H3>Example</H3></A>
<PRE>//
// search.cpp
//
 #include &#60;algorithm>
 #include &#60;list>
 #include &#60;iostream.h>
 int main()
 {
   // Initialize a list sequence and 
   // subsequence with characters
   char seq[40] = "Here's a string with a substring in it";
   char subseq[10] = "substring";
   list&#60;char> sequence(seq, seq+39);
   list&#60;char> subseqnc(subseq, subseq+9);
   //Print out the original sequence
   cout &#60;&#60; endl &#60;&#60; "The subsequence, " &#60;&#60; subseq 
        &#60;&#60; ", was found at the ";
   cout &#60;&#60; endl &#60;&#60; "location identified by a '*'" 
        &#60;&#60; endl &#60;&#60; "     ";
   // Create an iterator to identify the location of 
   // subsequence within sequence
   list&#60;char>::iterator place;
   //Do search
   place = <B>search</B>(sequence.begin(), sequence.end(),
                  subseqnc.begin(), subseqnc.end());
   //Identify result by marking first character with a '*'
   *place = '*';
   //Output sequence to display result
   for(list&#60;char>::iterator i = sequence.begin(); 
           i != sequence.end(); i++)
     cout &#60;&#60; *i;
   cout &#60;&#60; endl;
   return 0;
 }
Output :
The subsequence, substring, was found at the
location identified by a '*'
     Here's a string with a *ubstring in it</PRE>
<A NAME="Warning"><H3>Warning</H3></A>
<P>If your compiler does not support default template parameters, then you need to always supply the <SAMP>Allocator</SAMP> template argument.  For instance, you will need to write :</P>
<P><SAMP>list&#60;char, allocator></SAMP></P>
<P>instead of :</P>
<P><SAMP>list&#60;char></SAMP></P>
<HR>
<A HREF="rot_3525.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="Seq_6405.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
