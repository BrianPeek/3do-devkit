<HTML><TITLE>reverse_bidirectional_iterator, reverse_iterator</TITLE><BODY>
<A HREF="ref.htm"><IMG SRC="images/banner.gif"></A>
<P><STRONG>Click on the banner to return to the Class Reference home page.</STRONG></P>
<P>&copy;Copyright 1996 Rogue Wave Software</P>
<H2>reverse_bidirectional_iterator, reverse_iterator</H2>
<HR><PRE>     Iterator</PRE><HR>
<A NAME="Summary"><H3>Summary</H3></A>
<P>An iterator that traverses a collection backwards.</P>
<H3>Contents</H3>
<UL>
<A HREF="#Synopsis"><LI>Synopsis</LI></A>
<A HREF="#Description"><LI>Description</LI></A>
<A HREF="#Complexity"><LI>Complexity</LI></A>
<A HREF="#Interface"><LI>Interface</LI></A>
<A HREF="#Example"><LI>Example</LI></A>
<A HREF="#Warning"><LI>Warning</LI></A>
<A HREF="#See Also"><LI>See Also</LI></A>
</UL>
<A NAME="Synopsis"><H3>Synopsis</H3></A>
<PRE>#include &#60;iterator></PRE>
<PRE>
template &#60;class BidirectionalIterator,
          class T,
          class Reference = T&#38;,
          class Pointer = T*
          class Distance = ptrdiff_t>
class <B>reverse_bidirectional_iterator</B> : public 
      bidirectional_iterator&#60;T, Distance> ;
template &#60;class RandomAccessIterator, 
          class T, 
          class Reference = T&#38;,
          class Pointer = T*, 
          class Distance = ptrdiff_t>  
class <B>reverse_iterator</B> : public random_access_iterator&#60;T, Distance>;</PRE>
<A NAME="Description"><H3>Description</H3></A>
<P>The iterators <B><I>reverse_iterator</B></I> and<B><I> reverse_bidirectional_iterator</B></I> correspond to <A HREF="Ran_7047.htm"><B><I>Random Access Iterators</B></I></A> and <A HREF="Bid_7861.htm"><B><I>Bidirectional Iterators</B></I></A>, except they traverse the collection they point to in the opposite direction.  The fundamental relationship between a reverse iterator and its corresponding iterator <SAMP>i</SAMP> is established by the identity: </P>
<PRE>&#38;*(reverse_iterator(i)) == &#38;*(i-1); </PRE>
<PRE></PRE><P>This mapping is dictated by the fact that, while there is always a pointer past the end of a container, there might not be a valid pointer before its beginning. </P>
<P>The following are true for <B><I>reverse_bidirectional_iterators</B></I> :</P>
<UL><LI><P>These iterators may be instantiated with the default constructor or by a single argument constructor that initializes the new <SAMP>reverse_bidirectional_iterator</SAMP> with a <SAMP>bidirectional_iterator</SAMP>.</P>
</LI>
<LI><P><SAMP>operator*</SAMP> returns a reference to the current value pointed to.</P>
</LI>
<LI><P><SAMP>operator++</SAMP> advances the iterator to the previous item (<SAMP>--current</SAMP>) and returns a reference to <SAMP>*this</SAMP>.</P>
</LI>
<LI><P><SAMP>operator++(int)</SAMP> advances the iterator to the  previous item (<SAMP>--current</SAMP>) and returns the old value of <SAMP>*this</SAMP>.</P>
</LI>
<LI><P><SAMP>operator--</SAMP> advances the iterator to the following item (<SAMP>++current</SAMP>) and returns a reference to <SAMP>*this</SAMP>.</P>
</LI>
<LI><P><SAMP>operator--(int)</SAMP> Advances the iterator to the following item (<SAMP>++current)</SAMP> and returns the old value of <SAMP>*this.</SAMP></P>
</LI>
<LI><P><SAMP>operator== </SAMP>This non-member operator returns <SAMP>true</SAMP> if the iterators <SAMP>x</SAMP> and <SAMP>y</SAMP> point to the same item.</P>
</LI>
</UL>
<P>The following are true for <B><I>reverse_iterators</B></I>:</P>
<UL>
<LI><P>These iterators may be instantiated with the default constructor or by a single argument constructor which initializes the new <SAMP>reverse_iterator</SAMP> with a <SAMP>random_access_iterator</SAMP>. </P>
<LI><P><SAMP>operator*</SAMP> returns a reference to the current value pointed to.</P>
<LI><P><SAMP>operator++</SAMP> advances the iterator to the previous item (<SAMP>--current</SAMP>) and returns a reference to <SAMP>*this</SAMP>.</P>
<LI><P><SAMP>operator++(int)</SAMP> advances the iterator to the previous item (<SAMP>--current</SAMP>) and returns the old value of <SAMP>*this</SAMP>.</P>
<LI><P><SAMP>operator--</SAMP> advances the iterator to the  following  item (<SAMP>++current</SAMP>) and returns a reference to <SAMP>*this</SAMP>.</P>
<LI><P><SAMP>operator--(int)</SAMP> advances the iterator to the following item (<SAMP>++current</SAMP>) and returns the old value of <SAMP>*this</SAMP>.</P>
<LI><P><SAMP>operator==</SAMP> is a non-member operator returns <SAMP>true</SAMP> if  the iterators <SAMP>x</SAMP> and <SAMP>y</SAMP> point to the same item.</P>
<LI><P>The remaining operators (<SAMP>&#60;, +, - , +=, -=</SAMP>) are redefined to behave exactly as they would in a <SAMP>random_access_iterator</SAMP>, except with the sense of  direction reversed.</P></LI></UL>

<A NAME="Complexity"><H3>Complexity</H3></A>
<P>All iterator operations are required to take at most amortized constant time.</P>
<A NAME="Interface"><H3>Interface</H3></A>
<PRE>template &#60;class BidirectionalIterator,
          class T,
          class Reference = T&#38;,
          class Pointer = T*,
          class Distance = ptrdiff_t>
class reverse_bidirectional_iterator
   : public bidirectional_iterator&#60;T, Distance>  {
    typedef reverse_bidirectional_iterator&#60;BidirectionalIterator, T, 
                                           Reference,            
                                           Pointer, Distance> self;
    friend bool operator== (const self&#38;, const self&#38;);
  public:
    reverse_bidirectional_iterator ();
    explicit reverse_bidirectional_iterator
      (BidirectionalIterator);
    BidirectionalIterator base ();
    Reference operator* ();
    self&#38; operator++ ();
    self operator++ (int);
    self&#38; operator-- ();
    self operator-- (int);
  };
// Non-member Operator
  template &#60;class BidirectionalIterator,
            class T,
            class Reference,
            class Pointer
            class Distance>
  bool operator== (
     const reverse_bidirectional_iterator
        &#60;BidirectionalIterator,
         T,
         Reference,
         Pointer
         Distance>&#38;,
      const reverse_bidirectional_iterator
        &#60;BidirectionalIterator,
         T,
         Reference,
         Pointer,
         Distance>&#38;);
template &#60;class RandomAccessIterator,
          class T,
          class Reference = T&#38;,
          class Pointer = T*,
          class Distance = ptrdiff_t>
class reverse_iterator
   : public random_access_iterator&#60;T, Distance>  {
    typedef reverse_iterator&#60;RandomAccessIterator, T, Reference, 
                             Pointer, Distance> self;
    friend bool operator==    (const self&#38;, const self&#38;);
    friend bool operator&#60;     (const self&#38;, const self&#38;);
    friend Distance operator- (const self&#38;, const self&#38;);
    friend self operator+     (Distance, const self&#38;);
 
public:
    reverse_iterator ();
    explicit reverse_iterator (RandomAccessIterator);
    RandomAccessIterator base ();
    Reference operator* ();
    self&#38; operator++ ();
    self operator++ (int);
    self&#38; operator-- ();
    self operator-- (int);
    self  operator+ (Distance) const;
    self&#38; operator+= (Distance);
    self operator- (Distance) const;
    self&#38; operator-= (Distance);
    Reference operator[] (Distance);
};
// Non-member Operators
    template &#60;class RandomAccessIterator, class T,
              class Reference, class Pointer,
              class Distance> bool operator== (
        const reverse_iterator&#60;RandomAccessIterator, T,
                               Reference, Pointer,
                               Distance>&#38;,
        const reverse_iterator&#60;RandomAccessIterator, T,
                               Reference, Pointer,
                               Distance>&#38;);
     template &#60;class RandomAccessIterator, class T,
               class Reference, class Pointer,
               class Distance> bool operator&#60; (
         const reverse_iterator&#60;RandomAccessIterator, T,
                                Reference, Pointer,
                                Distance>&#38;,
         const reverse_iterator&#60;RandomAccessIterator, T,
                                Reference, Pointer,
                                Distance>&#38;);
     template &#60;class RandomAccessIterator, class T,
               class Reference, class Pointer,
               class Distance> Distance operator- (
         const reverse_iterator&#60;RandomAccessIterator, T,
                                Reference, Pointer,
                                Distance>&#38;,
         const reverse_iterator&#60;RandomAccessIterator, T,
                                Reference, Pointer,
                                Distance>&#38;);
     template &#60;class RandomAccessIterator, class T,
               class Reference, class Pointer,
               class Distance> 
      reverse_iterator&#60;RandomAccessIterator, T,
                       Reference, Pointer,
                       Distance> operator+ (
         Distance, 
         const reverse_iterator&#60;RandomAccessIterator, T,
                                Reference, Pointer,
                                Distance>&#38;);
</PRE>
<A NAME="Example"><H3>Example</H3></A>
<PRE>//
// rev_itr.cpp
//
 #include &#60;iterator>
 #include &#60;vector>
 #include &#60;iostream.h>
 int main()
 {
   //Initialize a vector using an array
   int arr[4] = {3,4,7,8};
   vector&#60;int> v(arr,arr+4);</PRE><PRE>   //Output the original vector
   cout &#60;&#60; "Traversing vector with iterator: " &#60;&#60; endl &#60;&#60; "     ";
   for(vector&#60;int>::iterator i = v.begin(); i != v.end(); i++)
     cout &#60;&#60; *i &#60;&#60; " ";</PRE><PRE>   //Declare the reverse_iterator
   vector&#60;int>::<B>reverse_iterator</B> rev(v.end());
   vector&#60;int>::<B>reverse_iterator</B> rev_end(v.begin());</PRE><PRE>   //Output the vector backwards
   cout &#60;&#60; endl &#60;&#60; endl;
   cout &#60;&#60; "Same vector, same loop, reverse_itertor: " &#60;&#60; endl        &#60;&#60; "     ";</PRE>
<PRE>   for(; rev != rev_end; rev++)
     cout &#60;&#60; *rev &#60;&#60; " ";</PRE><PRE>   return 0;
 }
Output :
Traversing vector with iterator:
     3 4 7 8
Same vector, same loop, reverse_itertor:
     8 7 4 3</PRE>
<A NAME="Warning"><H3>Warning</H3></A>
<P>If your compiler does not support default template parameters, then you need to always supply the <SAMP>Allocator</SAMP> template argument.  For instance, you will need to write :</P>
<P><SAMP>vector&#60;int, allocator></SAMP></P>
<P>instead of :</P>
<P><SAMP>vector&#60;int></SAMP></P>
<A NAME="See Also"><H3>See Also</H3></A>
<P><A HREF="Ite_5295.htm"><B><I>Iterators</B></I></A></P>
<HR>
<A HREF="rev_6652.htm"><IMG SRC="images/prev.gif"></A> <A HREF="ref.htm#contents"><IMG SRC="images/toc.gif"></A> <A HREF="rev_6851.htm"><IMG SRC="images/next.gif"></A></BODY></HTML>
