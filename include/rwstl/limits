#ifndef __STD_LIMITS
#define __STD_LIMITS

/***************************************************************************
 *
 * limits - Declarations for the Standard Library limits class
 *
 * $Id: limits@#/main/sl1main/sl121main/1  03/11/97 19:36:40  smithey (SL121RA_UNIX)
 *
 ***************************************************************************
 *
 * (c) Copyright 1994-1997 Rogue Wave Software, Inc.
 * ALL RIGHTS RESERVED
 *
 * The software and information contained herein are proprietary to, and
 * comprise valuable trade secrets of, Rogue Wave Software, Inc., which
 * intends to preserve as trade secrets such software and information.
 * This software is furnished pursuant to a written license agreement and
 * may be used, copied, transmitted, and stored only in accordance with
 * the terms of such license and with the inclusion of the above copyright
 * notice.  This software and information or any other copies thereof may
 * not be provided or otherwise made available to any other person.
 *
 * Notwithstanding any other lease or license that may pertain to, or
 * accompany the delivery of, this computer software and information, the
 * rights of the Government regarding its use, reproduction and disclosure
 * are as set forth in Section 52.227-19 of the FARS Computer
 * Software-Restricted Rights clause.
 * 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions as set forth in subparagraph (c)(1)(ii) of the Rights in
 * Technical Data and Computer Software clause at DFARS 252.227-7013.
 * Contractor/Manufacturer is Rogue Wave Software, Inc.,
 * P.O. Box 2328, Corvallis, Oregon 97339.
 *
 * This computer software and information is distributed with "restricted
 * rights."  Use, duplication or disclosure is subject to restrictions as
 * set forth in NASA FAR SUP 18-52.227-79 (April 1985) "Commercial
 * Computer Software-Restricted Rights (April 1985)."  If the Clause at
 * 18-52.227-74 "Rights in Data General" is specified in the contract,
 * then the "Alternate III" clause applies.
 *
 **************************************************************************/

#include <stdcomp.h>
#include <rw/stddefs.h>
#include <rw/math.h>

#ifndef RWSTD_NO_NEW_HEADER
#include <cfloat>
#include <climits>
#ifdef RWSTD_REQUIRES_IEEEFP
#include <ieeefp.h>	// for siemens
#endif
#else
#include <float.h>
#ifdef RWSTD_REQUIRES_IEEEFP
#include <ieeefp.h>	// for siemens
#endif
#include <limits.h>
#endif

//
// Turn off the warnings under the MSVC compiler that
// say 'bool reserved for future use'
//
#ifdef RWSTD_MSVC_BOOL_WARNING
#pragma warning ( disable : 4237 )
#endif


#ifndef RWSTD_NO_NAMESPACE
namespace std {
#endif

#ifdef __OS2__
#  ifdef max
#     undef max
#  endif
#  ifdef min
#     undef min
#  endif
#endif /*__OS2__*/   

enum float_round_style
{
    round_indeterminable      = -1,
    round_toward_zero         =  0,
    round_to_nearest          =  1,
    round_toward_infinity     =  2,
    round_toward_neg_infinity =  3
};

template <class T>
class RWSTDHuge numeric_limits
{
  public:

    static const bool is_specialized;

  static inline T min () RWSTD_INLINE_NO_THROW { return RWSTD_STATIC_CAST(T,0); }
  static inline T max () RWSTD_INLINE_NO_THROW { return RWSTD_STATIC_CAST(T,0); }

    static const int digits;
    static const int digits10;

    static const bool is_signed;
    static const bool is_integer;
    static const bool is_exact;

    static const int radix;
    static inline T  epsilon     () RWSTD_INLINE_NO_THROW { return RWSTD_STATIC_CAST(T,0); }
    static inline T  round_error () RWSTD_INLINE_NO_THROW { return RWSTD_STATIC_CAST(T,0); }

    static const int min_exponent;
    static const int min_exponent10; 
    static const int max_exponent;
    static const int max_exponent10;

    static const bool has_infinity;
    static const bool has_quiet_NaN;
    static const bool has_signaling_NaN;
    static const bool has_denorm;
    static const bool has_denorm_loss;

    static inline T infinity      () RWSTD_INLINE_NO_THROW { return RWSTD_STATIC_CAST(T,0); }
    static inline T quiet_NaN     () RWSTD_INLINE_NO_THROW { return RWSTD_STATIC_CAST(T,0); }
    static inline T signaling_NaN () RWSTD_INLINE_NO_THROW { return RWSTD_STATIC_CAST(T,0); }

  static inline T denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool is_iec559;
    static const bool is_bounded;
    static const bool is_modulo;

    static const bool traps;
    static const bool tinyness_before;

    static const float_round_style round_style;
};

#ifndef RWSTD_NO_TEMPLATE_SPECIALIZATION  
template <class T>
const bool numeric_limits<T>::is_specialized = false;

template <class T>
const int numeric_limits<T>::digits = 0;

template <class T>
const int numeric_limits<T>::digits10 = 0;

template <class T>
const bool numeric_limits<T>::is_signed = false;

template <class T>
const bool numeric_limits<T>::is_integer = false;

template <class T>
const bool numeric_limits<T>::is_exact = false;

template <class T>
const int numeric_limits<T>::radix = 0;

template <class T>
const int numeric_limits<T>::min_exponent10 =0; 

template <class T>
const int numeric_limits<T>::max_exponent10 = 0;

template <class T>
const int numeric_limits<T>::min_exponent = 0;

template <class T>
const int numeric_limits<T>::max_exponent = 0;

template <class T>
const bool RWSTDExportTemplate numeric_limits<T>::has_infinity = false;

template <class T>
const bool numeric_limits<T>::has_quiet_NaN = false;

template <class T>
const bool numeric_limits<T>::has_signaling_NaN = false;    

template <class T>
const bool numeric_limits<T>::is_iec559 = false;

template <class T>
const bool numeric_limits<T>::is_bounded = false;

template <class T>
const bool numeric_limits<T>::is_modulo = false;

template <class T>
const bool numeric_limits<T>::has_denorm = false;
 
template <class T>
const bool numeric_limits<T>::has_denorm_loss = false;

template <class T>
const bool numeric_limits<T>::traps = false;

template <class T>
const bool numeric_limits<T>::tinyness_before = false;

template <class T>
const float_round_style numeric_limits<T>::round_style = round_toward_zero;
#endif


#if !defined(RWSTD_NO_STI_SIMPLE) && defined(RWSTD_FLT_ROUNDS_IS_CONSTANT)
#define __RW_INIT(n) = n
#else
#define __RW_INIT(n) /**/
#endif


//**********************************************************************
//
// Assumptions made in this implementation:
//
//   1) numeric_limits<int>::radix equals numeric_limits<T>::radix
//      for all integral T specialized in this file.
//
//   2) numeric_limits<int>::is_modulo equals numeric_limits<T>::is_modulo
//      for all signed integral T specialized in this file, except
//      numeric_limits<bool>::is_modulo, which is assumed to be false.
//
//   3) numeric_limts<T>::traps == false for all builtin integral T.
//
// Does there exist a machine for which these aren't true?
//
//**********************************************************************


//**********************************************************************
//
// If your compiler allows in-class initialization of static const data
// members of integral type, then look for all lines having a comment of
// the form
//
//       // VENDOR
//
// and set the value on that line to the proper one for your environment.
//
// If your compiler does NOT allow in-class initialization of static const
// data members of integral type, then you'll need to set the values in
// stdlib/src/limits/limits.cpp so they're properly archived into the
// Standard Library.
//
//**********************************************************************


//
// Specialization for float.
//
/*
#ifdef macintosh
# define FLT_MIN 1.17549E-38
# define FLT_MAX 3.40282E+38
# define FLT_MANT_DIG 24
# define FLT_DIG 6
#endif
*/
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<float>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline float min ()  RWSTD_INLINE_NO_THROW { return FLT_MIN; }
    static inline float max ()  RWSTD_INLINE_NO_THROW { return FLT_MAX; }

    static const RWSTDExportTemplate int digits   __RW_INIT(FLT_MANT_DIG);
    static const RWSTDExportTemplate int digits10 __RW_INIT(FLT_DIG);

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(true);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(false);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(false);

    static const  int RWSTDExportTemplate radix __RW_INIT(FLT_RADIX);

    static inline float epsilon () RWSTD_INLINE_NO_THROW { return FLT_EPSILON; }
    static float RWSTDExportTemplate round_error    () RWSTD_INLINE_NO_THROW;

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(FLT_MIN_EXP);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(FLT_MIN_10_EXP);
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(FLT_MAX_EXP);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(FLT_MAX_10_EXP);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);            // VENDOR

    static float infinity      () RWSTD_INLINE_NO_THROW;
    static float quiet_NaN     () RWSTD_INLINE_NO_THROW;
    static float signaling_NaN () RWSTD_INLINE_NO_THROW;
    static float denorm_min    () RWSTD_INLINE_NO_THROW;

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);                   // VENDOR
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(false);                   // VENDOR

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);              // VENDOR
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);              // VENDOR

  static const float_round_style RWSTDExportTemplate round_style __RW_INIT(RWSTD_STATIC_CAST(float_round_style,FLT_ROUNDS));
};

//
// Specialization for double.
//

RWSTD_TEMPLATE
class RWSTDExport numeric_limits<double>
{
  public:

    static const bool RWSTDExportTemplate is_specialized  __RW_INIT(true);

    static inline double min ()  RWSTD_INLINE_NO_THROW { return DBL_MIN; }
    static inline double max ()  RWSTD_INLINE_NO_THROW { return DBL_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(DBL_MANT_DIG);
    static const int RWSTDExportTemplate digits10 __RW_INIT(DBL_DIG);

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(true);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(false);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(false);

    static const int RWSTDExportTemplate radix __RW_INIT(FLT_RADIX);

    static inline double epsilon () RWSTD_INLINE_NO_THROW { return DBL_EPSILON; }
    static double round_error    () RWSTD_INLINE_NO_THROW;

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(DBL_MIN_EXP);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(DBL_MIN_10_EXP);
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(DBL_MAX_EXP);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(DBL_MAX_10_EXP);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);            // VENDOR

    static double infinity      () RWSTD_INLINE_NO_THROW;
    static double quiet_NaN     () RWSTD_INLINE_NO_THROW;
    static double signaling_NaN () RWSTD_INLINE_NO_THROW;
    static double denorm_min    () RWSTD_INLINE_NO_THROW;

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);                   // VENDOR
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(false);                   // VENDOR

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);              // VENDOR
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);              // VENDOR

  static const float_round_style RWSTDExportTemplate round_style __RW_INIT(RWSTD_STATIC_CAST(float_round_style,FLT_ROUNDS));
};

//
// Specialization for long double.
//

#ifndef RWSTD_NO_LONGDOUBLE
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<long double>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline long double min () RWSTD_INLINE_NO_THROW { return LDBL_MIN; } 
    static inline long double max () RWSTD_INLINE_NO_THROW { return LDBL_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(LDBL_MANT_DIG);
    static const int RWSTDExportTemplate digits10 __RW_INIT(LDBL_DIG);

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(true);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(false);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(false);

    static const int RWSTDExportTemplate radix __RW_INIT(FLT_RADIX);

    static inline long double epsilon () RWSTD_INLINE_NO_THROW { return LDBL_EPSILON; }
    static long double round_error    () RWSTD_INLINE_NO_THROW;

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(LDBL_MIN_EXP);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(LDBL_MIN_10_EXP);
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(LDBL_MAX_EXP);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(LDBL_MAX_10_EXP);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);            // VENDOR
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);            // VENDOR

    static long double RWSTDExportTemplate infinity      () RWSTD_INLINE_NO_THROW;
    static long double RWSTDExportTemplate quiet_NaN     () RWSTD_INLINE_NO_THROW;
    static long double RWSTDExportTemplate signaling_NaN () RWSTD_INLINE_NO_THROW;
    static long double RWSTDExportTemplate denorm_min    () RWSTD_INLINE_NO_THROW;

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);                   // VENDOR
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(false);                   // VENDOR

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);              // VENDOR
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);              // VENDOR

  static const float_round_style RWSTDExportTemplate round_style __RW_INIT(RWSTD_STATIC_CAST(float_round_style,FLT_ROUNDS));
};
#endif /* RWSTD_NO_LONGDOUBLE */

//
// Specialization for int.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<int>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline int min ()  RWSTD_INLINE_NO_THROW { return INT_MIN; }
    static inline int max ()  RWSTD_INLINE_NO_THROW { return INT_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(CHAR_BIT*sizeof(int)-1);
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(true);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(2);                             // VENDOR

    static inline int epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline int round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline int RWSTDExportTemplate infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline int RWSTDExportTemplate quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline int RWSTDExportTemplate signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline int RWSTDExportTemplate denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(false);                   // VENDOR

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero); 
};

#ifndef RWSTD_NO_OVERLOAD_WCHAR
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<wchar_t>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static wchar_t min () RWSTD_INLINE_NO_THROW;
    static wchar_t max () RWSTD_INLINE_NO_THROW;

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(true);                    // VENDOR

    static const int RWSTDExportTemplate digits   __RW_INIT(is_signed ? CHAR_BIT*sizeof(wchar_t) - 1 : CHAR_BIT*sizeof(wchar_t));
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline wchar_t epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline wchar_t round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline wchar_t RWSTDExportTemplate infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline wchar_t RWSTDExportTemplate quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline wchar_t RWSTDExportTemplate signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline wchar_t RWSTDExportTemplate denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(is_signed ? numeric_limits<int>::is_modulo : true);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};
#endif /*!RWSTD_NO_OVERLOAD_WCHAR*/

//**********************************************************************
//
// There are no VENDOR-settable values beyond this point.
//
//**********************************************************************

//
// Specialization for short.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<short>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline short min ()  RWSTD_INLINE_NO_THROW { return SHRT_MIN; }
    static inline short max ()  RWSTD_INLINE_NO_THROW { return SHRT_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(CHAR_BIT*sizeof(short)-1);
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(true);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline short epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline short round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);


    static inline short RWSTDExportTemplate infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline short RWSTDExportTemplate quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     } 
    static inline short RWSTDExportTemplate signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline short RWSTDExportTemplate denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(numeric_limits<int>::is_modulo);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};

//
// Specialization for unsigned short.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<unsigned short>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline unsigned short min ()  RWSTD_INLINE_NO_THROW { return 0;         }
    static inline unsigned short max ()  RWSTD_INLINE_NO_THROW { return USHRT_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(CHAR_BIT*sizeof(unsigned short));
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline unsigned short epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline unsigned short round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline unsigned short infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned short quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned short signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned short denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(true);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};

//
// Specialization for unsigned int.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<unsigned int>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline unsigned int min ()  RWSTD_INLINE_NO_THROW { return 0;        }
    static inline unsigned int max ()  RWSTD_INLINE_NO_THROW { return UINT_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(CHAR_BIT*sizeof(unsigned int));
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline unsigned int epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline unsigned int round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline unsigned int infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned int quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned int signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned int denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(true);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};

//
// Specialization for long.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<long>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline long min ()  RWSTD_INLINE_NO_THROW { return LONG_MIN; }
    static inline long max ()  RWSTD_INLINE_NO_THROW { return LONG_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(CHAR_BIT*sizeof(long)-1);
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(true);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline long epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline long round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0); 
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline long infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline long quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline long signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline long denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(numeric_limits<int>::is_modulo);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};

//
// Specialization for unsigned long.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<unsigned long>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline unsigned long min ()  RWSTD_INLINE_NO_THROW { return 0;         }
    static inline unsigned long max ()  RWSTD_INLINE_NO_THROW { return ULONG_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(CHAR_BIT*sizeof(unsigned long));
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline unsigned long epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline unsigned long round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0); 
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline unsigned long infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned long quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned long signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned long denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(true);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};

//
// Specialization for char.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<char>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline char min ()  RWSTD_INLINE_NO_THROW { return CHAR_MIN; }
    static inline char max ()  RWSTD_INLINE_NO_THROW { return CHAR_MAX; }

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(CHAR_MAX == SCHAR_MAX ? true : false);

    static const int RWSTDExportTemplate digits   __RW_INIT(is_signed ? CHAR_BIT*sizeof(char) -1 : CHAR_BIT*sizeof(char));
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline char epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline char round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0); 
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline char infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline char quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline char signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline char denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }
    
    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(is_signed ? numeric_limits<int>::is_modulo : true);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};

//
// Specialization for unsigned char.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<unsigned char>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline unsigned char min ()  RWSTD_INLINE_NO_THROW { return 0;         }
    static inline unsigned char max ()  RWSTD_INLINE_NO_THROW { return UCHAR_MAX; }

    static const int RWSTDExportTemplate digits   __RW_INIT(CHAR_BIT*sizeof(unsigned char));
    static const int RWSTDExportTemplate digits10 __RW_INIT(int(digits/3.321928095)); 

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline unsigned char epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline unsigned char round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0); 
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline unsigned char infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned char quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned char signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline unsigned char denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(true);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};

//
// Specialization for signed char.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<signed char>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline signed char min ()  RWSTD_INLINE_NO_THROW { return SCHAR_MIN; }
    static inline signed char max ()  RWSTD_INLINE_NO_THROW { return SCHAR_MAX; }

    static const RWSTDExportTemplate int digits   __RW_INIT(CHAR_BIT*sizeof(signed char)-1);
    static const RWSTDExportTemplate int digits10 __RW_INIT(int(digits/3.321928095));

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(true);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline signed char epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline signed char round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0); 
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline signed char infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline signed char quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline signed char signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline signed char denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(numeric_limits<int>::is_modulo);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};

#ifndef RWSTD_NO_BOOL
//
// Specialization for bool.
//
RWSTD_TEMPLATE
class RWSTDExport numeric_limits<bool>
{
  public:

    static const bool RWSTDExportTemplate is_specialized __RW_INIT(true);

    static inline bool min ()  RWSTD_INLINE_NO_THROW { return false; }
    static inline bool max ()  RWSTD_INLINE_NO_THROW { return true;  }

    static const RWSTDExportTemplate int digits   __RW_INIT(1);
    static const RWSTDExportTemplate int digits10 __RW_INIT(0);

    static const bool RWSTDExportTemplate is_signed  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_integer __RW_INIT(true);
    static const bool RWSTDExportTemplate is_exact   __RW_INIT(true);

    static const int RWSTDExportTemplate radix __RW_INIT(numeric_limits<int>::radix);

    static inline bool epsilon     () RWSTD_INLINE_NO_THROW { return 0; }
    static inline bool round_error () RWSTD_INLINE_NO_THROW { return 0; }

    static const int RWSTDExportTemplate min_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate min_exponent10 __RW_INIT(0); 
    static const int RWSTDExportTemplate max_exponent   __RW_INIT(0);
    static const int RWSTDExportTemplate max_exponent10 __RW_INIT(0);

    static const bool RWSTDExportTemplate has_infinity      __RW_INIT(false);
    static const bool RWSTDExportTemplate has_quiet_NaN     __RW_INIT(false);
    static const bool RWSTDExportTemplate has_signaling_NaN __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm        __RW_INIT(false);
    static const bool RWSTDExportTemplate has_denorm_loss   __RW_INIT(false);

    static inline int infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline int quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline int signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
    static inline int denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

    static const bool RWSTDExportTemplate is_iec559  __RW_INIT(false);
    static const bool RWSTDExportTemplate is_bounded __RW_INIT(true);
    static const bool RWSTDExportTemplate is_modulo  __RW_INIT(false);

    static const bool RWSTDExportTemplate traps           __RW_INIT(false);
    static const bool RWSTDExportTemplate tinyness_before __RW_INIT(false);

    static const float_round_style RWSTDExportTemplate round_style __RW_INIT(round_toward_zero);
};
#endif /*!RWSTD_NO_BOOL*/

#undef __RW_INIT

#ifdef  RWSTD_TRICKY_MOVE_TO_HEADER 
//**********************************************************************
//
// Vendors MUST set the following functions to their proper values.
//
//**********************************************************************

float numeric_limits<float>::round_error   () RWSTD_INLINE_NO_THROW { return .5F;   }
float numeric_limits<float>::infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
float numeric_limits<float>::quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
float numeric_limits<float>::signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
float numeric_limits<float>::denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

double numeric_limits<double>::round_error   () RWSTD_INLINE_NO_THROW { return .5;    }
double numeric_limits<double>::infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
double numeric_limits<double>::quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
double numeric_limits<double>::signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
double numeric_limits<double>::denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }

#ifndef RWSTD_NO_LONGDOUBLE
long double numeric_limits<long double>::round_error   () RWSTD_INLINE_NO_THROW { return .5L;   }
long double numeric_limits<long double>::infinity      () RWSTD_INLINE_NO_THROW { return 0;     }
long double numeric_limits<long double>::quiet_NaN     () RWSTD_INLINE_NO_THROW { return 0;     }
long double numeric_limits<long double>::signaling_NaN () RWSTD_INLINE_NO_THROW { return 0;     }
long double numeric_limits<long double>::denorm_min    () RWSTD_INLINE_NO_THROW { return min(); }
#endif

#ifndef RWSTD_NO_OVERLOAD_WCHAR
wchar_t numeric_limits<wchar_t>::min () RWSTD_INLINE_NO_THROW { return INT_MIN; }
wchar_t numeric_limits<wchar_t>::max () RWSTD_INLINE_NO_THROW { return INT_MAX; }
#endif
#endif /*  RWSTD_TRICKY_MOVE_TO_HEADER */

#ifndef RWSTD_NO_NAMESPACE 
} 
#endif

#endif /*__STD_LIMITS*/


